<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANLT-9570</title>
  
  
  <link href="https://anlt-9570.github.io/atom.xml" rel="self"/>
  
  <link href="https://anlt-9570.github.io/"/>
  <updated>2022-05-04T09:02:10.555Z</updated>
  <id>https://anlt-9570.github.io/</id>
  
  <author>
    <name>xc9570</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keepalived+nginx集群的使用</title>
    <link href="https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/"/>
    <id>https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/</id>
    <published>2022-05-04T00:59:00.380Z</published>
    <updated>2022-05-04T09:02:10.555Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>准备多台机器：144，145</p><p>使用yum安装Keepalived</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br></pre></td></tr></table></div></figure><p>安装完后，默认安装在<code>/etc/keepalived</code>该路径</p><p><code>144</code>修改keepalived.conf文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>145</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>脚本nginx_check.sh文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">A=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">echo &#x27;-----&gt;144...心跳检测....&#x27;</span><br><span class="line">if [ $A ];then</span><br><span class="line">echo &quot;true....&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;restarting......&quot;</span><br><span class="line">docker start nginx</span><br><span class="line">fi</span><br><span class="line">sleep 5s #时间不能大于脚本的执行间隔时间</span><br><span class="line">C=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">if [ $C ];then</span><br><span class="line">echo &quot;to start success...&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;Fails to start.....&quot;</span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>需要给脚本赋予权限，不然可能执行失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx_check.sh</span><br></pre></td></tr></table></div></figure><p>keepalived启动</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></div></figure><p>查看状态</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status keepalived.service</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.66/">http://192.168.66.66</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>tip：如果脚本没有生效，需要修改<code>/etc/selinux/config</code>文件的<code>SELINUX=disabled</code>;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="keepalived" scheme="https://anlt-9570.github.io/categories/keepalived/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx使用</title>
    <link href="https://anlt-9570.github.io/2022/04/28/nginx/n/"/>
    <id>https://anlt-9570.github.io/2022/04/28/nginx/n/</id>
    <published>2022-04-28T13:16:51.048Z</published>
    <updated>2022-05-04T07:05:40.296Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="nginx-conf文件的简单概述">          <a href="#nginx-conf文件的简单概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx-conf文件的简单概述" class="headerlink" title="nginx.conf文件的简单概述"></a>nginx.conf文件的简单概述</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main#全局配置</span><br><span class="line"></span><br><span class="line">events &#123;#工作模式与连接数上限</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123; //http服务器</span><br><span class="line"></span><br><span class="line">server &#123; //虚拟主机 可以有多个虚拟主机</span><br><span class="line">...</span><br><span class="line">location &#123;#路由配置匹配（虚拟目录等）</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location path&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location otherPath&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123; //虚拟主机</span><br><span class="line">    ...</span><br><span class="line">    location &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">upstream name &#123;//负载均衡器</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Nginx基本使用">          <a href="#Nginx基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Nginx基本使用" class="headerlink" title="Nginx基本使用"></a>Nginx基本使用</h1>      <p>使用docker使用nginx，提前创建好挂载目录，并赋予nginx.conf权限，不然挂载失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx.conf</span><br></pre></td></tr></table></div></figure><p>运行并挂载容器等</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 80:80 -p 801:801 -p 802:802 -p 803:803 --name nginx --privileged=true -v /opt/nginx/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#nginx运行的用户或者用户组,windows下默认是nobody可以注释掉，docker下默认nginx用户</span><br><span class="line">user  nginx;</span><br><span class="line">#nginx进程数 (cpu核心数)</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">#进程文件，windows下可以注释掉</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">#connections 20000; 每个进程应许的最多连接数</span><br><span class="line">#单个进程最大连接数(最大连接数=连接数*进程数)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">#访问日志</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">#文件的传输模式</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">#最长连接超时时间，单位秒默认0</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;d</span><br><span class="line">#虚拟主机配置</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 802; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">        server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">            location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">                root /usr/share/nginx/html; #指定目录</span><br><span class="line">                index index.html; #不配置默认index.html</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server&#123;</span><br><span class="line">    listen 803; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">    server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">    location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">    root /usr/share/nginx/html; #指定目录</span><br><span class="line">    index index.html; #不配置默认index.html</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://127.0.0.1:802/">http://127.0.0.1:802/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h1 id="匹配规则">          <a href="#匹配规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#匹配规则</span><br><span class="line">server_name有三种写法：精确名称，以星号开头或者结尾，正则表达式</span><br><span class="line">例：</span><br><span class="line">server_name www.xc.com</span><br><span class="line">server_name *.com www.xc.*</span><br><span class="line">server_name www./[A-Za-z]/g.com</span><br><span class="line"></span><br><span class="line">#location匹配符号</span><br><span class="line"></span><br><span class="line">优先级</span><br><span class="line">1 =精确匹配</span><br><span class="line">2 ^~以某个字符串开头</span><br><span class="line">3 ~区分大小写的正则匹配</span><br><span class="line">3 ~*不区分大小写的正则匹配</span><br><span class="line">4 /通用匹配，任何请求都会匹配到</span><br><span class="line"></span><br><span class="line">//精确匹配</span><br><span class="line">location /index.html &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/index.html</span><br><span class="line"></span><br><span class="line">//以某个字符开头</span><br><span class="line">location ^~ /b &#123;</span><br><span class="line">default_type text/html; //响应类型</span><br><span class="line">return 200 &#x27;9999&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/boss</span><br><span class="line"></span><br><span class="line">//区分大小写</span><br><span class="line">location ~ /Cc &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/Cc</span><br><span class="line"></span><br><span class="line">//不区分大小写</span><br><span class="line">location ~ /Dd &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/dd</span><br><span class="line"></span><br><span class="line">//前缀匹配</span><br><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/images/b.jpg</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h1 id="反向代理">          <a href="#反向代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1>      <p>在143的主机上代理144</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 801;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://192.168.66.1:1572; //代理的ip和端口</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://192.168.66.143:801/t</span><br></pre></td></tr></table></div></figure>        <h1 id="负载均衡">          <a href="#负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1>      <p>//默认轮训</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>负载均衡的几种策略方式；</p><p>1.轮询(默认)：轮流分发到不同的机器；</p><p>2.weight(权重)：根据权重的比率进行分发，权重越高被分配的几率越打；(ip_hash策略的时候不可用)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:1572 weight=2;</span><br><span class="line">server 192.168.66.144:1572 weight=4;</span><br><span class="line">server 192.168.66.145:1572 weight=8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>3.ip_hash：根据IP进行hash分配，每个IP都会固定访问到一个机器；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>4.fair(第三方)：根据后端响应时间来分配请求，响应时间短的分配越多；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用fair之前，需要提前安装第三方插件，不然会报错，起不来;</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</span><br></pre></td></tr></table></div></figure><p>5.url_hash(第三方)</p><p>使用url_hash之前，也需要提前安装第三方插件，不然会报错，起不来;</p>        <h1 id="负载均衡调度参数">          <a href="#负载均衡调度参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡调度参数" class="headerlink" title="负载均衡调度参数"></a>负载均衡调度参数</h1>      <p>down：表示当前机器不参与负载均衡</p><p>backup：表示当前机器为备份机器，当其它所有的机器不可用之后，请求才回到当前机器，当其他机器可用之后，当前机器</p><p>max_fails：允许请求最大失败次数，超过最大次数暂停服务，默认为1；</p><p>fail_timeout：请求处理失败后，暂停指定的时间，然后重新连接；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tt&#123;</span><br><span class="line">    server 192.168.66.1:1572 down; //</span><br><span class="line">    server 192.168.66.1:1573 backup; //备份服务器</span><br><span class="line">    server 192.168.66.1:1574 max_fails=10 fail_timeout=10s;//重试10次后，暂停10s后重新连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="nginx其它参数">          <a href="#nginx其它参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx其它参数" class="headerlink" title="nginx其它参数"></a>nginx其它参数</h1>      <p>autoindex on;//列出目录内容</p><p>autoindex_exact_size on;//默认为on，显示出文件的大小</p><p>autoindex_localtime on;//显示文件的时间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    autoindex_localtime off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>allow指令：允许哪些IP访问，all表示运行所有；</p><p>deny指令：禁止哪些IP访问，all表示运行所有；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">deny all;</span><br><span class="line">allow 192.168.66.143;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Nginx" scheme="https://anlt-9570.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ使用</title>
    <link href="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/"/>
    <id>https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/</id>
    <published>2022-04-10T03:07:27.623Z</published>
    <updated>2022-04-28T03:04:16.749Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="RabbitMQ的几个主要成员">          <a href="#RabbitMQ的几个主要成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几个主要成员" class="headerlink" title="RabbitMQ的几个主要成员"></a>RabbitMQ的几个主要成员</h1>              <h2 id="1-Producer-生产者">          <a href="#1-Producer-生产者" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Producer-生产者" class="headerlink" title="1.Producer(生产者)"></a>1.Producer(生产者)</h2>      <p>生产消息的一端，可以指定交换机发送消息；</p><p>生产者可以在发送消息前声明Exchange(交换机)，Queue(队列)以及对于关系。</p>        <h2 id="2-Consumer-消费者">          <a href="#2-Consumer-消费者" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Consumer-消费者" class="headerlink" title="2.Consumer(消费者)"></a>2.Consumer(消费者)</h2>      <p>消费消息的一方，通过监听指定队列来消费消息。</p>        <h2 id="3-Exchange-交换机">          <a href="#3-Exchange-交换机" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Exchange-交换机" class="headerlink" title="3.Exchange(交换机)"></a>3.Exchange(交换机)</h2>      <p>用于接收、分配消息，存在多种不同类型的交换机处理特定需求。</p><p>不做存储，消息存储在队列中；交换机类型：direct(默认)，fanout，topics。</p>        <h2 id="4-Queue-队列">          <a href="#4-Queue-队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Queue-队列" class="headerlink" title="4.Queue(队列)"></a>4.Queue(队列)</h2>      <p>用于存储生产者的消息</p>        <h2 id="5-RoutingKey-路由键">          <a href="#5-RoutingKey-路由键" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-RoutingKey-路由键" class="headerlink" title="5.RoutingKey(路由键)"></a>5.RoutingKey(路由键)</h2>      <p>交换机和队列绑定的路由规则</p>        <h1 id="RabbitMQ的几种消息模型">          <a href="#RabbitMQ的几种消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几种消息模型" class="headerlink" title="RabbitMQ的几种消息模型"></a>RabbitMQ的几种消息模型</h1>      <p>基于springboot整合rabbitmq。</p><p>依赖</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure><p>配置文件配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">admin</span></span><br></pre></td></tr></table></div></figure>        <h2 id="1-基本消息模型">          <a href="#1-基本消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基本消息模型" class="headerlink" title="1.基本消息模型"></a>1.基本消息模型</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/1.png" alt="1"></p><p>以上图的模型中，有以下的概念：</p><p>P：生产者，也就是发送消息的一端</p><p>C：消费者，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>RabbitMQ的配置</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列，没有该队列时，会自动配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：队列名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久化默认true</span></span><br><span class="line"><span class="comment">         * boolean exclusive：是否独占(是否只能有一个消费者监听)默认false</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有消费者是否自动删除)默认false</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;xc.com.lt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String exchange //交换机 默认&quot;&quot;</span></span><br><span class="line"><span class="comment">         * String routingKey //路由键(或者队列名)</span></span><br><span class="line"><span class="comment">         * Message message //消息内容</span></span><br><span class="line"><span class="comment">         * CorrelationData correlationData 关联的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="消息确认机制">          <a href="#消息确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5>      <p>生产者：消息投递后，如果失败了，消息就会丢失而且我们自己也不会知道</p><p>消费者：消息消费后，在队列中的消息就会被删除，不管我们有没有消费成功</p><p>那么rabbitmq是怎么知道消息是否投递或者消费成功的呢？</p><p>生产者和消费者提供了几种模式；</p><p>生产者：</p><p>​    NONE：禁用发布确认模式，默认就是这种模式</p><p>​    CORRELATED：消息发布成功后，触发回调方法</p><p>​    SIMPLE：和CORRELATED一样回触发回调，但是比CORRELATED多了一些功能，比如使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待broker节点返回结果。</p><p>生产者的配置：</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment">#开启消息发送失败退回</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></div></figure><p>消息发送后会回调这个方法</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * correlationData：投递消息时附带的信息</span></span><br><span class="line"><span class="comment">     * ack：消息是否发送成功 true：成功，false：失败</span></span><br><span class="line"><span class="comment">     * cause：失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback((correlationData, ack, cause)-&gt;&#123;</span><br><span class="line">        System.out.println(ack);</span><br><span class="line">        System.out.println(cause);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//消息回退 returnedMessage：投递的信息如：交换机，路由键，消息等</span></span><br><span class="line">    rabbitTemplate.setReturnsCallback((returnedMessage)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(returnedMessage.getMessage().getBody()));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者：</p><p>​        NONE：自动应答（默认）</p><p>​        MANUL：收到应答，需要消费端手动回复确认</p><p>​        AUTO：根据监听器是否正常返回还是抛出异常来发出ack/nack。</p><p>实现方式</p><p>方式一配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></div></figure><p>方式二</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span><span class="comment">//监听队列时顺便通过 ackMode指定方式</span></span><br></pre></td></tr></table></div></figure><p>修改消费者，手动应答</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    <span class="comment">//deliveryTag:消息的deliveryTag标识，rabbitmq通过deliveryTag进行匹配;multiple:是否批量确认 true批量确认反之</span></span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="2-工作队列模式">          <a href="#2-工作队列模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-工作队列模式" class="headerlink" title="2.工作队列模式"></a>2.工作队列模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/2.png" alt="2"></p><p>工作队列模式有点类似于第一种，一个生产端，多个消费端同时消费一个队列，但是一个消息只能被一个消费者消费</p><p>P：生产者，也就是发送消息的一端</p><p>C1：消费者1，接收消息的一端</p><p>C2：消费者2，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>多个消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有多个消费者，rabbitmq实行的是消息均摊的方式，这样每个消费者所消费的消息都会差不多；这样不是很好，可能有一些消费的会比较快，有一些消费比较慢，快的在消费完后处于空闲状态，慢的会阻塞不能及时处理。</p><p>我们可以通过prefetch属性来表示该消费者每次只能从队列处理几个消息，处理完在取。比如prefetch=1表示每次只能从该队列取一条，消息没有处理完不会分配，这样就达到能者多劳。</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#一次处理的消息数量</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></div></figure>        <h2 id="3-订阅模式">          <a href="#3-订阅模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-订阅模式" class="headerlink" title="3.订阅模式"></a>3.订阅模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/5.png" alt="3"></p><p>和上面两种不同的是，这种模式多了个交换机。生产者把消息投递到交换机，交换机把消息分发到各个队列，不用指定路由键，交换机只负责分配消息，不做存储；每个监听的消费都会同时接收到消息。</p><p>而<b>fanout</b>类型的交换机可以做到这种模式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue1&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue2&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义fanout类型的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：交换机名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久换(默认true)</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有队列是否自动删除)(默认false)</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new FanoutExchange(&quot;fanoutExchange&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;fanoutExchange&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue1()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue2()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t4&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t4</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue1&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue2&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive4</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="4-路由模式">          <a href="#4-路由模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-路由模式" class="headerlink" title="4.路由模式"></a>4.路由模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/4.png" alt="3"></p><p>生产者向交换机投递消息时，可以指定路由键，交换机会根据路由键分发到指定队列。</p><p>而<b>direct</b>类型的交换机就是这种形式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;direct_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue5()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue6()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生存者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t6&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t6</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.1&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t7&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t7</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.2&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_1&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span><span class="comment">//注意这种要提前把队列和交换机创建好，不然气得会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive5</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_2&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive6</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="5-主题模式">          <a href="#5-主题模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-主题模式" class="headerlink" title="5.主题模式"></a>5.主题模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/6.png" alt="3"></p><p>topics(主题)模式和routing(路由)模式类似，只不过路由模式的键是固定的，而主题模式的路由键可以模糊匹配，类似于SQL 的 = 和 like关系。<b>*</b> 号表示匹配一个 <b>#</b> 表示匹配一个或多个</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue9</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue7()).to(topicsExchange()).with(<span class="string">&quot;topics.orange.rabbit&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue8()).to(topicsExchange()).with(<span class="string">&quot;*.orange.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue9()).to(topicsExchange()).with(<span class="string">&quot;lazy.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t8&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t8</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送后消费者1和2会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;topics.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t9</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">         <span class="comment">//发送后消费者2和3会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;lazy.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-a&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive7</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-b&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive8</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-3&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive9</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="死信队列">          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>      <p>当消息在队列中变成死信消息之后，它就会被重新转移到死信交换机(Dead-Letter-Exchange)简称DLX 。</p><p>变成死信消息的几种情况：消息被拒绝、消息过期、队列达到最大长度。</p><p>死信交换机和普通交换机没什么区别，它能够被任何的队列指定，当队列中消息成为死信消息时，就会重新发布到死信交换机上，进而路由到对应的队列上。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueDeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;deal-queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">dealExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;deal-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//普通队列绑定死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//map.put(&quot;x-message-ttl&quot;, 1000*5);//直接设置 Queue 延迟时间 但如果直接给队列设置过期时间,这种做法不是很灵活</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;deal-exchange&quot;</span>);<span class="comment">//交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;deal.routingKey.v1&quot;</span>);<span class="comment">//路由键</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;ordinary-queue-6&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">ordinaryExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;ordinary-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">ordinaryBindExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue11()).to(ordinaryExchange1()).with(<span class="string">&quot;ordinary.routingKey.v2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列与死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDealExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueDeal()).to(dealExchange1()).with(<span class="string">&quot;deal.routingKey.v1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t10</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;ordinary-exchange-2&quot;</span>,<span class="string">&quot;ordinary.routingKey.v2&quot;</span>,<span class="string">&quot;AMQP-&quot;</span>+a</span><br><span class="line">                ,(message)-&gt;&#123;</span><br><span class="line">                    message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>);<span class="comment">//设置消息过期时间</span></span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;deal-queue&quot;),exchange = @Exchange(value = &quot;deal-exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive10</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">&quot;ordinary_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>tip:如果队列和消息同时设置了过期时间则以最短的时间为准</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MQ" scheme="https://anlt-9570.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>docker单机、集群安装rabbitmq</title>
    <link href="https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/"/>
    <id>https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/</id>
    <published>2022-04-09T09:51:02.023Z</published>
    <updated>2022-05-04T07:42:46.774Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="单机安装">          <a href="#单机安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h1>      <p>拉取镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>创建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>访问<kbd><span class="exturl"><a class="exturl__link" href="http://ip:15672/">http://ip:15672</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd>并登陆，用户名密码默认都是guest</p><p>tips：如果<kbd>docker pull rabbitmq</kbd>后面不带management，启动mq是无法打开管理界面的，所以下载的时候要带management插件的rabbitmq</p>        <h1 id="集群安装">          <a href="#集群安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h1>      <p>RabbitMQ集群节点包含内存节点(RAM)、磁盘节点(Disk，消息持久化，默认)、集群中至少有一个Disk节点。集群分为三种模式：普通模式、镜像模式、仲裁队列(3.8版本以上才支持)。</p><p>普通模式：普通模式中，集群中各个节点有相同的的队列结构，但消息会存在集群中的某一个节点，对于消费者来说，若消息在A节点的Queue中，当从B节点拉取时，RabbitMQ会从A中取出消息，并经过B节点发送给消费者(不过如果A已经宕机，A节点的消息将会丢失)。</p><p>镜像模式：镜像模式就有点类似于主从，一个主节点，多个从节点，队列的所有操作都在主节点上完成，主节点的数据都会备份到从节点。如果是从节点接收到操作请求，会路由到主节点完成。</p>        <h2 id="普通集群配置">          <a href="#普通集群配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通集群配置" class="headerlink" title="普通集群配置"></a>普通集群配置</h2>      <p>先准备三台机器 <code>192.168.66.143(主)</code>,<code>192.168.66.144(备)</code>,<code>192.168.66.145(备)</code></p><p>在三台机器上创建文件夹，用于挂载docker容器 <code>mkdir -p /opt/rabbitmq</code></p><p>拉取MQ镜像 <code>docker pull rabbitmq:management</code></p><p>在各个机器上配置hosts</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.66.143 hadoop03</span><br><span class="line">192.168.66.144 hadoop04</span><br><span class="line">192.168.66.145 hadoop05</span><br></pre></td></tr></table></div></figure><p>在各个机器上先搭建单机</p><figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.66.143</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop03 --name r3 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.144</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop04 --name r4 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.145</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop05 --name r5 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="keyword">add</span><span class="bash">-host=<span class="string">&quot;hostname&quot;</span>:ip ：添加其它机器</span></span><br><span class="line">--hostname：容器的主机名称</span><br><span class="line">--name：容器名称</span><br></pre></td></tr></table></div></figure><p>RabbitMQ是基于Erlang语言的，集群中的每个RabbitMQ节点使用Erlang cookie来通信的，而且每个cookie的值都必须相同。</p><p>去主节点143上查看cookie值，并把144，145的cookie值改成143cookie的值</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cat /opt/rabbitmq/.erlang.cookie //查看143主机cookie值</span><br><span class="line"></span><br><span class="line">//修改144，145主机的cookie值，修改前必须先修改.erlang.cookie文件的权限，默认是只读权限</span><br><span class="line">$chmod 700 /opt/rabbitmq/.erlang.cookie //授予权限</span><br><span class="line"></span><br><span class="line">$vim /opt/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>192.168.66.143配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 无需太多配置，直接查看集群状态</span><br><span class="line">$ docker exec -it r3 bash</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br><span class="line">因为143是主节点，所以不需要过多的配置</span><br></pre></td></tr></table></div></figure><p>192.168.66.144配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r4 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster --ram rabbit@hadoop03 #加入集群 主节点是hadoop03 --ram表示设置为内存节点(默认disk磁盘)</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>192.168.66.145配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r5 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster rabbit@hadoop03 #加入集群 主节点是hadoop03</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>访问各个机器的地址：<a href="http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672">http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672</a></p>        <h2 id="SpringBoot集群配置使用">          <a href="#SpringBoot集群配置使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot集群配置使用" class="headerlink" title="SpringBoot集群配置使用"></a>SpringBoot集群配置使用</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    #单机连接</span><br><span class="line">    #    host: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span></span><br><span class="line">    #集群连接</span><br><span class="line">    addresses: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.144</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.145</span>:<span class="number">5672</span></span><br></pre></td></tr></table></div></figure><p>集群的时候生存者发送消息才会去创建队列</p>        <h2 id="镜像集群模式">          <a href="#镜像集群模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2>      <p>镜像模式基于普通模式，且具备高可用的能力。</p><p>镜像模式的配置有3种模式：exactly(建议),all,nodes</p>        <h3 id="exactly模式-建议使用这个模式">          <a href="#exactly模式-建议使用这个模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#exactly模式-建议使用这个模式" class="headerlink" title="exactly模式(建议使用这个模式)"></a>exactly模式(建议使用这个模式)</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_exactly &quot;^test*&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">-p admin：设置指定虚拟机</span><br><span class="line">ha_exactly：策略名称</span><br><span class="line">&quot;^test*&quot;：匹配队列的正则表达式；(匹配所有名称是以test开头的队列)</span><br><span class="line">&quot;ha-mode&quot;:&quot;exactly&quot;：策略模式，此处是exactly</span><br><span class="line">&quot;ha-params&quot;:2：策略参数，为ha-mode的补充；这里是2，就是副本数量为2，1主1镜像</span><br><span class="line">&quot;ha-sync-mode&quot;:&quot;automatic&quot;：同步策略，默认是manually，即新加入的镜像节点不会同步旧的消息；如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</span><br></pre></td></tr></table></div></figure>        <h3 id="all模式">          <a href="#all模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#all模式" class="headerlink" title="all模式"></a>all模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_all &quot;^all&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">ha_all：策略名称</span><br><span class="line">&quot;^all&quot;：匹配队列的正则表达式，这里是以all开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;all&quot;：all模式</span><br></pre></td></tr></table></div></figure>        <h3 id="nodes模式">          <a href="#nodes模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#nodes模式" class="headerlink" title="nodes模式"></a>nodes模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_nodes &quot;^nodes&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;，&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ha_nodes：策略名称</span><br><span class="line">&quot;^nodes&quot;：匹配队列的正则表达式，这里是以nodes开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;nodes&quot;：nodes模式</span><br><span class="line">&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]：策略参数，指定副本所在节点名称</span><br></pre></td></tr></table></div></figure>        <h3 id="RabbitMQ集成Nginx统一管理控制台">          <a href="#RabbitMQ集成Nginx统一管理控制台" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ集成Nginx统一管理控制台" class="headerlink" title="RabbitMQ集成Nginx统一管理控制台"></a>RabbitMQ集成Nginx统一管理控制台</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.143:802/">http://192.168.66.143:802</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MQ" scheme="https://anlt-9570.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>docker+jenkins实现自动化部署</title>
    <link href="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/"/>
    <id>https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/</id>
    <published>2022-04-07T04:50:52.109Z</published>
    <updated>2022-04-28T03:04:40.986Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="docker安装Jenkins">          <a href="#docker安装Jenkins" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker安装Jenkins" class="headerlink" title="docker安装Jenkins"></a>docker安装Jenkins</h2>      <p>先拉取jenkins</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br><span class="line">docker tag 镜像id jenkins //修改镜像名称方便书写</span><br></pre></td></tr></table></div></figure><p>创建jenkins的挂载目录并且授权不然容器没有权限会报错，方便后续配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/jenkins //-p 多级目录创建</span><br><span class="line">chmod 777 jenkins //授权</span><br></pre></td></tr></table></div></figure><p>创建并运行容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6060:8080 -p 50000:50000 -u root --privileged=true -v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker jenkins</span><br><span class="line"></span><br><span class="line">-p 6060:8080 //jenkins默认的访问端口是8080对外设置为6060</span><br><span class="line">-p 50000:50000  //Jenkins 可以公开一个允许入站代理连接到它的 TCP 端口</span><br><span class="line">-v /opt/jenkins:/var/jenkins_home //设置挂载的目录,jenkins生成的文件也会映射到容器外部的磁盘</span><br><span class="line">-u root --privileged=true -v //以root账号运行，方便后面jenkins执行shell脚本权限不够报错</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker //把docker也挂载到jenkins里面，执行shell脚本时需要用到docker指令，不然用不了</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器id//查看启动的结果,没有报错信息就是启动成功或者:docker ps /容器是否在运行</span><br></pre></td></tr></table></div></figure><p>启动成功后访问 <kbd><span class="exturl"><a class="exturl__link" href="http://ip:6060/">http://ip:6060</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd> 访问后会提示密码在 <kbd>/var/jenkins_home/secrets/initialAdminPassword</kbd> 文件里，先进入容器，然后查看密码</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 74d93f86e4ea /bin/bash //进入容器</span><br><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword //查看密码</span><br></pre></td></tr></table></div></figure><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0.png" alt="0"></p><p>选择安装推荐的插件(这里可能需要等久一点或者会报连接jenkins报错，只要你的网络没问题,点击重试就行)，创建账号密码登录进去.</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-1.png" alt="0-1"></p><p>等待……….</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\0-2.png" alt="0-2"></p><p>插件安装完成创建用户</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-3.png" alt="0-3"></p><p>选择左边侧边栏的 “系统管理” 在选择 “全局工具配置”</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\1.png" alt="1"></p><p>往下滑，找到 <b>JDK</b> 选择jdk安装</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/2.png" alt="2"></p><p>自动安装那里，默认是打钩的我已经把它去掉。选择自己已经安装有的jdk，别名可以随意取，可以通过<kbd>echo $JAVA_HOME</kbd>查看jdk的路径然后复制到JAVA_HOME路径里</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/3.png" alt="3"></p><p>往下滑找到maven选择自动安装，然后取个别名，选择maven的版本后点击保存。</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/4.png" alt="4"></p><p>配置完<b>jdk</b>和<b>maven</b>在安装一个maven的插件，主要用于构建maven项目方便</p><p>系统管理—&gt;插件管理</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/5.png" alt="5"></p><p>选择可选插件搜索maven选择 Pipeline Maven Integration 安装，因为我这里已经安装了，所以没有,可以在已安装那里看到</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/6.png" alt="6"></p><p>回到首页选择<b>新建任务</b>就会显示刚刚安装的maven插件，没安装是没有的，输入任务名称点击<b>构建一个maven项目</b>，点击确定</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/7.png" alt="7"></p><p>点击<b>源码管理</b>选择<b>Git</b> ,<b>URL</b>那里输入<b>Github</b>或者<b>Gitee</b>仓库的地址，选择添加，会弹出一个框，要求输入<b>Github</b>或者<b>Gitee</b>的账号和密码，添加完后<b>Credentials</b>那里就可以选择刚刚添加的账号了</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/8.png" alt="8"></p><p>点击build,Root POM下需要填写<kbd>项名称/pom.xml</kbd>,不然你仓库下有多个项目的话不知道使用哪个项目的pom文件或者任务名称和项目名称不一样也会找不到pom文件。Goals and options(目标和选择)主要用于打包时需要设置的参数，比如：设置jvm的堆栈的大小或者跳过maven测试等等…</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/9.png" alt="9"></p><p>点击<b>Post Steps</b>选择<b>Add post</b>下拉框选择 <b>执行shell</b>(jenkins打包完后执行shell，启动项目)，显示一个输入框就可以在里面写shell脚本</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/10.png" alt="10"></p><p>我的shell脚本</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#任务和项目必须一致，需要修改 pname ,ou,in,jport</span><br><span class="line">#!/bin/bash</span><br><span class="line">#任务名称 任务名称必须和项目名称一样</span><br><span class="line">pname=&quot;demo&quot;</span><br><span class="line">##构建容器时指定对外和对内端口</span><br><span class="line">ou=1586</span><br><span class="line">in=1586</span><br><span class="line">#jenkins端口</span><br><span class="line">jport=6060</span><br><span class="line">#会根据任务创建存放jar包目录</span><br><span class="line">p=/project/java/$pname/$pname/target</span><br><span class="line">#jenkins自动生成jar包的目录</span><br><span class="line">p3=/var/jenkins_home/workspace/$pname/$pname/target/</span><br><span class="line">#先删除以前的jar</span><br><span class="line">rm -rf $p</span><br><span class="line"></span><br><span class="line">#获取容器的id</span><br><span class="line">id=`docker ps -a|grep $pname| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#根据端口获取jenkins的容器id</span><br><span class="line">jid=`docker ps -a|grep $jport| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#镜像Id</span><br><span class="line">ll=`docker images|grep $pname|awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">#查找并切割获取jar包名称</span><br><span class="line">j=`find $p3 -name &#x27;*.jar&#x27; |cut -d&#x27;/&#x27; -f8`</span><br><span class="line">#判断容器是否在运行</span><br><span class="line">if [ $id ];then</span><br><span class="line"> echo $id</span><br><span class="line"> docker stop $id</span><br><span class="line"> docker rm $id</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;iiiiiiii&quot;</span><br><span class="line">fi</span><br><span class="line">#判断镜像是否存在</span><br><span class="line">if [ $ll ];then</span><br><span class="line"> docker rmi $ll</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;lllllll&quot;</span><br><span class="line"> echo $ll</span><br><span class="line">fi</span><br><span class="line">#创建文件</span><br><span class="line">mkdir -p $p</span><br><span class="line">#把jar复制到指定目录</span><br><span class="line">docker cp $jid:$p3/$j $p</span><br><span class="line">cd $p</span><br><span class="line">echo `pwd`</span><br><span class="line">#dockerfile创建写入</span><br><span class="line">echo &#x27;from java:8&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;add &#x27;$j&#x27; &#x27;$j&#x27;&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;entrypoint [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x27;$j&#x27;&quot;]&#x27; &gt;&gt; dockerfile</span><br><span class="line">cat dockerfile</span><br><span class="line">ls</span><br><span class="line">#运行构建容器</span><br><span class="line">docker build -t $pname .</span><br><span class="line">sleep 3</span><br><span class="line">docker run -d -p $ou:$in $pname</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>以上jenkins和要发布的项目都是在同一太机器上运行的…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>MySql_Test</title>
    <link href="https://anlt-9570.github.io/2022/03/22/mysql/Text/"/>
    <id>https://anlt-9570.github.io/2022/03/22/mysql/Text/</id>
    <published>2022-03-22T09:51:35.738Z</published>
    <updated>2022-06-13T08:48:01.892Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="后台线程">          <a href="#后台线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h1>      <p>​    InnoDB是多线程的模型，因此后台有多个不同的线程，负责处理同的任务</p>        <h2 id="Master-Thread">          <a href="#Master-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h2>      <p>​    Master Thread是后台核心线程，负责缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页数据、合并插入缓冲、UNDO页的回收等。</p>        <h2 id="IO-Thread">          <a href="#IO-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h2>      <p>​    IO Thread 使用AIO处理IO请求，主要负责IO请求回调处理。1.0后是read thread和write thread 共8个IO Thread。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;//查看缓冲池的情况</span><br><span class="line">show variables like &#x27;innodb_version&#x27;; //查看当前InnoDB当前版本</span><br><span class="line">show variables like &#x27;innodb_%io_threads&#x27;; //查看IO线程数</span><br></pre></td></tr></table></div></figure>        <h1 id="内存">          <a href="#内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存" class="headerlink" title="内存"></a>内存</h1>              <h2 id="缓冲池">          <a href="#缓冲池" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2>      <p>​    缓冲池就是一块内存，先将数据页从磁盘读取到缓冲池中，下次在读取数据时，回先判断是否在缓冲池中，若在则直接读取该数据，否则读取磁盘。对于修改操作，先修改缓冲池，然后在修改磁盘数据(不是每次数据更新就直接更新到磁盘，而是通过一种Checkpoint机制刷新回磁盘)。</p><p>​    缓冲池缓存的类型有：索引页、数据页、undo页、插入缓冲、锁信息、数据字典、自适应哈希索引等(页大小默认16kb)。</p><p>1.0版本后应许有多个缓冲池。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;; //查看缓冲池的大小</span><br><span class="line">//set global innodb_buffer_pool_size=8g //修改缓冲池的大小</span><br><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;; ////查看缓冲池的数量</span><br></pre></td></tr></table></div></figure>        <h3 id="LRU-list-Free-List-和Flush-List">          <a href="#LRU-list-Free-List-和Flush-List" class="heading-link"><i class="fas fa-link"></i></a><a href="#LRU-list-Free-List-和Flush-List" class="headerlink" title="LRU list,Free List,和Flush List"></a>LRU list,Free List,和Flush List</h3>      <p>Free List(空闲列表)：BufferPool初始化时，加载的页都是先放到Free List中，当缓存页被使用后，对应的Free List中去除掉，把该也放到LRU中。当有一个请求过来从磁盘读取到数据页后，就会在Free链表中获取一个空白的缓存页，把数据放到该链表中。</p><p>Flush List：LRU列表中的页被修改后，称为脏页，即缓冲池的数据和磁盘的数据不一致。该数据就会添加到Flush链表中，同时还会存在LRU链表中。</p><p>LRU（Latest Recent Used最近最少使用） List：被用过过后的页会被添加到该链表。频繁使用的页在列表顶端，少使用的在末端，缓冲池不能存放页时，将首先释放尾端的页。</p><p>InnoDB在LRU列表加入了midpoint位置，新读取的页，先放到LUR列表的midpoint位置。默认情况下，midpoint在LRU列表长度的5/8处。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_old_blocks_pct&#x27;; //查看midpoint位置(默认37)</span><br><span class="line">//可通过innodb_old_blocks_pct设置midpoint的位置</span><br><span class="line">//set global innodb_old_blocks_time=100//可通过该参数设置多久进入到new列表</span><br></pre></td></tr></table></div></figure><p>midpoint之前的称为new列表，之后的称为old列表。</p>        <h2 id="日志缓冲池-redo-log-buffer">          <a href="#日志缓冲池-redo-log-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志缓冲池-redo-log-buffer" class="headerlink" title="日志缓冲池(redo log buffer)"></a>日志缓冲池(redo log buffer)</h2>      <p>日志缓冲池主要存放日志信息，然后按照一定的频率将其刷新到磁盘(没秒刷新一次)。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log_buffer_size&#x27;;//查看大小(默认8MB)</span><br></pre></td></tr></table></div></figure>        <h2 id="Checkpoint技术">          <a href="#Checkpoint技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h2>      <p>数据库数据的持久性的保证：提交事务时，先写日志，然后在把数据刷新到磁盘中。</p>        <h1 id="日志文件">          <a href="#日志文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h1>      <p>redo log：记录事务执行过程中对数据库所做的所有修改。</p><p>慢查询日志：记录SQL语句查询慢于long_query_time指定的时间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_slow_queries&#x27;;//慢查询日志默认关闭 on //开启</span><br><span class="line">set global log_slow_queries=on;//开启慢查询日志</span><br><span class="line">show variables like &#x27;long_query_time&#x27; //查看时间默认10毫秒</span><br><span class="line"></span><br><span class="line">show variables like &#x27;log_output&#x27;;//查看slow_log日志表的输出格式默认FILE 可指定为TABLE格式</span><br><span class="line"></span><br><span class="line">5.1后提供了slow_log表查看慢查询日志。</span><br></pre></td></tr></table></div></figure><p>二进制日志(binary log)：记录MySQL数据库执行更改的所有操作。可用于备份和复制。</p>        <h1 id="表">          <a href="#表" class="heading-link"><i class="fas fa-link"></i></a><a href="#表" class="headerlink" title="表"></a>表</h1>      <p>InnoDB的逻辑存储结构分别为：表空间 —&gt; 段 —&gt; 区(64个连续的页)—&gt; 页 —&gt; 行</p>        <h1 id="索引">          <a href="#索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引" class="headerlink" title="索引"></a>索引</h1>      <p>Multi-Range Read</p><p>5.6开始支持MRR优化，可用于range，ref，eq_ref类型的查询优化。</p><p>MRR通过把随机磁盘读，转化为顺序磁盘读，从而提高了索引的查询性能。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用optimizer_switch 的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。</span><br><span class="line"></span><br><span class="line">mrr_cost_based表示是否通过cost base的方式来启用MRR.</span><br><span class="line"></span><br><span class="line">当mrr=on,mrr_cost_based=on,则表示cost base的方式还选择启用MRR优化,当发现优化后的代价过高时就会不使用该项优化</span><br><span class="line"></span><br><span class="line">当mrr=on,mrr_cost_based=off,则表示总是开启MRR优化</span><br><span class="line">SET  @@optimizer_switch=&#x27;mrr=on,mrr_cost_based=on&#x27;;</span><br></pre></td></tr></table></div></figure><p>Index Condition Pushdown(ICP)</p><p>5.6开始支持ICP，ICP主要是减少从基表中全记录读取操作的数量，从而降低IO操作。</p><p>对于InnoDB，ICP只适用于辅助索引。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer_switch=&quot;index_condition_pushdown=on”; </span><br></pre></td></tr></table></div></figure>        <h1 id="事务">          <a href="#事务" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务" class="headerlink" title="事务"></a>事务</h1>      <p>事务的实现：redo log用来保证事务的原子性和持久性，undo log保证事务的一致性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-03-07T03:52:50.168Z</published>
    <updated>2022-04-28T03:06:24.807Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="各种垃圾收集器">          <a href="#各种垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种垃圾收集器" class="headerlink" title="各种垃圾收集器"></a>各种垃圾收集器</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Serial</span><br><span class="line">ParNew</span><br><span class="line">ParallelScavenge</span><br><span class="line">Parallel Old</span><br><span class="line">Serial Old</span><br><span class="line">CMS</span><br><span class="line">G1</span><br><span class="line">Shenandoah</span><br><span class="line">ZGC</span><br></pre></td></tr></table></div></figure><p>衡量垃圾收集器的三个指标：内存占用(Footprint)，吞吐量(Throughput)，延迟。</p>        <h3 id="Serial-收集器">          <a href="#Serial-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3>      <p>Serial收集器是最基础、历史最悠久的收集器,JDK1.3之前是HotSpot虚拟机新生代收集器的唯一选择。Serial收集器是一个单线程的收集器，它单线程的意义并不是说明它只会使用一个处理器或一条线程去完成垃圾收集，是强调在它进行垃圾收集时，必须暂停其它所有工作的线程(在用户不可知，不可控的情况下把用户正常工作的线程停掉，这种体验效果很不好—-类似余电脑运行一个小时就会暂停响应五分钟)，直到它收集结束。</p><p>它由于其它虚拟机的特点是：简单，高效(单线程相比),而外内存消耗最小。</p>        <h3 id="ParNew收集器">          <a href="#ParNew收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3>      <p>parNew收集器是Serial收集器的多线程版本，除了同时使用多线程进行垃圾收集之外，其余的行为都和Serial收集器一致。可以与CMS收集器配合工作，支持新生代的垃圾并发收集。</p>        <h3 id="ParallelScavenge收集器">          <a href="#ParallelScavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParallelScavenge收集器" class="headerlink" title="ParallelScavenge收集器"></a>ParallelScavenge收集器</h3>      <p>parallelScavenge收集器是一款新生代收集器，基于标记-复制算法，可以并行收集的多线程收集器。parallel Scavenge收集器的关注目标是达到一个可控制的吞吐量(适合在后台运算而不需要太多交互的分享任务)。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis(最大垃圾收集停顿时间，大于0的毫秒数) //时间越短，将会以牺牲吞吐量和新生代空间为代价换取</span><br><span class="line">-XX:GCTimeRatio(吞吐量大小；建议大于0小于100整数)</span><br><span class="line">-XX:+UseAdaptiveSizePolice(这是一个开关参数，激活后就不需要人工指定新生代(-Xmn),Eden、Suurvivor等细节参数，虚拟机会根据当前系统的运行情况，动态调整参数，提供最合适的停顿时间或者最大的吞吐量。)</span><br></pre></td></tr></table></div></figure>        <h3 id="Serial-Old收集器">          <a href="#Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3>      <p>Serial Old收集器是Serial收集器的老年代版本，主要用于老年代，其它都是和Serial收集器一样。</p>        <h3 id="Parallel-Old收集器">          <a href="#Parallel-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3>      <p>Parallel Old是Parallel Scavenge收集器的老年代版本，主要用于老年代，其它和Parallel Scavenge一样。</p>        <h3 id="CMS收集器">          <a href="#CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3>      <p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器；是基于标记清除算法实现的，整个过程分为四步骤：1.初始标记，2.并发标记，3.重新标记，4.并发清除。</p><p>在初始标记、重新标记这两步骤依然需要停止用户线程，并发标记、并发清除与用户线程并发执行。</p><p>初始标记只是标记一下GCRoots能直接关联到的对象，速度快；并发标记是从GC Roots的直接关联对象开始变量整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。重新标记是为了修正并发标记期间变动的对象，停顿的时间比初始标记长一些，但也远比并发标记时间短。并发清除清理被标记死亡的对象，与用户线程并发执行。</p><p>优点：并发收集、低停顿。</p><p>缺点：并发阶段占用了资源，导致应用程序变慢，吞吐量降低，碎片空间。</p>        <h3 id="Garbage-First-G1-收集器">          <a href="#Garbage-First-G1-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First( G1 收集器)"></a>Garbage First( G1 收集器)</h3>      <p>G1是面向服务端的垃圾收集器基于标记整理算法实现的。jdk1.8默认使用的是Parallel Scanvenge加Parallel Old的组合，1.9开始将使用G1取代它们。G1不在像以前一样把java堆分为新生代和老年代，而是基于Region的堆内存布局。把连续的java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代。收集器会对扮演不同角色的Region区采用不同的策略去收集。</p><p>每个Region区中都有一个Humongous区域，专门用来存储大对象。只要超过了Region容量一半的对象判定为大对象。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：G1HeapRegionSize//可通过该参数设置Region区的大小，1到32MB,且为2的N次幂</span><br></pre></td></tr></table></div></figure><p>G1将Region作为单次回收的最小单元，避免了全区域的垃圾收集。G1会用一个优先级列表去根据Region里面的垃圾大小级回收所需要的时间去维护，然后根据用户设定的收集停顿时间优先处理收益最大的Region区。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：MaxGCPauseMillis //停顿的时间 默认200毫秒</span><br></pre></td></tr></table></div></figure><p>每个Region区都维护自己的记忆集(类似于哈斯表),跨Region引用对象通过记忆集堆解决。因此G1比其他垃圾收集器更占内存，要耗费相当于java堆容量的10%至20%的额外内存来维持记忆集。</p><p>G1的运作过程：</p><p>初始标记：标记一下GC Roots能直接关联到的对象；需要停顿线程(耗时很短)</p><p>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出回收的对象。耗时长，但可与用户线程并发执行。</p><p>最终标记：处理并发阶段遗留的SATB记录。(对用户线程做短暂的暂停)</p><p>筛选回收：更新Region的统计数据切根据回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划。(暂停用户线程)</p>        <h3 id="G1和CMS的对比">          <a href="#G1和CMS的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#G1和CMS的对比" class="headerlink" title="G1和CMS的对比"></a>G1和CMS的对比</h3>      <p>CMS是基于标记-清除算法会产生碎片空间，根据新生代老年代划分,只有一份记忆集</p><p>G1基于标记整理算法，不会产生碎片空间，根据Region区划分,每个Region区都有一个记忆集</p><p>G1垃圾收集产生的内存占用或者程序运行时的而外负载都比CMS高。</p><p>CMS适合小内存的应用上，G1适合大内存(java堆容量6GB到8GB)</p><p>CMS使用了增量更新实现了标记阶段的并发，而G1使用了原始快照</p>        <h3 id="虚拟机垃圾收集器日志">          <a href="#虚拟机垃圾收集器日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机垃圾收集器日志" class="headerlink" title="虚拟机垃圾收集器日志"></a>虚拟机垃圾收集器日志</h3>      <p>jdk9以后虚拟机的所有功能日志都收归到<kbd>-Xlog</kbd>参数上</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:[selector][output][decorators] [output-options] //默认 uptime level tags</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC //查看gc的基本信息</span><br><span class="line">-XX:+PrintGCDetails //查看GC详细信息</span><br><span class="line">-XX:+PrintHeapAtGC //查看GC前后的堆方法区可用容量变化</span><br><span class="line">//查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-XX:+Print-GCApplicationConcurrentTime以及-XX:PrintGCApplicationStoppedTime</span><br><span class="line">//查看收集器Ergonomics机制(自动设置堆空间各分代区域大小、收集目标等内容)</span><br><span class="line">-XX:+PrintAdaptive-SizePolicy</span><br><span class="line">//查看熬过收集后剩余对象的年龄分布信息</span><br><span class="line">-XX:+printTenuring-Distribution</span><br><span class="line"></span><br><span class="line">//jdk9以后</span><br><span class="line">-Xlog:gc GCTest //查看gc的基本信息</span><br><span class="line">-Xlog:gc* GCTest //查看GC详细信息</span><br><span class="line">-Xlog:gc+heap=debug //查看GC前后的堆方法区可用容量变化</span><br><span class="line">-Xlog:safepoint GCTest //查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-Xlog:gc+ergo*=trace</span><br><span class="line">-Xlog:gc+age=trace</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC算法</title>
    <link href="https://anlt-9570.github.io/2022/03/04/JVM/GC/"/>
    <id>https://anlt-9570.github.io/2022/03/04/JVM/GC/</id>
    <published>2022-03-04T12:51:59.160Z</published>
    <updated>2022-05-17T06:05:11.070Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="GC收集器的类型">          <a href="#GC收集器的类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#GC收集器的类型" class="headerlink" title="GC收集器的类型"></a>GC收集器的类型</h3>      <p>部分收集(Partial GC)：指目标不是完整收集整个java堆的垃圾收集</p><p>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集（新生代的Eden区满了之后触发Minor GC）</p><p>老年代(Major GC/old GC):指目标只是老年代的收集（老年代空间不足时尝试触发Minor GC，如果还不足则触发Major GC）</p><p>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代</p><p>整堆收集(Full GC):收集整个java堆和方法区（老年代或方法区等，空间不足时触发）</p>        <h3 id="引用计数算法">          <a href="#引用计数算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3>      <p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器减一；任何时候计数器为零的对象就是不可再被使用的。</p><p>引用计数器的原理简单，判定效率高，大多数情况下是一个不错的算法；但是在java中就很难解决对象之间相互循环引用的问题。比如 A = B、B = A;这样它们的计数器不为零，就会一直无法回收。</p>        <h3 id="可达性分析算法">          <a href="#可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3>      <p>该算法是通过 “GC Roots”的根对象作为起始点集，从这个节点开始，根据引用关系向下搜索，搜索程所走过的路径称为 “引用链”，如果某个对象到GCRoots间没有任何引用链相连，或者从GCRoots到这个对象不可达是，则证明此对象是不可能在被使用的。</p>        <h3 id="分代收集">          <a href="#分代收集" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3>              <h4 id="标记—复制算法">          <a href="#标记—复制算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—复制算法" class="headerlink" title="标记—复制算法"></a>标记—复制算法</h4>      <p>复制算法解决了清除算法对大量可回收对象时执行效率低的问题；它将可用的内存划分为两块相等的内存，每次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另一块上面，然后把已使用的内存空间一次性清理掉。</p><p>缺点是将可用的内存缩小为原来的一半，空间浪费的比较多。</p>        <h4 id="标记—-清除算法">          <a href="#标记—-清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—-清除算法" class="headerlink" title="标记—-清除算法"></a>标记—-清除算法</h4>      <p>算法分为”标记”和”清除”两个阶段：先标记需要回收的对象，标记完后，在统一回收；也可反过来，标记存活的对象，回收没有被标记的对象。</p><p>两个缺点：第一个执行效率不稳定，如果java堆中包含大量的对象，而且大部分是需要回收的，这时就需要进行大量的标记和清除的动作，效率就会变低。</p><p>第二个是内存空间的碎片，标记清楚后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续分配内存空间时，没有足够的连续空间，在继续触发一次垃圾收集。</p>        <h4 id="标记—-整理算法">          <a href="#标记—-整理算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—-整理算法" class="headerlink" title="标记—-整理算法"></a>标记—-整理算法</h4>      <p>标记整理算法是先对存活的对象进行标记，然后把存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。(不适合用在老年代)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GC" scheme="https://anlt-9570.github.io/categories/GC/"/>
    
    
    <category term="GC" scheme="https://anlt-9570.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数调试了解</title>
    <link href="https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/"/>
    <id>https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/</id>
    <published>2022-03-04T01:51:05.808Z</published>
    <updated>2022-06-13T09:49:53.371Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JVM参数设置">          <a href="#JVM参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line"></span><br><span class="line">jvm堆大小设置</span><br><span class="line">-Xmx3550m:设置JVM最大可用内存为3550M</span><br><span class="line">-Xms3550m:设置JVM初始内存为3550M</span><br><span class="line">-Xmn2g:设置年轻代大小为2G。整个JVM内存大小 = 年轻代大小 + 老年代大小 + 持久代大小</span><br><span class="line">-Xss128k:设置每个线程的堆栈大小</span><br><span class="line">-XX:Survivor-Ratio=8 //指定新生代和中Eden区和Survivor的比列(默认8:1)</span><br><span class="line">-XX:PretenureSizeThreshold=2 //设定大于该值的对象直接进入老年代，仅支持Serial和ParNew收集器</span><br><span class="line">-XX:MaxTenuringThreshold=1 //设置对象存活多少次，进入老年代</span><br><span class="line"></span><br><span class="line">//方法区</span><br><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize:设置元空间的最大值，默认-1</span><br><span class="line">-XX:MetaspaceSize:元空间的初始大小</span><br><span class="line"></span><br><span class="line">-XX:MaxDirectMemorySize:设置直接内存的大小，如果不指定默认和java堆的最大值(-Xmx)一致</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="java堆溢出测试">          <a href="#java堆溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆溢出测试" class="headerlink" title="java堆溢出测试"></a>java堆溢出测试</h3>      <p>只要不断的忘堆里面塞对象，并且保证GCRoots到对象有可达路径，避免垃圾回收。</p><p>将堆的大小限制为20MB不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样就不可扩展)<br>通过 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出的时候Dump出当前的内存堆以便进行事后分析</p><p>//idea的VM option中设置</p><p>-Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError</p><p>处理：</p><p>如果不是内存泄漏，检查java虚拟机的堆参数(-Xmx和-Xms)设置，与机器的内存对比，看看是否有向上跳整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。</p>        <h3 id="java虚拟机栈和本地方法栈溢出测试">          <a href="#java虚拟机栈和本地方法栈溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java虚拟机栈和本地方法栈溢出测试" class="headerlink" title="java虚拟机栈和本地方法栈溢出测试"></a>java虚拟机栈和本地方法栈溢出测试</h3>      <p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但没有效果，栈容量只能由 -Xss参数来设定。</p><p>虚拟机栈可能会抛出的两种异常：StackOverflowError(栈超过深度),OOM(内存溢出)</p><p>1.栈溢出</p><p>设置-Xss128k,写个递归死循环调用,就会抛出栈溢出</p><p>2.OOM(内存溢出)</p><p>设置-Xss128k,写个方法在方法中无限的创建线程，就会抛出OOM</p><p>处理：如果是多线程导致OOM，再不能减少线程数量和减少栈容量来换取更多的线程，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>        <h3 id="方法区和运行时常量池溢出">          <a href="#方法区和运行时常量池溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3>      <p>1.8后使用元空间代替永久代。</p><p>String::intern()是一个本地方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回常量池中这个字符串的对象引用，否则会在常量池中创建新的，并且返回引用。jdk1.6之前常量池都是分配在永久代中，可以通过 -XX:PermSize 和 -XX:MaxPermSize限制永久代的大小，即可间接限制常量池的容量。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br></pre></td></tr></table></div></figure><p>在jdk1.6中无限的调用String::intern()会发生OOM异常，但是在1.7或者1.8级以上不发生OOM，只是循环会一直进行下去。出现这种情况是因为JDK1.7级以上版本，原本存放在永久代的字符串常量池，已经被移至java堆之中，所以JDK1.7以上版本，限制方法区的容量对这个测试没效果。可以设置堆的大小，来测试(如-Xmx:6M)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM介绍</title>
    <link href="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/"/>
    <id>https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/</id>
    <published>2022-03-02T13:59:21.520Z</published>
    <updated>2022-06-13T08:45:17.152Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="虚拟机分类">          <a href="#虚拟机分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机分类" class="headerlink" title="虚拟机分类"></a>虚拟机分类</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Classic VM//初代</span><br><span class="line">Exact VM//</span><br><span class="line">HotSpot 虚拟机</span><br><span class="line">J9</span><br><span class="line">Graal 虚拟机</span><br></pre></td></tr></table></div></figure>        <h1 id="类加载器子系统">          <a href="#类加载器子系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1>              <h2 id="类加载过程">          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2>      <p>类加载过程分为三个阶段：加载，链接(Linking)，初始化</p><p>1.加载：通过类的全限定名以二进制流的方式加载到内存中，生成该类的Class对象；把该类的静态存储结构转换为方法区的运行时数据结构。</p><p>加载.class的方式:通过本地，或者网络等；</p><p>2.链接(Linking)：链接又分为三个阶段：验证(Verify)，准备（Prepare），解析（Resolve）；</p><p>验证：确保当前class文件的字节流包含的信息符合当前虚拟机的要求；主要包括四种验证：文件格式，元数据，字节码，符号引用验证；例如每个class文件的开头都是以CA FE BA BE标识开头；可通过     Binary Viewe查看；</p><p>准备：为类变量(static修饰的变量，不包括被final修饰的static(编译期已分配))分配内存，设置该变量的默认初始值(0值)；(通过jclasslib工具查看)</p><p>解析：将常量池的符号引用转换为直接引用（通过：javap -v xx.class进行反编译可以看到常量池已经加载的信息，然后看方法区的引用）解析主要针对：类或接口，字段，类方法等；</p><p>3.初始化：执行类构造器方法clinit()（类变量(static)的赋值和执行静态代码块，如果类中没有静态代码块和类变量，不会生成clinit文件）多线程情况下也只会被执行一次</p>        <h2 id="类加载器">          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2>      <p>Bootstrap ClassLoad ，Extension ClassLoad，System ClassCload</p><p>JVM支持两种类加载器：引导类加载器(Bootstrap ClassLoader)，自定义类加载器(User-Define ClassLoader)(继承ClassLoader类的都属于自定义加载器)</p><p>Bootstrap ClassLoader：</p><ul><li>属于虚拟机自带的加载器</li><li>用于加载java的核心库(JAVA_HOME/jre/lib/rt.jar等)只加载包名为java，javax,sun等开头的类</li><li>加载扩展类和应用程序类加载器，没有父加载器，不继承ClassCload</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bootstrap ClassLoad类加载器加载的目录</span></span><br><span class="line">URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">    System.out.println(urL.toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Extension ClassLoad：</p><ul><li>ClassLoad类的子类</li><li>从java.ext.dirs系统属性指定的目录加载类库，或从jdk的jre/lib/ext下加载类库；用户创建的类库放在此也会加载；</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Extension  ClassLoad类加载器加载的目录</span></span><br><span class="line">String property = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s:property.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>AppClassLoader：</p><ul><li>ClassLoad类的子类</li><li>负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库</li><li>该类是程序中默认的类加载器，一般java应用的类都是由它来完成加载</li></ul><blockquote><p>用户实现自定义类加载器需要实现ClassLoader或者URLClassLoader加载器</p></blockquote>        <h2 id="双亲委派机制">          <a href="#双亲委派机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2>      <p>工作原理：如果类加载器收到了类加载的请求，它并不会自己先去加载，而是委托给父类加载器去加载；如果父加载器还存在父加载器继续递归向上委托，直到最顶层的类加载器；如果父加载器可以完成加载，就成功返回，倘若父加载器无法完成加载，则由子加载器完成；</p><blockquote><p>避免了类的重复加载，防止核心API被串改</p></blockquote>        <h1 id="运行时数据区">          <a href="#运行时数据区" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1>              <h2 id="Java虚拟机的运行时数据区分布">          <a href="#Java虚拟机的运行时数据区分布" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机的运行时数据区分布" class="headerlink" title="Java虚拟机的运行时数据区分布"></a>Java虚拟机的运行时数据区分布</h2>      <p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/20201124113636647.png" alt="0"></p>        <h3 id="程序计数器">          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3>      <p>程序计数器是线程私有的，用来记录当前线程执行到的指令行(存储指向下一条指令的地址，随着线程的生命周期而结束)。比如在多线程中，cpu会对已经就绪的线程进行随机调度，如果当前线程指令还没执行完，可能被其它线程抢到时间片，此时就需要程序计数器记录当前线程执行到的位置，当当前线程又抢到时间片后，又会从刚才记录的指令开始执行。并且程序计数器不会发生OOM(OutOfMemoryError内存溢出)</p>        <h3 id="Java虚拟机栈">          <a href="#Java虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3>      <p>java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧(用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息)，每一个方法被调用直至执行完毕的过程，对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>局部变量表存放编译期可知的八种基本数据类型和对象引用类型。</p><p>在栈中可能会发生的两种异常：StackOverflowError(栈溢出)，OutOfMemoryError(内存溢出)</p><p>如果线程请求的深度或者递归的深度大于虚拟机的深度将会抛出StackOverflowError(栈溢出)</p><p>虚拟机栈容量是可以动态的扩展，当栈扩展时无法申请到空间会抛出OOM异常，或者开太多的线程也会OOM</p><p>HotSpot虚拟机栈容量是不可以动态扩展的，所以不会由于虚拟机无法扩展而导致OOM异常—只有线程申请到栈空间成功就不会有OOM，申请失败时还是会OOM。</p><p>局部变量表：类似于一个一维数组，数组的每个元素叫slot(槽)，用于存储变量(基本数据类和引用类型)；32位类型的变量占1一个槽(引用类型属于32位)，64位占两个槽（使用的时候取起始位置）；</p><blockquote><p>非静态方法第一个槽默认是this，静态方法没有，所以静态方法不能用this</p></blockquote><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/2.jpg" alt="2"></p><p>操作数栈：在方法执行的过程中，根据字节码指令，写入或读取数据(入栈/出栈);主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/3.jpg" alt="3"></p><p>动态链接：将符号引用转换为直接引用；java源文件编译成字节码时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里；一个方法调用了其它方法时，就是通过常量池中指向方法符号引用表示的；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/4.jpg" alt="4"></p>        <h3 id="本地方法栈">          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3>      <p>本地方法栈与虚拟机栈的作用非常相似，区别在于虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务(调用其它语言的库)。</p><p>HotSpot中是直接把本地方法栈和虚拟机栈合二为一的，与虚拟机栈一样，本地方法栈也会在栈深度溢出或者扩展失败时分别抛出StackOverflow和OOM。</p>        <h3 id="java堆">          <a href="#java堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3>      <p>java堆是虚拟机所管理的内存中最大的一块，并且也是被所有线程共享的一块内存区域。在虚拟机启动时被创建，java堆主要是用来存放对象实例，数组，几乎所有的对象实例都在堆中分配内存。</p><p>java堆可以被实现成固定的大小，也可以是扩展(可通过-Xmx和-Xms设定)。如果堆中没有内存完成实例分配，并且堆无法在扩展时，虚拟机将会抛出OOM</p><p>所有线程共享java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal,Allocation Buffer,TLAB)，线程私有的缓冲区分配在Eden区，只占Eden区1/100；</p><p>堆空间基于分代收集理论细分为：</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，永久代(java7以前)；</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，元空间(java8及以后);</p><p>新生代和老年代的占比是1:2，而新生代中Eden区和s0,s1占比是8:1:1;</p><p>几乎所有的对象都是在Eden区new出来的；被销毁的对象大多都是在新生代；</p><blockquote><p>对象的分配过程：大多对象都会在Eden区new出来，当Eden区满了之后会触发 Minor GC/Young GC，存活的对象将会放到s0,s1其中的一个区，而空着的一个Survivor区则称为to区；当Survivor区满了之后不会直接触发GC，而是当Eden区满了之后触发Minor GC/Young GC会同时对Survivor进行GC处理，把from区存活的对象放到to区，from就会变成to，to变成from，如果from区满了之后，剩余存活的对象直接进入老年代；对象每存活一次，就会有一个计数器记录着这个对象存活了多少次，当超过15次之后，将进入到老年代或者是Survivor区相同年龄的所有对象大于Survivor空间的一半则进入老年代；老年代满后直接FGC</p></blockquote><p>设置堆空间大小的参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">-Xmn设置新生代的空间大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line">    </span><br><span class="line">//获取jvm的堆初始内存总量</span><br><span class="line">long initMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;</span><br><span class="line">//获取jvm的最大内存总量</span><br><span class="line">long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;</span><br><span class="line">System.out.println(&quot;-Xms:&quot;+initMemory+&quot;M&quot;);</span><br><span class="line">System.out.println(&quot;-Xmx:&quot;+maxMemory+&quot;M&quot;);</span><br><span class="line"></span><br><span class="line">jstat -gc 进程id//查看jvm的使用情况 在黑窗口使用</span><br><span class="line">-XX:+PrintGCDetails //GC的详细处理信息</span><br><span class="line"></span><br><span class="line">//新生代和老年代的占比配置</span><br><span class="line">默认：-XX:NewRation=2,表示新生代占1，老年代占2，新生代占整个堆的1/3</span><br><span class="line">可以修改：-XX:NewRation=4,表示新生代占1，老年代占4，新生代占整个堆的1/5</span><br><span class="line">//配置新生代中Eden区和Survivor的占比</span><br><span class="line">-XX:SurvivorRation=8;</span><br></pre></td></tr></table></div></figure><p>逃逸分析：逃逸分析的基本行为就是分析对象的动态作用域；</p><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有逃逸分析；</p><p>反之它被外部方法引用，则发生逃逸。例如作为调用参数传递到其它方法；</p><p>没有发生逃逸的对象，则可以分配到栈上，随着方法的结束，栈空间的对象就被移除；</p><p>代码优化：栈上分配，标量替换；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存上的分配</span><br><span class="line">Person person = new Person();</span><br><span class="line">Person:方法区</span><br><span class="line">person:栈</span><br><span class="line">new Person():堆</span><br></pre></td></tr></table></div></figure><p>java8开始，静态变量，字符串常量池移到堆中；</p>        <h3 id="方法区">          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3>      <p>java7之前加永久代（Perm）,java8之后叫元空间（meta space）</p><p>方法区和堆一样也是被线程共享的内存区域，内存大小可固定或者扩展；用于存储被虚拟机加载的类型信息，运行时常量池(常量，静态变量)等。元空间不在虚拟机设置的内存中，而是使用本地内存；方法区也会OOM;</p><p>方法区的初始大小默认21m,最大内存没有限制；</p><p>方法区参数设置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=100m //初始大小</span><br><span class="line">-XX:MaxMetaspaceSize=1000m //最大值</span><br></pre></td></tr></table></div></figure><p>运行时常量池是方法区的一部分，存储编译期生成的各种字面量与符号引用</p><p>JDK1.8取消了永久代，取代永久代的是元空间。元空间属于本地内存，存储内容不同，元空间存储类的元信息，静态变量和常量池并入堆中。常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名参数等；</p>        <h3 id="直接内存-堆外内存">          <a href="#直接内存-堆外内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3>      <p>直接内存并不是虚拟机运行时数据区的一部分,也不属于虚拟机规范，但是因为被频繁的使用(NIO)，才划出这一块，而且也可能导致OOM.</p><p>可以直接使用Native函数库直接分配堆外内存，然后通过在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>为什么要设置直接内存呢：</p><p>java本身无法对磁盘读写，想要进行磁盘读写必须调用操作系统的方法(Native),调用操作系统方法的时候，CPU会切换到内核态。内核态期间，CPU函数读取磁盘文件，同时在操作系统内存中开辟一块系统缓存，将读取的数据写入到系统缓存区，但是java不能直接读取系统缓存，所以java会在堆内存中开辟自己的缓存区，java再次从系统缓存将数据读取到java缓存区。由于产生了两块缓存区导致访问速度缓慢。</p><p>调用ByteBuffer.allocateDirect()时，会分配一块直接内存，java和系统可以共享该区域，减少一次读写操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM工具</title>
    <link href="https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/"/>
    <id>https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/</id>
    <published>2022-03-01T02:42:32.346Z</published>
    <updated>2022-05-17T06:05:16.558Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JPS">          <a href="#JPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3>      <p>JPS 查看当前运行的java进程</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jps [-lvm] ：用于查看当前机器上运行的java进程</span><br><span class="line">命令格式：</span><br><span class="line">jps [options] [hostid] //hostid不知道默认为当前主机或服务器</span><br><span class="line"></span><br><span class="line">options参数：</span><br><span class="line">-q 不输出类名,jar名和传入的main方法参数</span><br><span class="line">-m 输出传入的main方法参数</span><br><span class="line">-l 输出main类或jar的全限名</span><br><span class="line">-v 输出传入的jvm参数</span><br><span class="line">jps -l,jps -m</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="jstat">          <a href="#jstat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3>      <p>jstat用于生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机每一条线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因，如线程死锁，死循环等。</p><p>jstat (用于监视虚拟机运行时状态信息的命令，可以显示出虚拟机进程中的类加载，内存，垃圾收集等运行数据)</p><p>格式：jstat [option] pid [interval] [count]</p><p>interval 连续输出的时间间隔</p><p>count 连续输出的次数</p><p>option 操作参数</p><p>​    -class 监视类加载，卸载数量，总空间以及耗费的时间</p><p>​    jstat -class 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loaded：加载class的数量</span><br><span class="line">Bytes：已加载class字节大小</span><br><span class="line">Unloaded：未加载class的数量</span><br><span class="line">Bytes：未加载class字节大小</span><br><span class="line">Time：加载时间</span><br></pre></td></tr></table></div></figure><p>​    -gc 垃圾回收堆的行为统计</p><p>​    jstat -gc 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C即Capacity 总容量，U即Used 已使用的容量</span><br><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></div></figure><p>-gccapacity 同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NGCMN：新生代最小容量</span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line">NGC：当前新生代容量</span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line">OGC：当前老年代大小</span><br><span class="line">OC:当前老年代大小</span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line">YGC：年轻代gc次数</span><br><span class="line">FGC：老年代GC次数</span><br></pre></td></tr></table></div></figure><p>-gcutil 同-gc，不过输出的是已使用空间占总空间的百分比</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S0：幸存1区当前使用比例</span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line">O：老年代使用比例</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></div></figure>        <h3 id="jmap">          <a href="#jmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3>      <p>jmap：用于生成heap dump文件</p><p>-XX:+HeapDumpOnOutOfMemoryError参数可以让虚拟机出现OOM的时候·自动生成dump文件。</p><p>jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><p>命令格式：jmap [option] pid</p><p>option参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump: 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>-dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/data/dump.hprof 21275</span><br><span class="line">jmap -dump:format=b,file=/data/dump.hprof 21275 //所有</span><br></pre></td></tr></table></div></figure>        <h3 id="jhat">          <a href="#jhat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3>      <p>jhat命令是与jmap搭配使用。用来分析jmap生成的dump</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat -port 9010 heapLive.hprof //以html的形式显示出来</span><br></pre></td></tr></table></div></figure>        <h3 id="可视化工具">          <a href="#可视化工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3>      <p>VisualVM,JConsole,JMC等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://anlt-9570.github.io/2022/02/23/Thread/volatile/"/>
    <id>https://anlt-9570.github.io/2022/02/23/Thread/volatile/</id>
    <published>2022-02-23T12:27:35.048Z</published>
    <updated>2022-04-28T03:10:08.442Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>java提供了一种稍微弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。被volatile声明后，编译器不会将该变量上的操作与其它内存操作一起重排序，不会缓存在寄存器或者其它处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronize关键字更轻量级别的同步机制。</p><p>volatile保证了共享变量的可见性</p><p>volatile通常用作某个操作完成，发生中断或者状态的标记。</p><p>满足一下条件，才应该使用volatile变量：</p><p>1.对变量的写入操作不依赖当前值，或者能确保只有单个线程更新变量的值</p><p>2.该变量不会与其它状态变量一起纳入不变性条件中</p><p>3.在访问变量时不需要加锁</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="线程安全" scheme="https://anlt-9570.github.io/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Thread" scheme="https://anlt-9570.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>redis的应用场景</title>
    <link href="https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-02-18T03:55:50.029Z</published>
    <updated>2022-06-13T09:48:16.945Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(列表)：做最新日志列表</span><br><span class="line">zset(有序集合)：做常见日志统计</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动补全功能：使用有序集合，遍历所有字符，完整的字符末尾做个标记</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx：做分布式锁</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浏览记录</span><br><span class="line">使用有序集合(zset)</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://anlt-9570.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>VM_待写</title>
    <link href="https://anlt-9570.github.io/2022/02/14/VMWare/VM/"/>
    <id>https://anlt-9570.github.io/2022/02/14/VMWare/VM/</id>
    <published>2022-02-14T03:31:48.471Z</published>
    <updated>2022-04-28T03:10:22.030Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://anlt-9570.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="jQuery" scheme="https://anlt-9570.github.io/tags/jQuery/"/>
    
    <category term="表格" scheme="https://anlt-9570.github.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="https://anlt-9570.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>linux常用的命令</title>
    <link href="https://anlt-9570.github.io/2022/02/14/linux/linux/"/>
    <id>https://anlt-9570.github.io/2022/02/14/linux/linux/</id>
    <published>2022-02-14T03:22:44.443Z</published>
    <updated>2022-05-03T11:51:44.504Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看指定端口</span><br><span class="line">ps -aux|grep port</span><br><span class="line"></span><br><span class="line">//查看硬件信息</span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line">//查看ip地址</span><br><span class="line">ip add</span><br></pre></td></tr></table></div></figure><p>常用安装使用</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget //安装yum</span><br><span class="line">yum -y install bash-completion //安装自动补全命令</span><br><span class="line">yum  install lrzsz //安装rz上传下载命令</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Tab] 按键 //命令补全</span><br><span class="line">pwd：//显示当前目录</span><br><span class="line">mkdir 目录名称：//创建目录</span><br><span class="line">touch 文件名：创建文件</span><br><span class="line">cat 文件：查看文件所有内容</span><br><span class="line">cat -n 文件：查看文件所有内容显示行号</span><br><span class="line">tac 文件：倒着看</span><br><span class="line">nl 文件：查看文件所有内容显示行号</span><br><span class="line">more 文件：一页一页的显示内容 </span><br><span class="line">less 文件：(上下键)上下查看本页内容,(左右)键 查看上一页和下一页 q 退出</span><br><span class="line">head -n 100 文件：查看100行</span><br><span class="line">tail 文件：查看尾几行 -n 100：从末尾查看100行</span><br><span class="line">tail -f /var/log/messages//查看linux的实时运行日志</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker安装部署使用</title>
    <link href="https://anlt-9570.github.io/2022/02/14/docker/docker/"/>
    <id>https://anlt-9570.github.io/2022/02/14/docker/docker/</id>
    <published>2022-02-14T03:22:25.566Z</published>
    <updated>2022-05-01T14:11:41.950Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="docker-安装">          <a href="#docker-安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2>      <p>docker要求CenterOS系统的内核版本3.10以上，可以通过<kbd>uname -r</kbd>命令来查看CenterOS是否支持Docker。</p><p>如果系统低了，通过<kbd>yum -y update</kbd>命令更新</p><p>安装docker需要的依赖软件包</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></div></figure><p>卸载</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engin</span><br></pre></td></tr></table></div></figure><p>设置yum源</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></div></figure><p>查看docker的版本</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></div></figure><p>安装docker</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker //启动</span><br><span class="line">systemctl enable docker //开机启动</span><br><span class="line">docker version //查看版本</span><br></pre></td></tr></table></div></figure>        <h2 id="docker的常用命令">          <a href="#docker的常用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h2>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker search java//搜索</span><br><span class="line">docker pull java //下载镜像</span><br><span class="line">docker stop id //停止容器</span><br><span class="line">docker rm id //删除容器</span><br><span class="line">docker rmi 镜像名称或ID //删除镜像</span><br><span class="line">docker images //查看已经下载或者自己构建的镜像</span><br><span class="line">docker ps //查看正在运行的容器</span><br><span class="line">docker ps -a //查看所有容器</span><br><span class="line">docker inspect id //查询容器信息</span><br><span class="line">docker build -t 名称 . dockerfile位置  //构建镜像</span><br><span class="line">docker run -d -p 对外端口:对外端口 -v 磁盘路径:容器里面的路径 镜像名 //运行并构建容器 -d 表示后台运行 -v文件挂载</span><br><span class="line">docker exec -it 容器id /bin/bash   //进入容器</span><br><span class="line">docker tag 镜像id 自定义名称  //修改镜像名称</span><br><span class="line">docker create 自定义容器名称 镜像名称  //创建容器</span><br><span class="line">docker logs -f -t --tail=100 容器id //查看容器的日志 -f跟踪实时日志 -t显示时间 --tail=100显示多少行</span><br><span class="line">docker logs 容器id//</span><br><span class="line">docker cp 容器id:容器路径 目标路径 //把容器的文件复制到指定目录</span><br><span class="line">//容器内安装vim</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line">--net=host//表示不用做端口映射，外部可以直接访问，进入容器后显示的是主机名称，而不是容器id</span><br><span class="line">--cap-add NET_ADMIN //开放网络的权限</span><br><span class="line">--privileged=true //开放容器的所有权限</span><br><span class="line">-it //交互模式运行，进入容器查看</span><br></pre></td></tr></table></div></figure>        <h2 id="docker-nginx部署vue项目">          <a href="#docker-nginx部署vue项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker-nginx部署vue项目" class="headerlink" title="docker+nginx部署vue项目"></a>docker+nginx部署vue项目</h2>      <p>在服务器创建pack_vue文件，npm run build 打包vue项目，把dist文件压缩上传到该目录并解压。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build //打包vue项目</span><br><span class="line">unrar x xxx.rar  //解压以rar结尾的压缩包</span><br></pre></td></tr></table></div></figure><p>在pack_vue目录下创建dockerfile和nginx.conf文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#dockerfile文件</span><br><span class="line"></span><br><span class="line"># 设置基础镜像</span><br><span class="line">FROM nginx</span><br><span class="line">COPY dist/  /usr/share/nginx/html/   # 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面</span><br><span class="line">COPY nginx.conf /etc/nginx/conf.d/default.conf   #拷贝nginx.conf文件到镜像下，替换原有的文件</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       801;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html; #配置vue项目的根路径</span><br><span class="line">            index  index.html index.htm; #配置首页</span><br><span class="line">            try_files $uri $uri/ /index.html; #防止刷新报404</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>构建镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-vue .  //mu-vue表示镜像的名称(随意取)  .(点)表示dockerfile文件所在位置</span><br></pre></td></tr></table></div></figure><p>运行并构建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:80 my-vue   //-d 表示后台启动  -p表映射的端口  对外端口:对内端口   -v 文件挂载</span><br></pre></td></tr></table></div></figure><p>注：dist文件，nginx.conf，dockerfile都是在同一目录下</p>        <h2 id="docker部署springboot项目">          <a href="#docker部署springboot项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h2>      <p>把项目打成jar报上传到服务器，然后配置dockerfile</p><p>配置dockerfile</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#指定java环境</span><br><span class="line">from java:8</span><br><span class="line">#将jar报添加到容器中并修改名称</span><br><span class="line">add demos-0.0.1-SNAPSHOT.jar demos.jar</span><br><span class="line">#可以指定端口</span><br><span class="line">#expose 8088</span><br><span class="line">#运行jar包</span><br><span class="line">entrypoint [&quot;java&quot;,&quot;-jar&quot;,&quot;/demos.jar&quot;]</span><br></pre></td></tr></table></div></figure><p>构建镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t demos .</span><br></pre></td></tr></table></div></figure><p>运行并构建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8686:8686 demos</span><br></pre></td></tr></table></div></figure><p>注：jar包和dockerfile在同一目录.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>My_Test</title>
    <link href="https://anlt-9570.github.io/2022/02/14/Text/"/>
    <id>https://anlt-9570.github.io/2022/02/14/Text/</id>
    <published>2022-02-14T03:21:44.857Z</published>
    <updated>2022-03-04T12:53:41.022Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>redis数据安全与性能保障</title>
    <link href="https://anlt-9570.github.io/2022/02/12/redis/Redis_2/"/>
    <id>https://anlt-9570.github.io/2022/02/12/redis/Redis_2/</id>
    <published>2022-02-12T15:35:21.398Z</published>
    <updated>2022-04-28T03:09:23.616Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h4 id="持久化">          <a href="#持久化" class="heading-link"><i class="fas fa-link"></i></a><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4>      <p>redis提供了两种不同的持久化方式将数据存储到硬盘。一种叫快照(RDB)：将某一时刻的数据写入硬盘，另一种叫追加文件(AOF)：将写的命令持久化到硬盘里。这两种命令可以同时使用也可以单独使用</p>        <h6 id="RDB">          <a href="#RDB" class="heading-link"><i class="fas fa-link"></i></a><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h6>      <p>redis默认采用rdb方式实现数据的持久化，以快照的形式持久化到硬盘的是一个二进制文件dump.rdb .</p><p>windos版打开 redis.widows.conf 文件(linux版打开 redis.conf文件) 搜索save可以看到默认配置有的信息：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 //在900秒(15分钟)之后，如果有一个key发生改变就执行一次备份</span><br><span class="line">save 300 10 //在300秒(5分钟)之后，如果有一个key发生改变就执行一次备份</span><br><span class="line">save 60 10000 //在60秒(1分钟)之后，如果有一个key发生改变就执行一次备份</span><br></pre></td></tr></table></div></figure><p>也可以按照自己的需求去配置。搜索dbfilename和dir这个可以找到rdb存储文件的名称和目录默认是以dump.rdb存储在redis的目录下，我们自己也可以去修改(修改后需要重启一下服务)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//默认是这样的</span><br><span class="line">//dbfilename dump.rdb</span><br><span class="line">//dir ./</span><br><span class="line"></span><br><span class="line">//我们自己可以修</span><br><span class="line">dbfilename dump_test.rdb</span><br><span class="line">dir f: //磁盘的路径</span><br></pre></td></tr></table></div></figure><p>创建快照的几种方法：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在redis的黑窗口执行 bgsave 该命令就可直接备份(创建子线程去执行备份)</span><br><span class="line">2.在redis的黑窗口执行 save 该命令就可直接备份(直接主线程备份，备份完之后可端才会响应其它命令)</span><br><span class="line">3.在redis的黑窗口执行 shutdown 或者term信号命令备份完之后会关闭服务器(调用save命令然后关闭服务器)</span><br><span class="line">4.在redis的黑窗口执行 sync 复制操作(如果主服务器没有执行 bgsave 就执行一遍 bgsave)</span><br></pre></td></tr></table></div></figure><p>如果只使用快照备份数据，系统崩溃后，用户会丢失最近一次生成快照之后更改的数据。因此快照只适用于即使丢失一部分数据也不会造成问题。数据越来越多 bgsave创建子进程会越来越慢。</p>        <h6 id="AOF">          <a href="#AOF" class="heading-link"><i class="fas fa-link"></i></a><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h6>      <p>在配置文件里搜 appendonly 把no改成yes开启AOF，文件默认是appendonly.aof可以修改appendfilename的值改成我们想要的文件名称。<br>aof有三种同步方式：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># appendfsync always //每次数据发生修改都会写入aof文件，能够保证数据不丢失，但是效率会比较低</span><br><span class="line">appendfsync everysec //(默认)每秒钟同步一次，可能会丢失1秒内的数据但是效率高</span><br><span class="line"># appendfsync no //让操作系统决定同步</span><br></pre></td></tr></table></div></figure>        <h6 id="重写-压缩AOF文件">          <a href="#重写-压缩AOF文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#重写-压缩AOF文件" class="headerlink" title="重写/压缩AOF文件"></a>重写/压缩AOF文件</h6>      <p>时间久了之后AOF文件会越来越大，redis重启后需要执行AOF文件记录的所有写命令来还原数据集，如果AOF文件很大，那么还原操作会很花时间。为了解决AOF文件的体积增大的问题，可以向redis客户端发送  **BGREWRITEAOF ** 该命令，这个命令会移除AOF文件中冗余的命令来重写AOF文件，使其体积变小。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof：redis会创建一个子进程，然后由子进程负责对AOF文件进行重写</span><br></pre></td></tr></table></div></figure><p>AOF文件很大时，创建子线程也会很耗时，影响性能。在配置文件中我们可以配置两个选项来让AOF进行自动执行**BGREWRITEAOF ** 命令对文件的重写如：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在配置文件中搜下面两个值，下面两个是默认值我们也可以自行修改</span><br><span class="line">auto-aof-rewrite-percentage 100  //</span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br><span class="line">//当AOF体积大于64MB时，并且AOF文件的体积比上一次体积大了至少一倍(100%)的时候，redis将执行bgrewriteaof命令。如果AOF重写执行过于频繁的话，可以考虑将 auto-aof-rewrite-percentage 选项的值设置为100以上，不过AOF的文件体积也会变得很大，启动还原数据时比较耗时</span><br></pre></td></tr></table></div></figure>        <h4 id="主从">          <a href="#主从" class="heading-link"><i class="fas fa-link"></i></a><a href="#主从" class="headerlink" title="主从"></a>主从</h4>      <p>redis的主从复制：通过持久化功能，redis保证了数据不会损失(或少量损失)。为了避免单点故障，通常的做法是将数据复制多个副本在不同的服务器上，这样即使一台服务器出现了故障，其它服务也可以继续提供服务，为此redis提供了复制功能，可以实现当一台redis的数据更新后，自动更新数据到其它服务器上。</p><p>主节点可以进行读写，主节点数据发生变化时会自动将数据同步到从节点。从节点一般是读，并接受主节点同步过来的数据。一个主节点可以拥有多个从节点，一个从节点只能有一个主节点。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主从设置：在redis.conf(或redis.windows.conf)中配置 slaveof host(主节点ip) port(主节点端口)</span><br><span class="line">(windows版或者直接启动redis然后打开黑窗口输入 slaveof host(主节点ip) port(主节点端口))</span><br></pre></td></tr></table></div></figure><p>当一个从服务器启动后，回向主服务器发送SYNC命令。主服务器收到SYNC命令后开始在后台备份快照(RDB持久化过程)，并将保存快照期间收到的命令缓存起来。备份完后，主服务器会将快照和缓存的命令全都发给从服务器，从服务器收到后，直接载入快照并执行收到的缓存命令。(&lt;—复制初始化过程),复制初始化结束后，主服务器每当收到写命令都会(异步的)同步给从服务器，从而保证主从数据一致性。</p><p>主从服务器断开重连之后，2.6之前版本会重新进行复制初始化，2.8版本之后短线重连能够支持增量数据传输，当从服务器重新连接主服务器后，主服务器只需将短线期间执行的命令传送给从服务器，大大提高redis复制的实用性。</p>        <h5 id="从数据持久">          <a href="#从数据持久" class="heading-link"><i class="fas fa-link"></i></a><a href="#从数据持久" class="headerlink" title="从数据持久"></a>从数据持久</h5>      <p>当主服务器崩溃时，需要手工去重新指定主服务器在从数据库中使用</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one //让服务器终止复制操作，不在接受主服务器的数据更新</span><br></pre></td></tr></table></div></figure><p>让服务器关闭复制功能，并从从服务器转成主服务器，启动崩溃的服务器之前，先使用<kbd>slaveof host port</kbd>命令指定主服务器。</p>        <h5 id="无硬盘复制">          <a href="#无硬盘复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#无硬盘复制" class="headerlink" title="无硬盘复制"></a>无硬盘复制</h5>      <p>redis复制的工作原理是基于RDB方式的持久化实现的，即主服务器在后端保存RDB快照，从服务器接收并载入快照，这样的有点是可以简化逻辑，复用已有的代码，缺点也很明显，从服务器每次断开重连都要进行上面复制操作导致性能下降。2.8.18版本后引入了无硬盘复制，开启选项后，redis在与从服务器进行复制初始化时将不会将快照内容存储到磁盘，而是直接通过网络发送给从服务器，避免了硬盘的性能瓶颈。</p><p>可以在配置文件开启该功能：<kbd>repl-diskless-sync yes</kbd></p><p>2.8版本之后不再发送SYNC，而是PSYNC</p>        <h4 id="哨兵模式">          <a href="#哨兵模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4>      <p>在一个一主多从的系统中，从服务器在整个系统中起到了数据冗余备份和读写分离的作用。主服务器挂了之后需要手动的去维护，难以实现自动化，所以就提出了哨兵模式。</p><p>哨兵模式主要包括两个功能：</p><p>1.监控主服务和从服务是否运行正常</p><p>2.主服务出现故障时自动将从服务转换为主服务</p><p>哨兵模式的搭建：</p><p>先按照主从配置配好一主多从，然后给每个服务器新建一个文件<kbd>sentinel.conf</kbd> 都指向主节点，文件里配置下面这些信息：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">port 26379 //端口号 可配可不配默认是26379</span><br><span class="line">logfile &quot;sentinel.log&quot; //日志文件的名称</span><br><span class="line">dir &quot;D:\\Tools\\zp_Test\\Redis-x64-3.2.100-6376&quot; //存放备份文件以及日志等文件的目录</span><br><span class="line">daemonize yes //是否为后台启动 默认no</span><br><span class="line"></span><br><span class="line">//监控的 ip 端口号 名称 以及sentinel通过投票后认为master宕机的数量，这里是2，2是根据N/2+1来的(N为哨兵节点数量)</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6376 2 </span><br><span class="line">//60秒后ping不同master，则认为master宕机</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000 </span><br><span class="line">//故障转移开始，在指定毫秒内没有完成，则视为转移失败</span><br><span class="line">sentinel failover-timeout mymaster 180000 </span><br><span class="line">//故障转移后主从复制，1表示串行，&gt; 1表示并行</span><br><span class="line">sentinel parallel-syncs mymaster 1 </span><br><span class="line"></span><br><span class="line">//如果redis服务器配置了密码连接，则要加如下配置</span><br><span class="line">sentinel auth-pass mymaster 123</span><br></pre></td></tr></table></div></figure><p>配置完后，使用 <kbd>redis-server sentinel.conf --sentinel</kbd> 启动sentinel服务。然后使用 <kbd>redis-cli -h ip -p 端口 info replication</kbd> 该命令可以查看服务器的信息。</p>        <h4 id="压测">          <a href="#压测" class="heading-link"><i class="fas fa-link"></i></a><a href="#压测" class="headerlink" title="压测"></a>压测</h4>      <p>redis提供了自带的压测工具 <kbd>redis-benchamark.exe</kbd> ,压测命令：<kbd>redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000</kbd> 。redis性能测试工具可选的参数如下：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-h：指定服务器名称/127.0.0.1   -p：指定服务器端口/6379</span><br><span class="line">-s：指定服务器socket -c：指定并发连接数/50</span><br><span class="line">-n：指定请求数/10000-d：以字节的形式指定set/get值的数据大小/2</span><br><span class="line">-k：1=keep alive 0=reconnect/ 1   -r：set/get/incr使用随机key，SADD使用随机值</span><br><span class="line">-P：通过管道传输&lt;numreq&gt;请求/1  -q：强制退出redis,只显示query/sec值</span><br><span class="line">--csv：以csv格式输出-l：生成循环，永久执行测试</span><br><span class="line">-t：仅运行以逗号分隔的测试命令列表</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://anlt-9570.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis_Study</title>
    <link href="https://anlt-9570.github.io/2022/02/11/redis/Redis/"/>
    <id>https://anlt-9570.github.io/2022/02/11/redis/Redis/</id>
    <published>2022-02-11T02:11:48.925Z</published>
    <updated>2022-06-13T09:48:40.288Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h4 id="1-Redis安装">          <a href="#1-Redis安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Redis安装" class="headerlink" title="1.Redis安装"></a>1.Redis安装</h4>      <p>下载地址： <span class="exturl"><a class="exturl__link" href="https://github.com/microsoftarchive/redis/tags">https://github.com/microsoftarchive/redis/tags</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (windos版)</p><p>下载后解压，然后到redis的目录双击redis-server.exe，就可以启动服务了，或者在目录下打开cmd窗口，执行 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf</span><br></pre></td></tr></table></div></figure><p>该命令安装redis服务，去服务列表看是否安装成功，安装成功后顺便启动服务</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf //只启动服务</span><br></pre></td></tr></table></div></figure><p>然后到redis的安装目录双击 redis-cli.exe运行就可进行数据操作了，或者打开cmd黑窗口执行</p><figure class="highlight plaintext"><figcaption><span>-h 127.0.0.1 -p 6379</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></div></figure><p>该命令也可以</p><!-- more -->        <h4 id="2-Redis的5种数据结构">          <a href="#2-Redis的5种数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Redis的5种数据结构" class="headerlink" title="2.Redis的5种数据结构"></a>2.Redis的5种数据结构</h4>      <p>STRING(字符串)：键值的存储单个字符串</p><p>LIST(列表)：有序的存储多个字符串且可以相同</p><p>SET(集合)：无序的存储多个字符串且不可以相同（通过散列表保证数据的不同）</p><p>HASH(散列)：可以存储多个键键值的形式，后面的键值和字符一样</p><p>ZSET(有序集合)：存储结构跟散列一样，但是以键值键存储，值必须是浮点数，可以根据浮点数排序</p>        <h5 id="2-1-STRING-字符串-的命令">          <a href="#2-1-STRING-字符串-的命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-STRING-字符串-的命令" class="headerlink" title="2.1 STRING(字符串)的命令"></a>2.1 STRING(字符串)的命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET //设置存储的键值  set key value  </span><br><span class="line">--&gt; 例： set hello world //如果key相同会把之前的值覆盖掉 可以设置过期时间</span><br><span class="line">SETNX //设置存储的键值 不能设置过期时间</span><br><span class="line">GET //获取存储的键值  get key ---&gt; 例：get hello</span><br><span class="line">DEL //删除存储的键值  del key ---&gt; 例：del hello</span><br><span class="line">INCR //自增1 ,如果不是数字会报错 incr key -&gt; 例：incr t</span><br><span class="line">DECR //自减1 decr key -&gt; 例：decr t</span><br><span class="line">INCRBY // 自增指定值 incrby key amount -&gt; 例：incrby t 2</span><br><span class="line">DECRBY // 自减指定值 decrby key amount -&gt; 例：decrby t 2</span><br><span class="line">INCRBYFLOAT //加上浮点数 incrbyfloat t 1.2</span><br></pre></td></tr></table></div></figure><p><img src="/2022/02/11/redis/Redis/image-20220211155742883.png" alt="image-20220211155742883"></p>        <h5 id="2-2-LIST-列表-命令">          <a href="#2-2-LIST-列表-命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-LIST-列表-命令" class="headerlink" title="2.2 LIST(列表)命令"></a>2.2 LIST(列表)命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lpush //向集合的左边(头)添加数据 lpush key value -&gt; 例：lpush hello word</span><br><span class="line">rpush //向集合的右边(尾)添加数据 rpush key value -&gt; 例：rpush hello word2</span><br><span class="line">lrange//从指定的开始位置到结束位置查看集合数据 lrange key start end </span><br><span class="line">-&gt; 例：lrange hello 0 -1 //-1表示查看这个列表数据</span><br><span class="line">lindex//查看指定位置索引的数据lindex key index -&gt; 例：lindex hello 1</span><br><span class="line">lpop//从列表的最左边弹出一个元素,弹出后该元素将不再列表 lpop key -&gt; 例：lpop hello</span><br><span class="line">rpop//...</span><br><span class="line">rpoplpush //rpoplpush source desc -&gt; rpoplpush q1 q2 从q1列表弹出最右边的一个元素，推到q2左边</span><br><span class="line">阻塞式命令</span><br><span class="line">BLPOP //blpop key timeout -&gt; 例：blpop test 10 //左</span><br><span class="line">BRPOP //...右</span><br><span class="line">BRPOPLPUSH // brpoplpush source desc timeout -&gt; brpoplpush q1 q2 3</span><br><span class="line">//从q1列表弹出最右边的一个元素，推到q2左边。在timeout秒之内阻塞等待可弹出元素</span><br></pre></td></tr></table></div></figure><p><img src="/2022/02/11/redis/Redis/picture%5Cimage-20220211161732124.png" alt="image-20220211161732124"></p>        <h5 id="2-3-SET-集合-命令">          <a href="#2-3-SET-集合-命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-SET-集合-命令" class="headerlink" title="2.3 SET(集合)命令"></a>2.3 SET(集合)命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sadd //向集合添加元素 sadd key member -&gt; 例：sadd hello word //1，添加成功,0集合已存在该数据</span><br><span class="line">smembers //查看集合中所有元素 smembers key -&gt; 例： smembers hello</span><br><span class="line">sismember key member //查找指定元素是否在集合 1，存在,0,不存在 -&gt; 例：sismember hello word</span><br><span class="line">srem key member //删除集合指定的元素(返回删除的数量)  -&gt; 例：srem hello word</span><br><span class="line">scard //返回集合包含元素的数量(集合的大小size) scard key</span><br><span class="line">srandmember //从集合里随机返回指定数量的数据，count为正数返回的元素不从复，为负数数据可能会重复</span><br><span class="line">//srandmember key count</span><br><span class="line">spop //随机移除集合元素不指定默认一个 spop key [count]</span><br><span class="line">smove //从source集合移动member元素到desc集合 返回1表示成功反之</span><br><span class="line">sdiff //返回第一个集合不存在其它集合的数据 sdiff key [...]</span><br><span class="line">sunion // 返回多个集合中各不相同的数据 sunion key [...]</span><br><span class="line">sinter //返回多个集合并集 sinter key [...]</span><br></pre></td></tr></table></div></figure><p><img src="/2022/02/11/redis/Redis/picture%5Cimage-20220211165652946.png" alt="image-20220211165652946"></p>        <h5 id="2-4HASH-散列">          <a href="#2-4HASH-散列" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4HASH-散列" class="headerlink" title="2.4HASH(散列)"></a>2.4HASH(散列)</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HSET //在一个键中在设置一个键值对 hset key field value -&gt; 例：hset hellos h1 h1_word</span><br><span class="line">HGET //获取键的键值 hget key field -&gt; 例：hget hellos h1</span><br><span class="line">HGETALL //获取所以键的键值对 hgetall key -&gt; 例： hgetall hellos</span><br><span class="line">HDEL //删除键的键 hdel key field  -&gt; 例：hdel hellos h1</span><br><span class="line">HINCRBY //对键的键自增指定数量 hincrby key key increment -&gt; 例：hincrby htest ht 2</span><br><span class="line"></span><br><span class="line">HMGET //从散列里获取一个或者多个键的值 hmget key field [field...]</span><br><span class="line">HMSET //设置单个或者多个键值对 hmset key field value [field value...]</span><br><span class="line">HLEN //获取散列表的数量 hlen key</span><br><span class="line"></span><br><span class="line">HEXISTS //检查某个键是否在散列表 hexists key field</span><br><span class="line">HKEYS //获取所有的键 hkeys key</span><br><span class="line">HVALS //获取所以键的值 hvals key </span><br><span class="line">HINCRBY //将key的值加上指定数量 hincrby key field increment</span><br><span class="line">HINCRBYFLOAD //将key的值加上指定数量(浮点数) hincrbyfloat key field increment</span><br></pre></td></tr></table></div></figure><p><img src="/2022/02/11/redis/Redis/picture%5Cimage-20220211171713508.png" alt="image-20220211171713508"></p>        <h5 id="2-5-ZSET-有序集合">          <a href="#2-5-ZSET-有序集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-ZSET-有序集合" class="headerlink" title="2.5 ZSET(有序集合)"></a>2.5 ZSET(有序集合)</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ZADD //将带有分值的成员添加到有序集合 zadd key value member -&gt; 例：zadd hs 10 h1</span><br><span class="line">ZRANGE //获取指定区间的元素 zrange key start stop [withscores](可又可无)</span><br><span class="line">-&gt; 例：zrange hs 0 -1 withscores</span><br><span class="line">ZRANGEBYSCORE //获取给定分数范围的元素 zrangebyscore key min max [withscores]</span><br><span class="line">-&gt; 例：zrangebyscore hs 10 40 </span><br><span class="line">ZREVRANGEBYSCORE //根据分值大到小的返回，其余同上</span><br><span class="line"></span><br><span class="line">ZREM //删除指定键的成员 zrem key member -&gt; 例：zrem hs h1</span><br><span class="line">ZINCRBY //给指定的成员自增指定的数量 zincrby key increment member -&gt; 例：zincrby ztest 3 zt</span><br><span class="line">zrevrange //根据评分从高到底排序获取数据 zrevrange hs 0 -1 withscores -&gt; 例：zrevrange hs 0 -1 [withscores] </span><br><span class="line"></span><br><span class="line">ZCARD //获取有序集合的数量 zcard key</span><br><span class="line">ZCOUNT //获取指定区间的值 zcount key min max</span><br><span class="line">ZRANK // 获取成员在有序集合的位置(索引) zrank key member</span><br><span class="line">ZSCORE //获取成员的分值 zscore key member</span><br><span class="line">ZREVRANK //返回成员的排名 按照分值从大到小排 zrevrank key member</span><br><span class="line">ZINTERSTORE //多个集合(集合的值和有序集合的键成员member)或者有序集合的交集之和 数据量多会比较慢</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK //移除在start和top之间的排名成员 zremrangebyrank key start top</span><br><span class="line">ZREMRANGEBYSCORE //移除在min和max之间分值的成员 zremrangebyscore key min max</span><br><span class="line"></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">属性：</span><br><span class="line">destination：新的集合名称</span><br><span class="line">numkeys：多少个集合要合并</span><br><span class="line">key：要合并的集合，多个空格隔开</span><br><span class="line">-&gt; 例： zinterstore newzt 2 zts zts2</span><br></pre></td></tr></table></div></figure><p><img src="/2022/02/11/redis/Redis/picture%5Cimage-20220211181836780.png" alt="image-20220211181836780"></p>        <h5 id="2-6发布与订阅">          <a href="#2-6发布与订阅" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6发布与订阅" class="headerlink" title="2.6发布与订阅"></a>2.6发布与订阅</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subscribe //订阅一个或者多个频道 subscribe channel [channel...]</span><br><span class="line">unsubscribe //取消订阅频道 unsubscribe [channel [channel...]] 如果不指定默认退订所有频道</span><br><span class="line"></span><br><span class="line">publish // 给指定的频道发送消息 publish channel message</span><br><span class="line"></span><br><span class="line">psubscribe //订阅给定模式的频道  psubscribe pattern [pattern...]</span><br><span class="line">punsubscribe //退订给定模式的频道 punsubscribe [pattern [pattern...]] 不指定退订所有频道</span><br></pre></td></tr></table></div></figure>        <h4 id="3-Redis的基本事务">          <a href="#3-Redis的基本事务" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Redis的基本事务" class="headerlink" title="3.Redis的基本事务"></a>3.Redis的基本事务</h4>      <p>redis有5个事务命令，分别为：WATCH,MULTI,EXEC,UNWATCH,DISCARD</p><p>在redis里面，被multi和exec命令包围的所有命令会一个一个地执行，直到所有命令执行完。当一个事务执行完毕之后，redis才会处理其它客户端的命令。要在redis里面执行事务首先执行multi命令，然后输入那些我们想在事务里执行的命令，最后在执行exec命令。当redis从一个客户端接收到multi命令时，redis会将这个客户端发送的命令都放入到一个队列里面，直到客户端发送exec命令为止</p>        <h4 id="键的过期时间">          <a href="#键的过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h4>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">persist -&gt; persist key //移除键的过期时间</span><br><span class="line">ttl -&gt; ttl key //查看键的过期还剩多少秒</span><br><span class="line">expire -&gt; expire key seconds 指定键多少秒后过期</span><br><span class="line">expireat -&gt; expireat key timestamp 指定键的过期时间(时间戳)</span><br><span class="line">pttl -&gt; pttl key 查看键的过期时间剩多少毫秒</span><br><span class="line">pexpire -&gt; pexpire key milliseconds 指定键多少毫秒后过期</span><br></pre></td></tr></table></div></figure><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://anlt-9570.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql_介绍</title>
    <link href="https://anlt-9570.github.io/2021/09/05/mysql/MySQL/"/>
    <id>https://anlt-9570.github.io/2021/09/05/mysql/MySQL/</id>
    <published>2021-09-05T03:11:56.192Z</published>
    <updated>2022-04-28T03:08:51.147Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h4 id="MySQL支持的存储引擎">          <a href="#MySQL支持的存储引擎" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL支持的存储引擎" class="headerlink" title="MySQL支持的存储引擎"></a>MySQL支持的存储引擎</h4>      <div class="table-container"><table><thead><tr><th>存储引擎</th><th>描述</th></tr></thead><tbody><tr><td>ARCHIVE</td><td>用于数据存档 〈记录插入后不能再修改〉</td></tr><tr><td>BLACKHOLE</td><td>丢弃写操作，读操作会返回空内容</td></tr><tr><td>CSV</td><td>在存储数据时，以逗号分隔各个数据项</td></tr><tr><td>FEDERATED</td><td>用来访问远程表</td></tr><tr><td>InnoDB</td><td>支持事务、行级锁、外键</td></tr><tr><td>MEMORY</td><td>数据只存储在内存，不存储在磁盘:多用于临时</td></tr><tr><td>MERGE</td><td>用来管理多个 MyISAM 表构成的表集合</td></tr><tr><td>MylSAM</td><td>主要的非事务处理存储引擎</td></tr><tr><td>NDB</td><td>MySQL 专用存储引擎</td></tr></tbody></table></div><!-- more -->        <h1 id="InnoDB简介">          <a href="#InnoDB简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#InnoDB简介" class="headerlink" title="InnoDB简介"></a>InnoDB简介</h1>      <p>InnoDB是将表中数据存储到磁盘上的存储引擎，即使关闭重启服务器，数据还是存在，数据的处理过程发生在内存中，所以需要把磁盘中的数据加载到内存。如果是处理写入或修改请求，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，与读写内存差了 几个 数量级。InnoDB获取数据的方式是，将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。InnoDB中页的大小一般为16KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过innodb_page_size设置InnoDB存储引擎中页的大小,默认值为16384(单位字节,16KB),该变量在初始化MySQL数据目录时指定,之后就不能更改了(mysqld --initialize 来初始化目录)。</span><br></pre></td></tr></table></div></figure><p>InnoDB目前支持4种行格式:<br>compact,redundant,dynamic,compressed</p><p>InnoDB为了不同的目的设置了不同类型的页，用于存放记录的页成为数据页：</p><p>一个数据页大致分为7个部分：</p><p>1.File Header：表示页的一些通用信息（固定的38字节）</p><p>2.Page Header：表示数据页一些专有的信息（固定56字节）</p><p>3.Infimum+Supremum：两个虚拟的伪记录，分别表示页中的最小和最大记录（固定26字节）</p><p>4.User Records：真正存储我们插入的记录，大小不固定</p><p>5.Free Space：页中尚未使用的部分，大小不固定</p><p>6.Page Directory：页中某些记录的相对位置，就是各个槽对应的记录在页面中额地址偏移量，大小不固定记录越多空间越大</p><p>7.File Trailer：用于检验页是否完整（固定8字节）</p><p>每个记录的头信息中都有一个next_record属性，从而可以使页中的所有记录串联成一个单项链表</p><p>InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在 Page Directory中，一个槽占用2字节</p><p>在一个页中根据主键查找记录会非常快的，分为两个步骤：</p><p>1.通过2分查找确定记录所在分组对应的槽，并找到该槽所在分组中主键值最小的那条记录</p><p>2.通过记录的next_record属性遍历该槽所在的组中各个记录</p><p>每个数据页的File Header部分都有上一个页和下一个的编号，所以所有的数据页会组成一个双向链表。</p><p>在将页从内存刷到磁盘时，为了保证页的完整性，页首和页尾都会存储页中数据的校验和，以及页面最后修改时对应的LSN值，如果页首和页尾的校验和以及LSN值校验不成功，说明刷新期间出了问题（磁盘数据和页中数据不一致）</p>        <h4 id="1-聚簇索引：">          <a href="#1-聚簇索引：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-聚簇索引：" class="headerlink" title="1.聚簇索引："></a>1.聚簇索引：</h4>      <p>InnoDB存储引擎会自动为我们创建聚簇索引，在InnoDB中，聚簇索引就是数据的存储方式   - - &gt; &gt;”索引即数据，数据即索引”</p><p>两个特点：</p><p>使用主键值得大小进行记录和页的排序</p><p>B+树的页子节点存储的是完整的用户记录</p><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，原因是B+树中的数据是按照主键进行排序</p>        <h4 id="2-二级索引-或辅助索引">          <a href="#2-二级索引-或辅助索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-二级索引-或辅助索引" class="headerlink" title="2.二级索引(或辅助索引)"></a>2.二级索引(或辅助索引)</h4>      <p>创建一颗新的B+树，不再是根据主键值得大小进行排序，而是根据你指定的列数据采用不同的规则进行排序</p><p>二级索引的几个特点：</p><p>使用指定列的大小进行记录和页的排序</p><p>B+树的叶子节点存储不是完整的用户记录，而只是你指定的列加主键的值</p><p>目录中不再是主键加页号的搭配，而是指定的列+主键</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在当前B+树通过携带主键信息到聚簇索引中重新定位完整的用户记录的过程称为回表</span><br></pre></td></tr></table></div></figure>        <h4 id="3-联合索引-复合或多列索引">          <a href="#3-联合索引-复合或多列索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-联合索引-复合或多列索引" class="headerlink" title="3.联合索引(复合或多列索引)"></a>3.联合索引(复合或多列索引)</h4>      <p>为多个列建立索引</p><p>例，列1，列2，建立索引：</p><p>可以让B+树找列1和列2的大小进行排序；</p><p>1.先把各个记录和页按列1进行排序</p><p>2.在记录列1相同的情况下，在采用列2进行排序。</p><p>叶子节点的记录是由列1，列2和主键组成</p>        <h1 id="InnoDB中B-树索引的主要事项">          <a href="#InnoDB中B-树索引的主要事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#InnoDB中B-树索引的主要事项" class="headerlink" title="InnoDB中B+树索引的主要事项"></a>InnoDB中B+树索引的主要事项</h1>      <p>每当为某个表创建一个B+树索引时，都会为这个索引创建一个根节点，最开始表中没有数据时，B+树索引对应的根节点没有用户记录也没有目录项记录</p><p>随后向表中插入记录时，先把用户记录存到跟节点</p><p>根节点可用空间用完时，会将记录复制到新分配的页，然后对这个页进行分裂操作</p><p>InnoDB的索引分为两种：</p><p>聚簇索引：以主键值的大小做为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列。</p><p>二级索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列+主键。</p><p>在二级索引的B+树内节点中，目录项记录由索引列的值，主键值和页号组成。</p><p>一个数据页至少可以容纳两条数据</p><p>MyISAM存储引擎的数据和索引分开，这种存储引擎全部都是二级索引，在叶子节点处存储的是列+行号。</p><p>一个表空间默认16T的数据</p><p>区的概念</p><p>连续的64个页是一个区，256个连续的区是一组，一个区默认占用1M</p><p>Buffer Pool</p><p><img src="/2021/09/05/mysql/MySQL/Users\一只小王八\AppData\Roaming\Typora\typora-user-images\image-20220207170910379.png" alt="image-20220207170910379"></p><p><img src="/2021/09/05/mysql/MySQL/Users\一只小王八\AppData\Roaming\Typora\typora-user-images\image-20220207171341310.png" alt="image-20220207171341310"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://anlt-9570.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://anlt-9570.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
