<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANLT-9570</title>
  
  
  <link href="https://anlt-9570.github.io/atom.xml" rel="self"/>
  
  <link href="https://anlt-9570.github.io/"/>
  <updated>2022-08-06T12:43:11.608Z</updated>
  <id>https://anlt-9570.github.io/</id>
  
  <author>
    <name>xc9570</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收,GCRoot,OOPMap</title>
    <link href="https://anlt-9570.github.io/2022/08/06/JVM/GCROOT-OOPMAP/"/>
    <id>https://anlt-9570.github.io/2022/08/06/JVM/GCROOT-OOPMAP/</id>
    <published>2022-08-06T02:22:10.039Z</published>
    <updated>2022-08-06T12:43:11.608Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="如何标记对象是否存活">          <a href="#如何标记对象是否存活" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何标记对象是否存活" class="headerlink" title="如何标记对象是否存活"></a>如何标记对象是否存活</h3>      <p>判断对象是否存活就是判断对象是否被在次使用，常用的算法有应用计算和可达性分析</p><p><b>1.引用计数算法</b></p><p>引用计数就是为对象添加一个引用计数器，当有一个对象引用它时，那么该对象的引用计数加1，反之每一个引用失效时，该对象的计数就会减1，当对象的引用次数为0时，那么认为该对象不会被再次使用，通过这种方式能够快速的定位到这些可回收的对象，从而进行清理；</p><p>不过引用计数无法解决对象的循环引用问题，比如A引用B,B引用A，除此之外它们没有被任何对象引用，可能这两个对象不可能再被访问，但是它们相互引用对方，导致计数不为0，引用计数无法定位到和回收它们，另一方面就是需要而外的空间去维护引用计数器；</p><p><b>2.可达性分析</b></p><p>可达性分析是通过一系列称为GCRoots的根对象为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象到GCroot间没有任何引用链，则证明此对象不再用，可回收;</p><p>那么那些对象可以称之为GCRoots对象呢？作为GCRoot对象需要满足一个条件，那就是它在很长一段时间内不会被GC回收；</p><p>1.虚拟机栈中本地变量所引用的对象</p><p>2.方法区中常量引用的对象和静态属性引用的对象</p><p>3.本地方法中引用的对象</p><p>当我们通过可达性分析法来定位到对象是否存活后，就需要通过某种策略把这些已经死的对象进行清理，这过程涉及到三种算法，分别为：标记清除，标记复制，标记整理；</p>        <h3 id="垃圾收集算法">          <a href="#垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3>      <p>垃圾收集算法是基于分代收集理论上的(而分代收集是建立在两个分代假说上的);</p><p>1.弱分代假说：绝大多数对象都是朝生夕灭的</p><p>2.强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</p><p><b>1.标记清除</b></p><p>标记清除法是先标记内存里需要回收的对象，标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，回收未被标记的对象；不过标记清除也有它的不足之处，那就是会造成不连续的内存空间，或者当大量对象需要回收而且比较分散，清除的过程就会比较耗时；</p><p><b>2.标记复制</b></p><p>标记复制是将可用的内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块，然后在把已使用的内存空间一次清理掉；如果内存大多数对象是存活的，将会产生大量的内存复制开销；可使用的内存只有原来的一半；</p><p><b>3.标记整理</b></p><p>标记整理分为两个阶段，标记阶段和整理阶段；标记阶段会先把存活的对象和可回收的对象标记出来；标记完在堆内存进行整理，这个阶段会把存活的对象往内存的一端移动，移动完成对象后在清除存活对象边界之外的对象。</p><p>标记整理解决了标记复制法的空间浪费，又解决了标记清除的空间碎片问题；</p>        <h3 id="什么是OOPMap">          <a href="#什么是OOPMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是OOPMap" class="headerlink" title="什么是OOPMap"></a>什么是OOPMap</h3>      <p>当垃圾回收发生时，收集线程会遍历栈里的所有变量，看看哪些位置上存储了引用类型，就意味着这个引用所指向的对象在这一次不会被回收；</p><p>栈上的本地变量表只有一部分数据是引用类型的，为了避免每次垃圾收集时都要扫描真个栈，所以采用了空间换时间的策略。</p><p>HotSpot虚拟机采用了一种叫做OOPMap的数据结构用于记录栈中的对象引用，OOPMap记录了栈上本地变量到堆上对象的引用关系，这些引用关系对象不能进行回收，并且可以作为根节点进行可达性分析，查找出不能够回收的对象；</p>        <h3 id="什么是safePoint-安全点">          <a href="#什么是safePoint-安全点" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是safePoint-安全点" class="headerlink" title="什么是safePoint(安全点)"></a>什么是safePoint(安全点)</h3>      <p>在GCRoot枚举过程中，可能会导致对象的引用关系发生变化，那么保存的OOPMap就要随着变化，如果每一条指令的执行都要去修改OOPMap的话，又是一件成本很高的事。所以就引入了安全点(safePoint)概念，只有在Safe Point才会生成或更新对应的OOPMap;</p><p>Safe Point可以理解成用户执行到特殊的位置，在这些位置上中断用户线程然后更新对应的OOPMap;</p><p>Safe Region(安全区)：就是在程序的一段代码片段中引用的关系不会发生变化，也就是不用更新OOPMap,那么在这段代码区域内进行GC不会有问题；</p>        <h3 id="GCRoots是如何枚举的？">          <a href="#GCRoots是如何枚举的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCRoots是如何枚举的？" class="headerlink" title="GCRoots是如何枚举的？"></a>GCRoots是如何枚举的？</h3>      <p>GCRoot在枚举时都必须暂停用户线程，因为整个枚举的过程必须保证在一致性的快照中进行；这里一致性是指整个枚举期间，系统看起来像被冻结在某个时间点上，不会出现GCRoot的对象引用关系还在不断变化的情况，否则枚举结果的准确性无法保证；</p><p>GCRoot的枚举过程是：(效率慢的)：遍历栈里的所有变量，逐一进行类型判断，如果是引用类信息，则属于GCRoots;(高效的)：直接扫描栈里的OOPMap,通过OOPMap获取对象的引用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring循环依赖问题</title>
    <link href="https://anlt-9570.github.io/2022/07/28/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://anlt-9570.github.io/2022/07/28/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-07-28T03:25:44.441Z</published>
    <updated>2022-08-04T04:41:36.951Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>循环依赖的场景就是A依赖B，B又依赖A对象；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line">public class B &#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>先了解三级缓存的各个属性</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一级缓存：用于存储已经初始化完成的对象</span><br><span class="line">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="line">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">//二级缓存：存储的是实例化完成，没有进行属性赋值的对象</span><br><span class="line">/** Cache of early singleton objects: bean name to bean instance. */</span><br><span class="line">private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">//三级缓存：单列对象工厂，存放bean工厂对象</span><br><span class="line">/** Cache of singleton factories: bean name to ObjectFactory. */</span><br><span class="line">private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</span><br></pre></td></tr></table></div></figure><p>//bean的加载过程</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//实例化bean</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="comment">//是否提前曝光</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//把实例化的对象添加到第三级缓存(解决循环依赖)</span></span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//属性填充 可能存在依赖于其它bean属性，则会递归调用</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略.....</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这个方法就是对象的初始化过程，结合以上A,B对象的情况来说一下循环依赖的一个流程是怎么解决的：</p><p>首先标记实例化对象A,把A对象的实例放到第三级缓存</p><p>属性填充，填充过程中发现需要依赖注入B,则获取B的实例</p><p>标记实例化B,并且把B的实例放到第三级缓存</p><p>属性填充，填充过程中发现需要依赖注入A,则获取A的实例</p><p>这时候是从缓存获取A的实例，先从一级缓存获取，没有则从二级缓存获取，没有则从三级缓存获取，获取到后把实例放到二级缓存，并且把三级缓存的删除掉</p><p>这时B实例初始化完成，放到一级缓存，移除二，三级缓存</p><p>B实例化完成后返回继续初始化A实例，属性装配完后，放到一级缓存，移除二，三级缓存</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从一级缓存获取实例</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//从二级缓存获取实例</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//从三级缓存获取实例</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取三级缓存实例</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//放到二级缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">//移除三级缓存的实例</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>为什么使用三级缓存而不是两级？</p><p>二级缓存也可以解决循环依赖，但是如果bean被aop进行切面后，只使用两个缓存则无法解决；</p><p>如果只有一级和三级缓存，每次先从三级缓存拿到singletonFactory，执行getObject()方法又会产生新的代理对象，这时候对象就不是单列的了，不符合spring的单列原则；所有需要借助二级缓存来解决这个问题，三级缓存产生的对象放到二级缓存中去，后面在二级缓存中会拿到的是同一个对象，就不需要在三级缓存中产生一个新的代理对象了，保证始终只有一个代理对象；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://anlt-9570.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>java运算符</title>
    <link href="https://anlt-9570.github.io/2022/06/30/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/javaOperation/"/>
    <id>https://anlt-9570.github.io/2022/06/30/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/javaOperation/</id>
    <published>2022-06-30T06:46:54.348Z</published>
    <updated>2022-06-30T06:48:49.972Z</updated>
    
    
    
    
    <category term="java" scheme="https://anlt-9570.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Keepalived+nginx集群的使用</title>
    <link href="https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/"/>
    <id>https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/</id>
    <published>2022-05-04T00:59:00.380Z</published>
    <updated>2022-05-04T09:02:10.555Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>准备多台机器：144，145</p><p>使用yum安装Keepalived</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br></pre></td></tr></table></div></figure><p>安装完后，默认安装在<code>/etc/keepalived</code>该路径</p><p><code>144</code>修改keepalived.conf文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>145</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>脚本nginx_check.sh文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">A=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">echo &#x27;-----&gt;144...心跳检测....&#x27;</span><br><span class="line">if [ $A ];then</span><br><span class="line">echo &quot;true....&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;restarting......&quot;</span><br><span class="line">docker start nginx</span><br><span class="line">fi</span><br><span class="line">sleep 5s #时间不能大于脚本的执行间隔时间</span><br><span class="line">C=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">if [ $C ];then</span><br><span class="line">echo &quot;to start success...&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;Fails to start.....&quot;</span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>需要给脚本赋予权限，不然可能执行失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx_check.sh</span><br></pre></td></tr></table></div></figure><p>keepalived启动</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></div></figure><p>查看状态</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status keepalived.service</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.66/">http://192.168.66.66</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>tip：如果脚本没有生效，需要修改<code>/etc/selinux/config</code>文件的<code>SELINUX=disabled</code>;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="keepalived" scheme="https://anlt-9570.github.io/categories/keepalived/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx使用</title>
    <link href="https://anlt-9570.github.io/2022/04/28/nginx/n/"/>
    <id>https://anlt-9570.github.io/2022/04/28/nginx/n/</id>
    <published>2022-04-28T13:16:51.048Z</published>
    <updated>2022-05-04T07:05:40.296Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="nginx-conf文件的简单概述">          <a href="#nginx-conf文件的简单概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx-conf文件的简单概述" class="headerlink" title="nginx.conf文件的简单概述"></a>nginx.conf文件的简单概述</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main#全局配置</span><br><span class="line"></span><br><span class="line">events &#123;#工作模式与连接数上限</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123; //http服务器</span><br><span class="line"></span><br><span class="line">server &#123; //虚拟主机 可以有多个虚拟主机</span><br><span class="line">...</span><br><span class="line">location &#123;#路由配置匹配（虚拟目录等）</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location path&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location otherPath&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123; //虚拟主机</span><br><span class="line">    ...</span><br><span class="line">    location &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">upstream name &#123;//负载均衡器</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Nginx基本使用">          <a href="#Nginx基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Nginx基本使用" class="headerlink" title="Nginx基本使用"></a>Nginx基本使用</h1>      <p>使用docker使用nginx，提前创建好挂载目录，并赋予nginx.conf权限，不然挂载失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx.conf</span><br></pre></td></tr></table></div></figure><p>运行并挂载容器等</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 80:80 -p 801:801 -p 802:802 -p 803:803 --name nginx --privileged=true -v /opt/nginx/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#nginx运行的用户或者用户组,windows下默认是nobody可以注释掉，docker下默认nginx用户</span><br><span class="line">user  nginx;</span><br><span class="line">#nginx进程数 (cpu核心数)</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">#进程文件，windows下可以注释掉</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">#connections 20000; 每个进程应许的最多连接数</span><br><span class="line">#单个进程最大连接数(最大连接数=连接数*进程数)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">#访问日志</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">#文件的传输模式</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">#最长连接超时时间，单位秒默认0</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;d</span><br><span class="line">#虚拟主机配置</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 802; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">        server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">            location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">                root /usr/share/nginx/html; #指定目录</span><br><span class="line">                index index.html; #不配置默认index.html</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server&#123;</span><br><span class="line">    listen 803; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">    server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">    location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">    root /usr/share/nginx/html; #指定目录</span><br><span class="line">    index index.html; #不配置默认index.html</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://127.0.0.1:802/">http://127.0.0.1:802/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h1 id="匹配规则">          <a href="#匹配规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#匹配规则</span><br><span class="line">server_name有三种写法：精确名称，以星号开头或者结尾，正则表达式</span><br><span class="line">例：</span><br><span class="line">server_name www.xc.com</span><br><span class="line">server_name *.com www.xc.*</span><br><span class="line">server_name www./[A-Za-z]/g.com</span><br><span class="line"></span><br><span class="line">#location匹配符号</span><br><span class="line"></span><br><span class="line">优先级</span><br><span class="line">1 =精确匹配</span><br><span class="line">2 ^~以某个字符串开头</span><br><span class="line">3 ~区分大小写的正则匹配</span><br><span class="line">3 ~*不区分大小写的正则匹配</span><br><span class="line">4 /通用匹配，任何请求都会匹配到</span><br><span class="line"></span><br><span class="line">//精确匹配</span><br><span class="line">location /index.html &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/index.html</span><br><span class="line"></span><br><span class="line">//以某个字符开头</span><br><span class="line">location ^~ /b &#123;</span><br><span class="line">default_type text/html; //响应类型</span><br><span class="line">return 200 &#x27;9999&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/boss</span><br><span class="line"></span><br><span class="line">//区分大小写</span><br><span class="line">location ~ /Cc &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/Cc</span><br><span class="line"></span><br><span class="line">//不区分大小写</span><br><span class="line">location ~ /Dd &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/dd</span><br><span class="line"></span><br><span class="line">//前缀匹配</span><br><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/images/b.jpg</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h1 id="反向代理">          <a href="#反向代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1>      <p>在143的主机上代理144</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 801;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://192.168.66.1:1572; //代理的ip和端口</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://192.168.66.143:801/t</span><br></pre></td></tr></table></div></figure>        <h1 id="负载均衡">          <a href="#负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1>      <p>//默认轮训</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>负载均衡的几种策略方式；</p><p>1.轮询(默认)：轮流分发到不同的机器；</p><p>2.weight(权重)：根据权重的比率进行分发，权重越高被分配的几率越打；(ip_hash策略的时候不可用)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:1572 weight=2;</span><br><span class="line">server 192.168.66.144:1572 weight=4;</span><br><span class="line">server 192.168.66.145:1572 weight=8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>3.ip_hash：根据IP进行hash分配，每个IP都会固定访问到一个机器；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>4.fair(第三方)：根据后端响应时间来分配请求，响应时间短的分配越多；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用fair之前，需要提前安装第三方插件，不然会报错，起不来;</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</span><br></pre></td></tr></table></div></figure><p>5.url_hash(第三方)</p><p>使用url_hash之前，也需要提前安装第三方插件，不然会报错，起不来;</p>        <h1 id="负载均衡调度参数">          <a href="#负载均衡调度参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡调度参数" class="headerlink" title="负载均衡调度参数"></a>负载均衡调度参数</h1>      <p>down：表示当前机器不参与负载均衡</p><p>backup：表示当前机器为备份机器，当其它所有的机器不可用之后，请求才回到当前机器，当其他机器可用之后，当前机器</p><p>max_fails：允许请求最大失败次数，超过最大次数暂停服务，默认为1；</p><p>fail_timeout：请求处理失败后，暂停指定的时间，然后重新连接；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tt&#123;</span><br><span class="line">    server 192.168.66.1:1572 down; //</span><br><span class="line">    server 192.168.66.1:1573 backup; //备份服务器</span><br><span class="line">    server 192.168.66.1:1574 max_fails=10 fail_timeout=10s;//重试10次后，暂停10s后重新连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="nginx其它参数">          <a href="#nginx其它参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx其它参数" class="headerlink" title="nginx其它参数"></a>nginx其它参数</h1>      <p>autoindex on;//列出目录内容</p><p>autoindex_exact_size on;//默认为on，显示出文件的大小</p><p>autoindex_localtime on;//显示文件的时间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    autoindex_localtime off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>allow指令：允许哪些IP访问，all表示运行所有；</p><p>deny指令：禁止哪些IP访问，all表示运行所有；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">deny all;</span><br><span class="line">allow 192.168.66.143;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Nginx" scheme="https://anlt-9570.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ使用</title>
    <link href="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/"/>
    <id>https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/</id>
    <published>2022-04-10T03:07:27.623Z</published>
    <updated>2022-04-28T03:04:16.749Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="RabbitMQ的几个主要成员">          <a href="#RabbitMQ的几个主要成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几个主要成员" class="headerlink" title="RabbitMQ的几个主要成员"></a>RabbitMQ的几个主要成员</h1>              <h2 id="1-Producer-生产者">          <a href="#1-Producer-生产者" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Producer-生产者" class="headerlink" title="1.Producer(生产者)"></a>1.Producer(生产者)</h2>      <p>生产消息的一端，可以指定交换机发送消息；</p><p>生产者可以在发送消息前声明Exchange(交换机)，Queue(队列)以及对于关系。</p>        <h2 id="2-Consumer-消费者">          <a href="#2-Consumer-消费者" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Consumer-消费者" class="headerlink" title="2.Consumer(消费者)"></a>2.Consumer(消费者)</h2>      <p>消费消息的一方，通过监听指定队列来消费消息。</p>        <h2 id="3-Exchange-交换机">          <a href="#3-Exchange-交换机" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Exchange-交换机" class="headerlink" title="3.Exchange(交换机)"></a>3.Exchange(交换机)</h2>      <p>用于接收、分配消息，存在多种不同类型的交换机处理特定需求。</p><p>不做存储，消息存储在队列中；交换机类型：direct(默认)，fanout，topics。</p>        <h2 id="4-Queue-队列">          <a href="#4-Queue-队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Queue-队列" class="headerlink" title="4.Queue(队列)"></a>4.Queue(队列)</h2>      <p>用于存储生产者的消息</p>        <h2 id="5-RoutingKey-路由键">          <a href="#5-RoutingKey-路由键" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-RoutingKey-路由键" class="headerlink" title="5.RoutingKey(路由键)"></a>5.RoutingKey(路由键)</h2>      <p>交换机和队列绑定的路由规则</p>        <h1 id="RabbitMQ的几种消息模型">          <a href="#RabbitMQ的几种消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几种消息模型" class="headerlink" title="RabbitMQ的几种消息模型"></a>RabbitMQ的几种消息模型</h1>      <p>基于springboot整合rabbitmq。</p><p>依赖</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure><p>配置文件配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">admin</span></span><br></pre></td></tr></table></div></figure>        <h2 id="1-基本消息模型">          <a href="#1-基本消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基本消息模型" class="headerlink" title="1.基本消息模型"></a>1.基本消息模型</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/1.png" alt="1"></p><p>以上图的模型中，有以下的概念：</p><p>P：生产者，也就是发送消息的一端</p><p>C：消费者，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>RabbitMQ的配置</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列，没有该队列时，会自动配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：队列名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久化默认true</span></span><br><span class="line"><span class="comment">         * boolean exclusive：是否独占(是否只能有一个消费者监听)默认false</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有消费者是否自动删除)默认false</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;xc.com.lt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String exchange //交换机 默认&quot;&quot;</span></span><br><span class="line"><span class="comment">         * String routingKey //路由键(或者队列名)</span></span><br><span class="line"><span class="comment">         * Message message //消息内容</span></span><br><span class="line"><span class="comment">         * CorrelationData correlationData 关联的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="消息确认机制">          <a href="#消息确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5>      <p>生产者：消息投递后，如果失败了，消息就会丢失而且我们自己也不会知道</p><p>消费者：消息消费后，在队列中的消息就会被删除，不管我们有没有消费成功</p><p>那么rabbitmq是怎么知道消息是否投递或者消费成功的呢？</p><p>生产者和消费者提供了几种模式；</p><p>生产者：</p><p>​    NONE：禁用发布确认模式，默认就是这种模式</p><p>​    CORRELATED：消息发布成功后，触发回调方法</p><p>​    SIMPLE：和CORRELATED一样回触发回调，但是比CORRELATED多了一些功能，比如使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待broker节点返回结果。</p><p>生产者的配置：</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment">#开启消息发送失败退回</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></div></figure><p>消息发送后会回调这个方法</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * correlationData：投递消息时附带的信息</span></span><br><span class="line"><span class="comment">     * ack：消息是否发送成功 true：成功，false：失败</span></span><br><span class="line"><span class="comment">     * cause：失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback((correlationData, ack, cause)-&gt;&#123;</span><br><span class="line">        System.out.println(ack);</span><br><span class="line">        System.out.println(cause);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//消息回退 returnedMessage：投递的信息如：交换机，路由键，消息等</span></span><br><span class="line">    rabbitTemplate.setReturnsCallback((returnedMessage)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(returnedMessage.getMessage().getBody()));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者：</p><p>​        NONE：自动应答（默认）</p><p>​        MANUL：收到应答，需要消费端手动回复确认</p><p>​        AUTO：根据监听器是否正常返回还是抛出异常来发出ack/nack。</p><p>实现方式</p><p>方式一配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></div></figure><p>方式二</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span><span class="comment">//监听队列时顺便通过 ackMode指定方式</span></span><br></pre></td></tr></table></div></figure><p>修改消费者，手动应答</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    <span class="comment">//deliveryTag:消息的deliveryTag标识，rabbitmq通过deliveryTag进行匹配;multiple:是否批量确认 true批量确认反之</span></span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="2-工作队列模式">          <a href="#2-工作队列模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-工作队列模式" class="headerlink" title="2.工作队列模式"></a>2.工作队列模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/2.png" alt="2"></p><p>工作队列模式有点类似于第一种，一个生产端，多个消费端同时消费一个队列，但是一个消息只能被一个消费者消费</p><p>P：生产者，也就是发送消息的一端</p><p>C1：消费者1，接收消息的一端</p><p>C2：消费者2，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>多个消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有多个消费者，rabbitmq实行的是消息均摊的方式，这样每个消费者所消费的消息都会差不多；这样不是很好，可能有一些消费的会比较快，有一些消费比较慢，快的在消费完后处于空闲状态，慢的会阻塞不能及时处理。</p><p>我们可以通过prefetch属性来表示该消费者每次只能从队列处理几个消息，处理完在取。比如prefetch=1表示每次只能从该队列取一条，消息没有处理完不会分配，这样就达到能者多劳。</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#一次处理的消息数量</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></div></figure>        <h2 id="3-订阅模式">          <a href="#3-订阅模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-订阅模式" class="headerlink" title="3.订阅模式"></a>3.订阅模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/5.png" alt="3"></p><p>和上面两种不同的是，这种模式多了个交换机。生产者把消息投递到交换机，交换机把消息分发到各个队列，不用指定路由键，交换机只负责分配消息，不做存储；每个监听的消费都会同时接收到消息。</p><p>而<b>fanout</b>类型的交换机可以做到这种模式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue1&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue2&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义fanout类型的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：交换机名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久换(默认true)</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有队列是否自动删除)(默认false)</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new FanoutExchange(&quot;fanoutExchange&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;fanoutExchange&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue1()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue2()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t4&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t4</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue1&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue2&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive4</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="4-路由模式">          <a href="#4-路由模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-路由模式" class="headerlink" title="4.路由模式"></a>4.路由模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/4.png" alt="3"></p><p>生产者向交换机投递消息时，可以指定路由键，交换机会根据路由键分发到指定队列。</p><p>而<b>direct</b>类型的交换机就是这种形式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;direct_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue5()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue6()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生存者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t6&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t6</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.1&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t7&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t7</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.2&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_1&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span><span class="comment">//注意这种要提前把队列和交换机创建好，不然气得会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive5</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_2&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive6</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="5-主题模式">          <a href="#5-主题模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-主题模式" class="headerlink" title="5.主题模式"></a>5.主题模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/6.png" alt="3"></p><p>topics(主题)模式和routing(路由)模式类似，只不过路由模式的键是固定的，而主题模式的路由键可以模糊匹配，类似于SQL 的 = 和 like关系。<b>*</b> 号表示匹配一个 <b>#</b> 表示匹配一个或多个</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue9</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue7()).to(topicsExchange()).with(<span class="string">&quot;topics.orange.rabbit&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue8()).to(topicsExchange()).with(<span class="string">&quot;*.orange.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue9()).to(topicsExchange()).with(<span class="string">&quot;lazy.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t8&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t8</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送后消费者1和2会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;topics.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t9</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">         <span class="comment">//发送后消费者2和3会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;lazy.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-a&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive7</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-b&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive8</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-3&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive9</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="死信队列">          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>      <p>当消息在队列中变成死信消息之后，它就会被重新转移到死信交换机(Dead-Letter-Exchange)简称DLX 。</p><p>变成死信消息的几种情况：消息被拒绝、消息过期、队列达到最大长度。</p><p>死信交换机和普通交换机没什么区别，它能够被任何的队列指定，当队列中消息成为死信消息时，就会重新发布到死信交换机上，进而路由到对应的队列上。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueDeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;deal-queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">dealExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;deal-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//普通队列绑定死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//map.put(&quot;x-message-ttl&quot;, 1000*5);//直接设置 Queue 延迟时间 但如果直接给队列设置过期时间,这种做法不是很灵活</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;deal-exchange&quot;</span>);<span class="comment">//交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;deal.routingKey.v1&quot;</span>);<span class="comment">//路由键</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;ordinary-queue-6&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">ordinaryExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;ordinary-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">ordinaryBindExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue11()).to(ordinaryExchange1()).with(<span class="string">&quot;ordinary.routingKey.v2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列与死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDealExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueDeal()).to(dealExchange1()).with(<span class="string">&quot;deal.routingKey.v1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t10</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;ordinary-exchange-2&quot;</span>,<span class="string">&quot;ordinary.routingKey.v2&quot;</span>,<span class="string">&quot;AMQP-&quot;</span>+a</span><br><span class="line">                ,(message)-&gt;&#123;</span><br><span class="line">                    message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>);<span class="comment">//设置消息过期时间</span></span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;deal-queue&quot;),exchange = @Exchange(value = &quot;deal-exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive10</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">&quot;ordinary_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>tip:如果队列和消息同时设置了过期时间则以最短的时间为准</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MQ" scheme="https://anlt-9570.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>docker单机、集群安装rabbitmq</title>
    <link href="https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/"/>
    <id>https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/</id>
    <published>2022-04-09T09:51:02.023Z</published>
    <updated>2022-05-04T07:42:46.774Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="单机安装">          <a href="#单机安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h1>      <p>拉取镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>创建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>访问<kbd><span class="exturl"><a class="exturl__link" href="http://ip:15672/">http://ip:15672</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd>并登陆，用户名密码默认都是guest</p><p>tips：如果<kbd>docker pull rabbitmq</kbd>后面不带management，启动mq是无法打开管理界面的，所以下载的时候要带management插件的rabbitmq</p>        <h1 id="集群安装">          <a href="#集群安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h1>      <p>RabbitMQ集群节点包含内存节点(RAM)、磁盘节点(Disk，消息持久化，默认)、集群中至少有一个Disk节点。集群分为三种模式：普通模式、镜像模式、仲裁队列(3.8版本以上才支持)。</p><p>普通模式：普通模式中，集群中各个节点有相同的的队列结构，但消息会存在集群中的某一个节点，对于消费者来说，若消息在A节点的Queue中，当从B节点拉取时，RabbitMQ会从A中取出消息，并经过B节点发送给消费者(不过如果A已经宕机，A节点的消息将会丢失)。</p><p>镜像模式：镜像模式就有点类似于主从，一个主节点，多个从节点，队列的所有操作都在主节点上完成，主节点的数据都会备份到从节点。如果是从节点接收到操作请求，会路由到主节点完成。</p>        <h2 id="普通集群配置">          <a href="#普通集群配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通集群配置" class="headerlink" title="普通集群配置"></a>普通集群配置</h2>      <p>先准备三台机器 <code>192.168.66.143(主)</code>,<code>192.168.66.144(备)</code>,<code>192.168.66.145(备)</code></p><p>在三台机器上创建文件夹，用于挂载docker容器 <code>mkdir -p /opt/rabbitmq</code></p><p>拉取MQ镜像 <code>docker pull rabbitmq:management</code></p><p>在各个机器上配置hosts</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.66.143 hadoop03</span><br><span class="line">192.168.66.144 hadoop04</span><br><span class="line">192.168.66.145 hadoop05</span><br></pre></td></tr></table></div></figure><p>在各个机器上先搭建单机</p><figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.66.143</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop03 --name r3 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.144</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop04 --name r4 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.145</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop05 --name r5 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="keyword">add</span><span class="bash">-host=<span class="string">&quot;hostname&quot;</span>:ip ：添加其它机器</span></span><br><span class="line">--hostname：容器的主机名称</span><br><span class="line">--name：容器名称</span><br></pre></td></tr></table></div></figure><p>RabbitMQ是基于Erlang语言的，集群中的每个RabbitMQ节点使用Erlang cookie来通信的，而且每个cookie的值都必须相同。</p><p>去主节点143上查看cookie值，并把144，145的cookie值改成143cookie的值</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cat /opt/rabbitmq/.erlang.cookie //查看143主机cookie值</span><br><span class="line"></span><br><span class="line">//修改144，145主机的cookie值，修改前必须先修改.erlang.cookie文件的权限，默认是只读权限</span><br><span class="line">$chmod 700 /opt/rabbitmq/.erlang.cookie //授予权限</span><br><span class="line"></span><br><span class="line">$vim /opt/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>192.168.66.143配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 无需太多配置，直接查看集群状态</span><br><span class="line">$ docker exec -it r3 bash</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br><span class="line">因为143是主节点，所以不需要过多的配置</span><br></pre></td></tr></table></div></figure><p>192.168.66.144配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r4 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster --ram rabbit@hadoop03 #加入集群 主节点是hadoop03 --ram表示设置为内存节点(默认disk磁盘)</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>192.168.66.145配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r5 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster rabbit@hadoop03 #加入集群 主节点是hadoop03</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>访问各个机器的地址：<a href="http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672">http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672</a></p>        <h2 id="SpringBoot集群配置使用">          <a href="#SpringBoot集群配置使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot集群配置使用" class="headerlink" title="SpringBoot集群配置使用"></a>SpringBoot集群配置使用</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    #单机连接</span><br><span class="line">    #    host: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span></span><br><span class="line">    #集群连接</span><br><span class="line">    addresses: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.144</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.145</span>:<span class="number">5672</span></span><br></pre></td></tr></table></div></figure><p>集群的时候生存者发送消息才会去创建队列</p>        <h2 id="镜像集群模式">          <a href="#镜像集群模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2>      <p>镜像模式基于普通模式，且具备高可用的能力。</p><p>镜像模式的配置有3种模式：exactly(建议),all,nodes</p>        <h3 id="exactly模式-建议使用这个模式">          <a href="#exactly模式-建议使用这个模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#exactly模式-建议使用这个模式" class="headerlink" title="exactly模式(建议使用这个模式)"></a>exactly模式(建议使用这个模式)</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_exactly &quot;^test*&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">-p admin：设置指定虚拟机</span><br><span class="line">ha_exactly：策略名称</span><br><span class="line">&quot;^test*&quot;：匹配队列的正则表达式；(匹配所有名称是以test开头的队列)</span><br><span class="line">&quot;ha-mode&quot;:&quot;exactly&quot;：策略模式，此处是exactly</span><br><span class="line">&quot;ha-params&quot;:2：策略参数，为ha-mode的补充；这里是2，就是副本数量为2，1主1镜像</span><br><span class="line">&quot;ha-sync-mode&quot;:&quot;automatic&quot;：同步策略，默认是manually，即新加入的镜像节点不会同步旧的消息；如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</span><br></pre></td></tr></table></div></figure>        <h3 id="all模式">          <a href="#all模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#all模式" class="headerlink" title="all模式"></a>all模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_all &quot;^all&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">ha_all：策略名称</span><br><span class="line">&quot;^all&quot;：匹配队列的正则表达式，这里是以all开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;all&quot;：all模式</span><br></pre></td></tr></table></div></figure>        <h3 id="nodes模式">          <a href="#nodes模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#nodes模式" class="headerlink" title="nodes模式"></a>nodes模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_nodes &quot;^nodes&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;，&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ha_nodes：策略名称</span><br><span class="line">&quot;^nodes&quot;：匹配队列的正则表达式，这里是以nodes开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;nodes&quot;：nodes模式</span><br><span class="line">&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]：策略参数，指定副本所在节点名称</span><br></pre></td></tr></table></div></figure>        <h3 id="RabbitMQ集成Nginx统一管理控制台">          <a href="#RabbitMQ集成Nginx统一管理控制台" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ集成Nginx统一管理控制台" class="headerlink" title="RabbitMQ集成Nginx统一管理控制台"></a>RabbitMQ集成Nginx统一管理控制台</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.143:802/">http://192.168.66.143:802</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MQ" scheme="https://anlt-9570.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>docker+jenkins实现自动化部署</title>
    <link href="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/"/>
    <id>https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/</id>
    <published>2022-04-07T04:50:52.109Z</published>
    <updated>2022-04-28T03:04:40.986Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="docker安装Jenkins">          <a href="#docker安装Jenkins" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker安装Jenkins" class="headerlink" title="docker安装Jenkins"></a>docker安装Jenkins</h2>      <p>先拉取jenkins</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br><span class="line">docker tag 镜像id jenkins //修改镜像名称方便书写</span><br></pre></td></tr></table></div></figure><p>创建jenkins的挂载目录并且授权不然容器没有权限会报错，方便后续配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/jenkins //-p 多级目录创建</span><br><span class="line">chmod 777 jenkins //授权</span><br></pre></td></tr></table></div></figure><p>创建并运行容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6060:8080 -p 50000:50000 -u root --privileged=true -v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker jenkins</span><br><span class="line"></span><br><span class="line">-p 6060:8080 //jenkins默认的访问端口是8080对外设置为6060</span><br><span class="line">-p 50000:50000  //Jenkins 可以公开一个允许入站代理连接到它的 TCP 端口</span><br><span class="line">-v /opt/jenkins:/var/jenkins_home //设置挂载的目录,jenkins生成的文件也会映射到容器外部的磁盘</span><br><span class="line">-u root --privileged=true -v //以root账号运行，方便后面jenkins执行shell脚本权限不够报错</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker //把docker也挂载到jenkins里面，执行shell脚本时需要用到docker指令，不然用不了</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器id//查看启动的结果,没有报错信息就是启动成功或者:docker ps /容器是否在运行</span><br></pre></td></tr></table></div></figure><p>启动成功后访问 <kbd><span class="exturl"><a class="exturl__link" href="http://ip:6060/">http://ip:6060</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd> 访问后会提示密码在 <kbd>/var/jenkins_home/secrets/initialAdminPassword</kbd> 文件里，先进入容器，然后查看密码</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 74d93f86e4ea /bin/bash //进入容器</span><br><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword //查看密码</span><br></pre></td></tr></table></div></figure><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0.png" alt="0"></p><p>选择安装推荐的插件(这里可能需要等久一点或者会报连接jenkins报错，只要你的网络没问题,点击重试就行)，创建账号密码登录进去.</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-1.png" alt="0-1"></p><p>等待……….</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\0-2.png" alt="0-2"></p><p>插件安装完成创建用户</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-3.png" alt="0-3"></p><p>选择左边侧边栏的 “系统管理” 在选择 “全局工具配置”</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\1.png" alt="1"></p><p>往下滑，找到 <b>JDK</b> 选择jdk安装</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/2.png" alt="2"></p><p>自动安装那里，默认是打钩的我已经把它去掉。选择自己已经安装有的jdk，别名可以随意取，可以通过<kbd>echo $JAVA_HOME</kbd>查看jdk的路径然后复制到JAVA_HOME路径里</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/3.png" alt="3"></p><p>往下滑找到maven选择自动安装，然后取个别名，选择maven的版本后点击保存。</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/4.png" alt="4"></p><p>配置完<b>jdk</b>和<b>maven</b>在安装一个maven的插件，主要用于构建maven项目方便</p><p>系统管理—&gt;插件管理</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/5.png" alt="5"></p><p>选择可选插件搜索maven选择 Pipeline Maven Integration 安装，因为我这里已经安装了，所以没有,可以在已安装那里看到</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/6.png" alt="6"></p><p>回到首页选择<b>新建任务</b>就会显示刚刚安装的maven插件，没安装是没有的，输入任务名称点击<b>构建一个maven项目</b>，点击确定</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/7.png" alt="7"></p><p>点击<b>源码管理</b>选择<b>Git</b> ,<b>URL</b>那里输入<b>Github</b>或者<b>Gitee</b>仓库的地址，选择添加，会弹出一个框，要求输入<b>Github</b>或者<b>Gitee</b>的账号和密码，添加完后<b>Credentials</b>那里就可以选择刚刚添加的账号了</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/8.png" alt="8"></p><p>点击build,Root POM下需要填写<kbd>项名称/pom.xml</kbd>,不然你仓库下有多个项目的话不知道使用哪个项目的pom文件或者任务名称和项目名称不一样也会找不到pom文件。Goals and options(目标和选择)主要用于打包时需要设置的参数，比如：设置jvm的堆栈的大小或者跳过maven测试等等…</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/9.png" alt="9"></p><p>点击<b>Post Steps</b>选择<b>Add post</b>下拉框选择 <b>执行shell</b>(jenkins打包完后执行shell，启动项目)，显示一个输入框就可以在里面写shell脚本</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/10.png" alt="10"></p><p>我的shell脚本</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#任务和项目必须一致，需要修改 pname ,ou,in,jport</span><br><span class="line">#!/bin/bash</span><br><span class="line">#任务名称 任务名称必须和项目名称一样</span><br><span class="line">pname=&quot;demo&quot;</span><br><span class="line">##构建容器时指定对外和对内端口</span><br><span class="line">ou=1586</span><br><span class="line">in=1586</span><br><span class="line">#jenkins端口</span><br><span class="line">jport=6060</span><br><span class="line">#会根据任务创建存放jar包目录</span><br><span class="line">p=/project/java/$pname/$pname/target</span><br><span class="line">#jenkins自动生成jar包的目录</span><br><span class="line">p3=/var/jenkins_home/workspace/$pname/$pname/target/</span><br><span class="line">#先删除以前的jar</span><br><span class="line">rm -rf $p</span><br><span class="line"></span><br><span class="line">#获取容器的id</span><br><span class="line">id=`docker ps -a|grep $pname| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#根据端口获取jenkins的容器id</span><br><span class="line">jid=`docker ps -a|grep $jport| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#镜像Id</span><br><span class="line">ll=`docker images|grep $pname|awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">#查找并切割获取jar包名称</span><br><span class="line">j=`find $p3 -name &#x27;*.jar&#x27; |cut -d&#x27;/&#x27; -f8`</span><br><span class="line">#判断容器是否在运行</span><br><span class="line">if [ $id ];then</span><br><span class="line"> echo $id</span><br><span class="line"> docker stop $id</span><br><span class="line"> docker rm $id</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;iiiiiiii&quot;</span><br><span class="line">fi</span><br><span class="line">#判断镜像是否存在</span><br><span class="line">if [ $ll ];then</span><br><span class="line"> docker rmi $ll</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;lllllll&quot;</span><br><span class="line"> echo $ll</span><br><span class="line">fi</span><br><span class="line">#创建文件</span><br><span class="line">mkdir -p $p</span><br><span class="line">#把jar复制到指定目录</span><br><span class="line">docker cp $jid:$p3/$j $p</span><br><span class="line">cd $p</span><br><span class="line">echo `pwd`</span><br><span class="line">#dockerfile创建写入</span><br><span class="line">echo &#x27;from java:8&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;add &#x27;$j&#x27; &#x27;$j&#x27;&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;entrypoint [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x27;$j&#x27;&quot;]&#x27; &gt;&gt; dockerfile</span><br><span class="line">cat dockerfile</span><br><span class="line">ls</span><br><span class="line">#运行构建容器</span><br><span class="line">docker build -t $pname .</span><br><span class="line">sleep 3</span><br><span class="line">docker run -d -p $ou:$in $pname</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>以上jenkins和要发布的项目都是在同一太机器上运行的…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>MySql_Test</title>
    <link href="https://anlt-9570.github.io/2022/03/22/mysql/Text/"/>
    <id>https://anlt-9570.github.io/2022/03/22/mysql/Text/</id>
    <published>2022-03-22T09:51:35.738Z</published>
    <updated>2022-06-13T08:48:01.892Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="后台线程">          <a href="#后台线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h1>      <p>​    InnoDB是多线程的模型，因此后台有多个不同的线程，负责处理同的任务</p>        <h2 id="Master-Thread">          <a href="#Master-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h2>      <p>​    Master Thread是后台核心线程，负责缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页数据、合并插入缓冲、UNDO页的回收等。</p>        <h2 id="IO-Thread">          <a href="#IO-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h2>      <p>​    IO Thread 使用AIO处理IO请求，主要负责IO请求回调处理。1.0后是read thread和write thread 共8个IO Thread。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;//查看缓冲池的情况</span><br><span class="line">show variables like &#x27;innodb_version&#x27;; //查看当前InnoDB当前版本</span><br><span class="line">show variables like &#x27;innodb_%io_threads&#x27;; //查看IO线程数</span><br></pre></td></tr></table></div></figure>        <h1 id="内存">          <a href="#内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存" class="headerlink" title="内存"></a>内存</h1>              <h2 id="缓冲池">          <a href="#缓冲池" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2>      <p>​    缓冲池就是一块内存，先将数据页从磁盘读取到缓冲池中，下次在读取数据时，回先判断是否在缓冲池中，若在则直接读取该数据，否则读取磁盘。对于修改操作，先修改缓冲池，然后在修改磁盘数据(不是每次数据更新就直接更新到磁盘，而是通过一种Checkpoint机制刷新回磁盘)。</p><p>​    缓冲池缓存的类型有：索引页、数据页、undo页、插入缓冲、锁信息、数据字典、自适应哈希索引等(页大小默认16kb)。</p><p>1.0版本后应许有多个缓冲池。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;; //查看缓冲池的大小</span><br><span class="line">//set global innodb_buffer_pool_size=8g //修改缓冲池的大小</span><br><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;; ////查看缓冲池的数量</span><br></pre></td></tr></table></div></figure>        <h3 id="LRU-list-Free-List-和Flush-List">          <a href="#LRU-list-Free-List-和Flush-List" class="heading-link"><i class="fas fa-link"></i></a><a href="#LRU-list-Free-List-和Flush-List" class="headerlink" title="LRU list,Free List,和Flush List"></a>LRU list,Free List,和Flush List</h3>      <p>Free List(空闲列表)：BufferPool初始化时，加载的页都是先放到Free List中，当缓存页被使用后，对应的Free List中去除掉，把该也放到LRU中。当有一个请求过来从磁盘读取到数据页后，就会在Free链表中获取一个空白的缓存页，把数据放到该链表中。</p><p>Flush List：LRU列表中的页被修改后，称为脏页，即缓冲池的数据和磁盘的数据不一致。该数据就会添加到Flush链表中，同时还会存在LRU链表中。</p><p>LRU（Latest Recent Used最近最少使用） List：被用过过后的页会被添加到该链表。频繁使用的页在列表顶端，少使用的在末端，缓冲池不能存放页时，将首先释放尾端的页。</p><p>InnoDB在LRU列表加入了midpoint位置，新读取的页，先放到LUR列表的midpoint位置。默认情况下，midpoint在LRU列表长度的5/8处。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_old_blocks_pct&#x27;; //查看midpoint位置(默认37)</span><br><span class="line">//可通过innodb_old_blocks_pct设置midpoint的位置</span><br><span class="line">//set global innodb_old_blocks_time=100//可通过该参数设置多久进入到new列表</span><br></pre></td></tr></table></div></figure><p>midpoint之前的称为new列表，之后的称为old列表。</p>        <h2 id="日志缓冲池-redo-log-buffer">          <a href="#日志缓冲池-redo-log-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志缓冲池-redo-log-buffer" class="headerlink" title="日志缓冲池(redo log buffer)"></a>日志缓冲池(redo log buffer)</h2>      <p>日志缓冲池主要存放日志信息，然后按照一定的频率将其刷新到磁盘(没秒刷新一次)。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log_buffer_size&#x27;;//查看大小(默认8MB)</span><br></pre></td></tr></table></div></figure>        <h2 id="Checkpoint技术">          <a href="#Checkpoint技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h2>      <p>数据库数据的持久性的保证：提交事务时，先写日志，然后在把数据刷新到磁盘中。</p>        <h1 id="日志文件">          <a href="#日志文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h1>      <p>redo log：记录事务执行过程中对数据库所做的所有修改。</p><p>慢查询日志：记录SQL语句查询慢于long_query_time指定的时间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_slow_queries&#x27;;//慢查询日志默认关闭 on //开启</span><br><span class="line">set global log_slow_queries=on;//开启慢查询日志</span><br><span class="line">show variables like &#x27;long_query_time&#x27; //查看时间默认10毫秒</span><br><span class="line"></span><br><span class="line">show variables like &#x27;log_output&#x27;;//查看slow_log日志表的输出格式默认FILE 可指定为TABLE格式</span><br><span class="line"></span><br><span class="line">5.1后提供了slow_log表查看慢查询日志。</span><br></pre></td></tr></table></div></figure><p>二进制日志(binary log)：记录MySQL数据库执行更改的所有操作。可用于备份和复制。</p>        <h1 id="表">          <a href="#表" class="heading-link"><i class="fas fa-link"></i></a><a href="#表" class="headerlink" title="表"></a>表</h1>      <p>InnoDB的逻辑存储结构分别为：表空间 —&gt; 段 —&gt; 区(64个连续的页)—&gt; 页 —&gt; 行</p>        <h1 id="索引">          <a href="#索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引" class="headerlink" title="索引"></a>索引</h1>      <p>Multi-Range Read</p><p>5.6开始支持MRR优化，可用于range，ref，eq_ref类型的查询优化。</p><p>MRR通过把随机磁盘读，转化为顺序磁盘读，从而提高了索引的查询性能。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用optimizer_switch 的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。</span><br><span class="line"></span><br><span class="line">mrr_cost_based表示是否通过cost base的方式来启用MRR.</span><br><span class="line"></span><br><span class="line">当mrr=on,mrr_cost_based=on,则表示cost base的方式还选择启用MRR优化,当发现优化后的代价过高时就会不使用该项优化</span><br><span class="line"></span><br><span class="line">当mrr=on,mrr_cost_based=off,则表示总是开启MRR优化</span><br><span class="line">SET  @@optimizer_switch=&#x27;mrr=on,mrr_cost_based=on&#x27;;</span><br></pre></td></tr></table></div></figure><p>Index Condition Pushdown(ICP)</p><p>5.6开始支持ICP，ICP主要是减少从基表中全记录读取操作的数量，从而降低IO操作。</p><p>对于InnoDB，ICP只适用于辅助索引。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer_switch=&quot;index_condition_pushdown=on”; </span><br></pre></td></tr></table></div></figure>        <h1 id="事务">          <a href="#事务" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务" class="headerlink" title="事务"></a>事务</h1>      <p>事务的实现：redo log用来保证事务的原子性和持久性，undo log保证事务的一致性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-03-07T03:52:50.168Z</published>
    <updated>2022-04-28T03:06:24.807Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="各种垃圾收集器">          <a href="#各种垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种垃圾收集器" class="headerlink" title="各种垃圾收集器"></a>各种垃圾收集器</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Serial</span><br><span class="line">ParNew</span><br><span class="line">ParallelScavenge</span><br><span class="line">Parallel Old</span><br><span class="line">Serial Old</span><br><span class="line">CMS</span><br><span class="line">G1</span><br><span class="line">Shenandoah</span><br><span class="line">ZGC</span><br></pre></td></tr></table></div></figure><p>衡量垃圾收集器的三个指标：内存占用(Footprint)，吞吐量(Throughput)，延迟。</p>        <h3 id="Serial-收集器">          <a href="#Serial-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3>      <p>Serial收集器是最基础、历史最悠久的收集器,JDK1.3之前是HotSpot虚拟机新生代收集器的唯一选择。Serial收集器是一个单线程的收集器，它单线程的意义并不是说明它只会使用一个处理器或一条线程去完成垃圾收集，是强调在它进行垃圾收集时，必须暂停其它所有工作的线程(在用户不可知，不可控的情况下把用户正常工作的线程停掉，这种体验效果很不好—-类似余电脑运行一个小时就会暂停响应五分钟)，直到它收集结束。</p><p>它由于其它虚拟机的特点是：简单，高效(单线程相比),而外内存消耗最小。</p>        <h3 id="ParNew收集器">          <a href="#ParNew收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3>      <p>parNew收集器是Serial收集器的多线程版本，除了同时使用多线程进行垃圾收集之外，其余的行为都和Serial收集器一致。可以与CMS收集器配合工作，支持新生代的垃圾并发收集。</p>        <h3 id="ParallelScavenge收集器">          <a href="#ParallelScavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParallelScavenge收集器" class="headerlink" title="ParallelScavenge收集器"></a>ParallelScavenge收集器</h3>      <p>parallelScavenge收集器是一款新生代收集器，基于标记-复制算法，可以并行收集的多线程收集器。parallel Scavenge收集器的关注目标是达到一个可控制的吞吐量(适合在后台运算而不需要太多交互的分享任务)。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis(最大垃圾收集停顿时间，大于0的毫秒数) //时间越短，将会以牺牲吞吐量和新生代空间为代价换取</span><br><span class="line">-XX:GCTimeRatio(吞吐量大小；建议大于0小于100整数)</span><br><span class="line">-XX:+UseAdaptiveSizePolice(这是一个开关参数，激活后就不需要人工指定新生代(-Xmn),Eden、Suurvivor等细节参数，虚拟机会根据当前系统的运行情况，动态调整参数，提供最合适的停顿时间或者最大的吞吐量。)</span><br></pre></td></tr></table></div></figure>        <h3 id="Serial-Old收集器">          <a href="#Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3>      <p>Serial Old收集器是Serial收集器的老年代版本，主要用于老年代，其它都是和Serial收集器一样。</p>        <h3 id="Parallel-Old收集器">          <a href="#Parallel-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3>      <p>Parallel Old是Parallel Scavenge收集器的老年代版本，主要用于老年代，其它和Parallel Scavenge一样。</p>        <h3 id="CMS收集器">          <a href="#CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3>      <p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器；是基于标记清除算法实现的，整个过程分为四步骤：1.初始标记，2.并发标记，3.重新标记，4.并发清除。</p><p>在初始标记、重新标记这两步骤依然需要停止用户线程，并发标记、并发清除与用户线程并发执行。</p><p>初始标记只是标记一下GCRoots能直接关联到的对象，速度快；并发标记是从GC Roots的直接关联对象开始变量整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。重新标记是为了修正并发标记期间变动的对象，停顿的时间比初始标记长一些，但也远比并发标记时间短。并发清除清理被标记死亡的对象，与用户线程并发执行。</p><p>优点：并发收集、低停顿。</p><p>缺点：并发阶段占用了资源，导致应用程序变慢，吞吐量降低，碎片空间。</p>        <h3 id="Garbage-First-G1-收集器">          <a href="#Garbage-First-G1-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First( G1 收集器)"></a>Garbage First( G1 收集器)</h3>      <p>G1是面向服务端的垃圾收集器基于标记整理算法实现的。jdk1.8默认使用的是Parallel Scanvenge加Parallel Old的组合，1.9开始将使用G1取代它们。G1不在像以前一样把java堆分为新生代和老年代，而是基于Region的堆内存布局。把连续的java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代。收集器会对扮演不同角色的Region区采用不同的策略去收集。</p><p>每个Region区中都有一个Humongous区域，专门用来存储大对象。只要超过了Region容量一半的对象判定为大对象。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：G1HeapRegionSize//可通过该参数设置Region区的大小，1到32MB,且为2的N次幂</span><br></pre></td></tr></table></div></figure><p>G1将Region作为单次回收的最小单元，避免了全区域的垃圾收集。G1会用一个优先级列表去根据Region里面的垃圾大小级回收所需要的时间去维护，然后根据用户设定的收集停顿时间优先处理收益最大的Region区。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：MaxGCPauseMillis //停顿的时间 默认200毫秒</span><br></pre></td></tr></table></div></figure><p>每个Region区都维护自己的记忆集(类似于哈斯表),跨Region引用对象通过记忆集堆解决。因此G1比其他垃圾收集器更占内存，要耗费相当于java堆容量的10%至20%的额外内存来维持记忆集。</p><p>G1的运作过程：</p><p>初始标记：标记一下GC Roots能直接关联到的对象；需要停顿线程(耗时很短)</p><p>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出回收的对象。耗时长，但可与用户线程并发执行。</p><p>最终标记：处理并发阶段遗留的SATB记录。(对用户线程做短暂的暂停)</p><p>筛选回收：更新Region的统计数据切根据回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划。(暂停用户线程)</p>        <h3 id="G1和CMS的对比">          <a href="#G1和CMS的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#G1和CMS的对比" class="headerlink" title="G1和CMS的对比"></a>G1和CMS的对比</h3>      <p>CMS是基于标记-清除算法会产生碎片空间，根据新生代老年代划分,只有一份记忆集</p><p>G1基于标记整理算法，不会产生碎片空间，根据Region区划分,每个Region区都有一个记忆集</p><p>G1垃圾收集产生的内存占用或者程序运行时的而外负载都比CMS高。</p><p>CMS适合小内存的应用上，G1适合大内存(java堆容量6GB到8GB)</p><p>CMS使用了增量更新实现了标记阶段的并发，而G1使用了原始快照</p>        <h3 id="虚拟机垃圾收集器日志">          <a href="#虚拟机垃圾收集器日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机垃圾收集器日志" class="headerlink" title="虚拟机垃圾收集器日志"></a>虚拟机垃圾收集器日志</h3>      <p>jdk9以后虚拟机的所有功能日志都收归到<kbd>-Xlog</kbd>参数上</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:[selector][output][decorators] [output-options] //默认 uptime level tags</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC //查看gc的基本信息</span><br><span class="line">-XX:+PrintGCDetails //查看GC详细信息</span><br><span class="line">-XX:+PrintHeapAtGC //查看GC前后的堆方法区可用容量变化</span><br><span class="line">//查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-XX:+Print-GCApplicationConcurrentTime以及-XX:PrintGCApplicationStoppedTime</span><br><span class="line">//查看收集器Ergonomics机制(自动设置堆空间各分代区域大小、收集目标等内容)</span><br><span class="line">-XX:+PrintAdaptive-SizePolicy</span><br><span class="line">//查看熬过收集后剩余对象的年龄分布信息</span><br><span class="line">-XX:+printTenuring-Distribution</span><br><span class="line"></span><br><span class="line">//jdk9以后</span><br><span class="line">-Xlog:gc GCTest //查看gc的基本信息</span><br><span class="line">-Xlog:gc* GCTest //查看GC详细信息</span><br><span class="line">-Xlog:gc+heap=debug //查看GC前后的堆方法区可用容量变化</span><br><span class="line">-Xlog:safepoint GCTest //查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-Xlog:gc+ergo*=trace</span><br><span class="line">-Xlog:gc+age=trace</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC算法</title>
    <link href="https://anlt-9570.github.io/2022/03/04/JVM/GC/"/>
    <id>https://anlt-9570.github.io/2022/03/04/JVM/GC/</id>
    <published>2022-03-04T12:51:59.160Z</published>
    <updated>2022-05-17T06:05:11.070Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="GC收集器的类型">          <a href="#GC收集器的类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#GC收集器的类型" class="headerlink" title="GC收集器的类型"></a>GC收集器的类型</h3>      <p>部分收集(Partial GC)：指目标不是完整收集整个java堆的垃圾收集</p><p>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集（新生代的Eden区满了之后触发Minor GC）</p><p>老年代(Major GC/old GC):指目标只是老年代的收集（老年代空间不足时尝试触发Minor GC，如果还不足则触发Major GC）</p><p>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代</p><p>整堆收集(Full GC):收集整个java堆和方法区（老年代或方法区等，空间不足时触发）</p>        <h3 id="引用计数算法">          <a href="#引用计数算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3>      <p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器减一；任何时候计数器为零的对象就是不可再被使用的。</p><p>引用计数器的原理简单，判定效率高，大多数情况下是一个不错的算法；但是在java中就很难解决对象之间相互循环引用的问题。比如 A = B、B = A;这样它们的计数器不为零，就会一直无法回收。</p>        <h3 id="可达性分析算法">          <a href="#可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3>      <p>该算法是通过 “GC Roots”的根对象作为起始点集，从这个节点开始，根据引用关系向下搜索，搜索程所走过的路径称为 “引用链”，如果某个对象到GCRoots间没有任何引用链相连，或者从GCRoots到这个对象不可达是，则证明此对象是不可能在被使用的。</p>        <h3 id="分代收集">          <a href="#分代收集" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3>              <h4 id="标记—复制算法">          <a href="#标记—复制算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—复制算法" class="headerlink" title="标记—复制算法"></a>标记—复制算法</h4>      <p>复制算法解决了清除算法对大量可回收对象时执行效率低的问题；它将可用的内存划分为两块相等的内存，每次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另一块上面，然后把已使用的内存空间一次性清理掉。</p><p>缺点是将可用的内存缩小为原来的一半，空间浪费的比较多。</p>        <h4 id="标记—-清除算法">          <a href="#标记—-清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—-清除算法" class="headerlink" title="标记—-清除算法"></a>标记—-清除算法</h4>      <p>算法分为”标记”和”清除”两个阶段：先标记需要回收的对象，标记完后，在统一回收；也可反过来，标记存活的对象，回收没有被标记的对象。</p><p>两个缺点：第一个执行效率不稳定，如果java堆中包含大量的对象，而且大部分是需要回收的，这时就需要进行大量的标记和清除的动作，效率就会变低。</p><p>第二个是内存空间的碎片，标记清楚后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续分配内存空间时，没有足够的连续空间，在继续触发一次垃圾收集。</p>        <h4 id="标记—-整理算法">          <a href="#标记—-整理算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记—-整理算法" class="headerlink" title="标记—-整理算法"></a>标记—-整理算法</h4>      <p>标记整理算法是先对存活的对象进行标记，然后把存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。(不适合用在老年代)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GC" scheme="https://anlt-9570.github.io/categories/GC/"/>
    
    
    <category term="GC" scheme="https://anlt-9570.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数调试了解</title>
    <link href="https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/"/>
    <id>https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/</id>
    <published>2022-03-04T01:51:05.808Z</published>
    <updated>2022-06-13T09:49:53.371Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JVM参数设置">          <a href="#JVM参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line"></span><br><span class="line">jvm堆大小设置</span><br><span class="line">-Xmx3550m:设置JVM最大可用内存为3550M</span><br><span class="line">-Xms3550m:设置JVM初始内存为3550M</span><br><span class="line">-Xmn2g:设置年轻代大小为2G。整个JVM内存大小 = 年轻代大小 + 老年代大小 + 持久代大小</span><br><span class="line">-Xss128k:设置每个线程的堆栈大小</span><br><span class="line">-XX:Survivor-Ratio=8 //指定新生代和中Eden区和Survivor的比列(默认8:1)</span><br><span class="line">-XX:PretenureSizeThreshold=2 //设定大于该值的对象直接进入老年代，仅支持Serial和ParNew收集器</span><br><span class="line">-XX:MaxTenuringThreshold=1 //设置对象存活多少次，进入老年代</span><br><span class="line"></span><br><span class="line">//方法区</span><br><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize:设置元空间的最大值，默认-1</span><br><span class="line">-XX:MetaspaceSize:元空间的初始大小</span><br><span class="line"></span><br><span class="line">-XX:MaxDirectMemorySize:设置直接内存的大小，如果不指定默认和java堆的最大值(-Xmx)一致</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="java堆溢出测试">          <a href="#java堆溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆溢出测试" class="headerlink" title="java堆溢出测试"></a>java堆溢出测试</h3>      <p>只要不断的忘堆里面塞对象，并且保证GCRoots到对象有可达路径，避免垃圾回收。</p><p>将堆的大小限制为20MB不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样就不可扩展)<br>通过 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出的时候Dump出当前的内存堆以便进行事后分析</p><p>//idea的VM option中设置</p><p>-Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError</p><p>处理：</p><p>如果不是内存泄漏，检查java虚拟机的堆参数(-Xmx和-Xms)设置，与机器的内存对比，看看是否有向上跳整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。</p>        <h3 id="java虚拟机栈和本地方法栈溢出测试">          <a href="#java虚拟机栈和本地方法栈溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java虚拟机栈和本地方法栈溢出测试" class="headerlink" title="java虚拟机栈和本地方法栈溢出测试"></a>java虚拟机栈和本地方法栈溢出测试</h3>      <p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但没有效果，栈容量只能由 -Xss参数来设定。</p><p>虚拟机栈可能会抛出的两种异常：StackOverflowError(栈超过深度),OOM(内存溢出)</p><p>1.栈溢出</p><p>设置-Xss128k,写个递归死循环调用,就会抛出栈溢出</p><p>2.OOM(内存溢出)</p><p>设置-Xss128k,写个方法在方法中无限的创建线程，就会抛出OOM</p><p>处理：如果是多线程导致OOM，再不能减少线程数量和减少栈容量来换取更多的线程，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>        <h3 id="方法区和运行时常量池溢出">          <a href="#方法区和运行时常量池溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3>      <p>1.8后使用元空间代替永久代。</p><p>String::intern()是一个本地方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回常量池中这个字符串的对象引用，否则会在常量池中创建新的，并且返回引用。jdk1.6之前常量池都是分配在永久代中，可以通过 -XX:PermSize 和 -XX:MaxPermSize限制永久代的大小，即可间接限制常量池的容量。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br></pre></td></tr></table></div></figure><p>在jdk1.6中无限的调用String::intern()会发生OOM异常，但是在1.7或者1.8级以上不发生OOM，只是循环会一直进行下去。出现这种情况是因为JDK1.7级以上版本，原本存放在永久代的字符串常量池，已经被移至java堆之中，所以JDK1.7以上版本，限制方法区的容量对这个测试没效果。可以设置堆的大小，来测试(如-Xmx:6M)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM介绍</title>
    <link href="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/"/>
    <id>https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/</id>
    <published>2022-03-02T13:59:21.520Z</published>
    <updated>2022-06-13T08:45:17.152Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="虚拟机分类">          <a href="#虚拟机分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机分类" class="headerlink" title="虚拟机分类"></a>虚拟机分类</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Classic VM//初代</span><br><span class="line">Exact VM//</span><br><span class="line">HotSpot 虚拟机</span><br><span class="line">J9</span><br><span class="line">Graal 虚拟机</span><br></pre></td></tr></table></div></figure>        <h1 id="类加载器子系统">          <a href="#类加载器子系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1>              <h2 id="类加载过程">          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2>      <p>类加载过程分为三个阶段：加载，链接(Linking)，初始化</p><p>1.加载：通过类的全限定名以二进制流的方式加载到内存中，生成该类的Class对象；把该类的静态存储结构转换为方法区的运行时数据结构。</p><p>加载.class的方式:通过本地，或者网络等；</p><p>2.链接(Linking)：链接又分为三个阶段：验证(Verify)，准备（Prepare），解析（Resolve）；</p><p>验证：确保当前class文件的字节流包含的信息符合当前虚拟机的要求；主要包括四种验证：文件格式，元数据，字节码，符号引用验证；例如每个class文件的开头都是以CA FE BA BE标识开头；可通过     Binary Viewe查看；</p><p>准备：为类变量(static修饰的变量，不包括被final修饰的static(编译期已分配))分配内存，设置该变量的默认初始值(0值)；(通过jclasslib工具查看)</p><p>解析：将常量池的符号引用转换为直接引用（通过：javap -v xx.class进行反编译可以看到常量池已经加载的信息，然后看方法区的引用）解析主要针对：类或接口，字段，类方法等；</p><p>3.初始化：执行类构造器方法clinit()（类变量(static)的赋值和执行静态代码块，如果类中没有静态代码块和类变量，不会生成clinit文件）多线程情况下也只会被执行一次</p>        <h2 id="类加载器">          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2>      <p>Bootstrap ClassLoad ，Extension ClassLoad，System ClassCload</p><p>JVM支持两种类加载器：引导类加载器(Bootstrap ClassLoader)，自定义类加载器(User-Define ClassLoader)(继承ClassLoader类的都属于自定义加载器)</p><p>Bootstrap ClassLoader：</p><ul><li>属于虚拟机自带的加载器</li><li>用于加载java的核心库(JAVA_HOME/jre/lib/rt.jar等)只加载包名为java，javax,sun等开头的类</li><li>加载扩展类和应用程序类加载器，没有父加载器，不继承ClassCload</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bootstrap ClassLoad类加载器加载的目录</span></span><br><span class="line">URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">    System.out.println(urL.toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Extension ClassLoad：</p><ul><li>ClassLoad类的子类</li><li>从java.ext.dirs系统属性指定的目录加载类库，或从jdk的jre/lib/ext下加载类库；用户创建的类库放在此也会加载；</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Extension  ClassLoad类加载器加载的目录</span></span><br><span class="line">String property = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s:property.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>AppClassLoader：</p><ul><li>ClassLoad类的子类</li><li>负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库</li><li>该类是程序中默认的类加载器，一般java应用的类都是由它来完成加载</li></ul><blockquote><p>用户实现自定义类加载器需要实现ClassLoader或者URLClassLoader加载器</p></blockquote>        <h2 id="双亲委派机制">          <a href="#双亲委派机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2>      <p>工作原理：如果类加载器收到了类加载的请求，它并不会自己先去加载，而是委托给父类加载器去加载；如果父加载器还存在父加载器继续递归向上委托，直到最顶层的类加载器；如果父加载器可以完成加载，就成功返回，倘若父加载器无法完成加载，则由子加载器完成；</p><blockquote><p>避免了类的重复加载，防止核心API被串改</p></blockquote>        <h1 id="运行时数据区">          <a href="#运行时数据区" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1>              <h2 id="Java虚拟机的运行时数据区分布">          <a href="#Java虚拟机的运行时数据区分布" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机的运行时数据区分布" class="headerlink" title="Java虚拟机的运行时数据区分布"></a>Java虚拟机的运行时数据区分布</h2>      <p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/20201124113636647.png" alt="0"></p>        <h3 id="程序计数器">          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3>      <p>程序计数器是线程私有的，用来记录当前线程执行到的指令行(存储指向下一条指令的地址，随着线程的生命周期而结束)。比如在多线程中，cpu会对已经就绪的线程进行随机调度，如果当前线程指令还没执行完，可能被其它线程抢到时间片，此时就需要程序计数器记录当前线程执行到的位置，当当前线程又抢到时间片后，又会从刚才记录的指令开始执行。并且程序计数器不会发生OOM(OutOfMemoryError内存溢出)</p>        <h3 id="Java虚拟机栈">          <a href="#Java虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3>      <p>java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧(用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息)，每一个方法被调用直至执行完毕的过程，对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>局部变量表存放编译期可知的八种基本数据类型和对象引用类型。</p><p>在栈中可能会发生的两种异常：StackOverflowError(栈溢出)，OutOfMemoryError(内存溢出)</p><p>如果线程请求的深度或者递归的深度大于虚拟机的深度将会抛出StackOverflowError(栈溢出)</p><p>虚拟机栈容量是可以动态的扩展，当栈扩展时无法申请到空间会抛出OOM异常，或者开太多的线程也会OOM</p><p>HotSpot虚拟机栈容量是不可以动态扩展的，所以不会由于虚拟机无法扩展而导致OOM异常—只有线程申请到栈空间成功就不会有OOM，申请失败时还是会OOM。</p><p>局部变量表：类似于一个一维数组，数组的每个元素叫slot(槽)，用于存储变量(基本数据类和引用类型)；32位类型的变量占1一个槽(引用类型属于32位)，64位占两个槽（使用的时候取起始位置）；</p><blockquote><p>非静态方法第一个槽默认是this，静态方法没有，所以静态方法不能用this</p></blockquote><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/2.jpg" alt="2"></p><p>操作数栈：在方法执行的过程中，根据字节码指令，写入或读取数据(入栈/出栈);主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/3.jpg" alt="3"></p><p>动态链接：将符号引用转换为直接引用；java源文件编译成字节码时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里；一个方法调用了其它方法时，就是通过常量池中指向方法符号引用表示的；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/4.jpg" alt="4"></p>        <h3 id="本地方法栈">          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3>      <p>本地方法栈与虚拟机栈的作用非常相似，区别在于虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务(调用其它语言的库)。</p><p>HotSpot中是直接把本地方法栈和虚拟机栈合二为一的，与虚拟机栈一样，本地方法栈也会在栈深度溢出或者扩展失败时分别抛出StackOverflow和OOM。</p>        <h3 id="java堆">          <a href="#java堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3>      <p>java堆是虚拟机所管理的内存中最大的一块，并且也是被所有线程共享的一块内存区域。在虚拟机启动时被创建，java堆主要是用来存放对象实例，数组，几乎所有的对象实例都在堆中分配内存。</p><p>java堆可以被实现成固定的大小，也可以是扩展(可通过-Xmx和-Xms设定)。如果堆中没有内存完成实例分配，并且堆无法在扩展时，虚拟机将会抛出OOM</p><p>所有线程共享java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal,Allocation Buffer,TLAB)，线程私有的缓冲区分配在Eden区，只占Eden区1/100；</p><p>堆空间基于分代收集理论细分为：</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，永久代(java7以前)；</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，元空间(java8及以后);</p><p>新生代和老年代的占比是1:2，而新生代中Eden区和s0,s1占比是8:1:1;</p><p>几乎所有的对象都是在Eden区new出来的；被销毁的对象大多都是在新生代；</p><blockquote><p>对象的分配过程：大多对象都会在Eden区new出来，当Eden区满了之后会触发 Minor GC/Young GC，存活的对象将会放到s0,s1其中的一个区，而空着的一个Survivor区则称为to区；当Survivor区满了之后不会直接触发GC，而是当Eden区满了之后触发Minor GC/Young GC会同时对Survivor进行GC处理，把from区存活的对象放到to区，from就会变成to，to变成from，如果from区满了之后，剩余存活的对象直接进入老年代；对象每存活一次，就会有一个计数器记录着这个对象存活了多少次，当超过15次之后，将进入到老年代或者是Survivor区相同年龄的所有对象大于Survivor空间的一半则进入老年代；老年代满后直接FGC</p></blockquote><p>设置堆空间大小的参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">-Xmn设置新生代的空间大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line">    </span><br><span class="line">//获取jvm的堆初始内存总量</span><br><span class="line">long initMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;</span><br><span class="line">//获取jvm的最大内存总量</span><br><span class="line">long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;</span><br><span class="line">System.out.println(&quot;-Xms:&quot;+initMemory+&quot;M&quot;);</span><br><span class="line">System.out.println(&quot;-Xmx:&quot;+maxMemory+&quot;M&quot;);</span><br><span class="line"></span><br><span class="line">jstat -gc 进程id//查看jvm的使用情况 在黑窗口使用</span><br><span class="line">-XX:+PrintGCDetails //GC的详细处理信息</span><br><span class="line"></span><br><span class="line">//新生代和老年代的占比配置</span><br><span class="line">默认：-XX:NewRation=2,表示新生代占1，老年代占2，新生代占整个堆的1/3</span><br><span class="line">可以修改：-XX:NewRation=4,表示新生代占1，老年代占4，新生代占整个堆的1/5</span><br><span class="line">//配置新生代中Eden区和Survivor的占比</span><br><span class="line">-XX:SurvivorRation=8;</span><br></pre></td></tr></table></div></figure><p>逃逸分析：逃逸分析的基本行为就是分析对象的动态作用域；</p><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有逃逸分析；</p><p>反之它被外部方法引用，则发生逃逸。例如作为调用参数传递到其它方法；</p><p>没有发生逃逸的对象，则可以分配到栈上，随着方法的结束，栈空间的对象就被移除；</p><p>代码优化：栈上分配，标量替换；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存上的分配</span><br><span class="line">Person person = new Person();</span><br><span class="line">Person:方法区</span><br><span class="line">person:栈</span><br><span class="line">new Person():堆</span><br></pre></td></tr></table></div></figure><p>java8开始，静态变量，字符串常量池移到堆中；</p>        <h3 id="方法区">          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3>      <p>java7之前加永久代（Perm）,java8之后叫元空间（meta space）</p><p>方法区和堆一样也是被线程共享的内存区域，内存大小可固定或者扩展；用于存储被虚拟机加载的类型信息，运行时常量池(常量，静态变量)等。元空间不在虚拟机设置的内存中，而是使用本地内存；方法区也会OOM;</p><p>方法区的初始大小默认21m,最大内存没有限制；</p><p>方法区参数设置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=100m //初始大小</span><br><span class="line">-XX:MaxMetaspaceSize=1000m //最大值</span><br></pre></td></tr></table></div></figure><p>运行时常量池是方法区的一部分，存储编译期生成的各种字面量与符号引用</p><p>JDK1.8取消了永久代，取代永久代的是元空间。元空间属于本地内存，存储内容不同，元空间存储类的元信息，静态变量和常量池并入堆中。常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名参数等；</p>        <h3 id="直接内存-堆外内存">          <a href="#直接内存-堆外内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3>      <p>直接内存并不是虚拟机运行时数据区的一部分,也不属于虚拟机规范，但是因为被频繁的使用(NIO)，才划出这一块，而且也可能导致OOM.</p><p>可以直接使用Native函数库直接分配堆外内存，然后通过在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>为什么要设置直接内存呢：</p><p>java本身无法对磁盘读写，想要进行磁盘读写必须调用操作系统的方法(Native),调用操作系统方法的时候，CPU会切换到内核态。内核态期间，CPU函数读取磁盘文件，同时在操作系统内存中开辟一块系统缓存，将读取的数据写入到系统缓存区，但是java不能直接读取系统缓存，所以java会在堆内存中开辟自己的缓存区，java再次从系统缓存将数据读取到java缓存区。由于产生了两块缓存区导致访问速度缓慢。</p><p>调用ByteBuffer.allocateDirect()时，会分配一块直接内存，java和系统可以共享该区域，减少一次读写操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM工具</title>
    <link href="https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/"/>
    <id>https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/</id>
    <published>2022-03-01T02:42:32.346Z</published>
    <updated>2022-05-17T06:05:16.558Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JPS">          <a href="#JPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3>      <p>JPS 查看当前运行的java进程</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jps [-lvm] ：用于查看当前机器上运行的java进程</span><br><span class="line">命令格式：</span><br><span class="line">jps [options] [hostid] //hostid不知道默认为当前主机或服务器</span><br><span class="line"></span><br><span class="line">options参数：</span><br><span class="line">-q 不输出类名,jar名和传入的main方法参数</span><br><span class="line">-m 输出传入的main方法参数</span><br><span class="line">-l 输出main类或jar的全限名</span><br><span class="line">-v 输出传入的jvm参数</span><br><span class="line">jps -l,jps -m</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="jstat">          <a href="#jstat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3>      <p>jstat用于生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机每一条线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因，如线程死锁，死循环等。</p><p>jstat (用于监视虚拟机运行时状态信息的命令，可以显示出虚拟机进程中的类加载，内存，垃圾收集等运行数据)</p><p>格式：jstat [option] pid [interval] [count]</p><p>interval 连续输出的时间间隔</p><p>count 连续输出的次数</p><p>option 操作参数</p><p>​    -class 监视类加载，卸载数量，总空间以及耗费的时间</p><p>​    jstat -class 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loaded：加载class的数量</span><br><span class="line">Bytes：已加载class字节大小</span><br><span class="line">Unloaded：未加载class的数量</span><br><span class="line">Bytes：未加载class字节大小</span><br><span class="line">Time：加载时间</span><br></pre></td></tr></table></div></figure><p>​    -gc 垃圾回收堆的行为统计</p><p>​    jstat -gc 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C即Capacity 总容量，U即Used 已使用的容量</span><br><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></div></figure><p>-gccapacity 同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NGCMN：新生代最小容量</span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line">NGC：当前新生代容量</span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line">OGC：当前老年代大小</span><br><span class="line">OC:当前老年代大小</span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line">YGC：年轻代gc次数</span><br><span class="line">FGC：老年代GC次数</span><br></pre></td></tr></table></div></figure><p>-gcutil 同-gc，不过输出的是已使用空间占总空间的百分比</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S0：幸存1区当前使用比例</span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line">O：老年代使用比例</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></div></figure>        <h3 id="jmap">          <a href="#jmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3>      <p>jmap：用于生成heap dump文件</p><p>-XX:+HeapDumpOnOutOfMemoryError参数可以让虚拟机出现OOM的时候·自动生成dump文件。</p><p>jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><p>命令格式：jmap [option] pid</p><p>option参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump: 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>-dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/data/dump.hprof 21275</span><br><span class="line">jmap -dump:format=b,file=/data/dump.hprof 21275 //所有</span><br></pre></td></tr></table></div></figure>        <h3 id="jhat">          <a href="#jhat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3>      <p>jhat命令是与jmap搭配使用。用来分析jmap生成的dump</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat -port 9010 heapLive.hprof //以html的形式显示出来</span><br></pre></td></tr></table></div></figure>        <h3 id="可视化工具">          <a href="#可视化工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3>      <p>VisualVM,JConsole,JMC等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://anlt-9570.github.io/2022/02/23/Thread/volatile/"/>
    <id>https://anlt-9570.github.io/2022/02/23/Thread/volatile/</id>
    <published>2022-02-23T12:27:35.048Z</published>
    <updated>2022-04-28T03:10:08.442Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>java提供了一种稍微弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。被volatile声明后，编译器不会将该变量上的操作与其它内存操作一起重排序，不会缓存在寄存器或者其它处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronize关键字更轻量级别的同步机制。</p><p>volatile保证了共享变量的可见性</p><p>volatile通常用作某个操作完成，发生中断或者状态的标记。</p><p>满足一下条件，才应该使用volatile变量：</p><p>1.对变量的写入操作不依赖当前值，或者能确保只有单个线程更新变量的值</p><p>2.该变量不会与其它状态变量一起纳入不变性条件中</p><p>3.在访问变量时不需要加锁</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="线程安全" scheme="https://anlt-9570.github.io/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Thread" scheme="https://anlt-9570.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>redis的应用场景</title>
    <link href="https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-02-18T03:55:50.029Z</published>
    <updated>2022-06-13T09:48:16.945Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(列表)：做最新日志列表</span><br><span class="line">zset(有序集合)：做常见日志统计</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动补全功能：使用有序集合，遍历所有字符，完整的字符末尾做个标记</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx：做分布式锁</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浏览记录</span><br><span class="line">使用有序集合(zset)</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://anlt-9570.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>VM_待写</title>
    <link href="https://anlt-9570.github.io/2022/02/14/VMWare/VM/"/>
    <id>https://anlt-9570.github.io/2022/02/14/VMWare/VM/</id>
    <published>2022-02-14T03:31:48.471Z</published>
    <updated>2022-04-28T03:10:22.030Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://anlt-9570.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="jQuery" scheme="https://anlt-9570.github.io/tags/jQuery/"/>
    
    <category term="表格" scheme="https://anlt-9570.github.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="https://anlt-9570.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>linux常用的命令</title>
    <link href="https://anlt-9570.github.io/2022/02/14/linux/linux/"/>
    <id>https://anlt-9570.github.io/2022/02/14/linux/linux/</id>
    <published>2022-02-14T03:22:44.443Z</published>
    <updated>2022-06-23T12:08:05.297Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看指定端口</span><br><span class="line">ps -aux|grep port</span><br><span class="line"></span><br><span class="line">//查看硬件信息</span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line">//查看ip地址</span><br><span class="line">ip add</span><br></pre></td></tr></table></div></figure><p>常用安装使用</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget //安装yum</span><br><span class="line">yum -y install bash-completion //安装自动补全命令</span><br><span class="line">yum  install lrzsz //安装rz上传下载命令</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Tab] 按键 //命令补全</span><br><span class="line">pwd：//显示当前目录</span><br><span class="line">mkdir 目录名称：//创建目录</span><br><span class="line">touch 文件名：创建文件</span><br><span class="line">cat 文件：查看文件所有内容</span><br><span class="line">cat -n 文件：查看文件所有内容显示行号</span><br><span class="line">tac 文件：倒着看</span><br><span class="line">nl 文件：查看文件所有内容显示行号</span><br><span class="line">more 文件：一页一页的显示内容 </span><br><span class="line">less 文件：(上下键)上下查看本页内容,(左右)键 查看上一页和下一页 q 退出</span><br><span class="line">head -n 100 文件：查看100行</span><br><span class="line">tail 文件：查看尾几行 -n 100：从末尾查看100行</span><br><span class="line">tail -f /var/log/messages//查看linux的实时运行日志</span><br></pre></td></tr></table></div></figure><p>linux解压命令</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*.tar用tar–xvf解压</span><br><span class="line">*.gz用gzip-d或者gunzip解压</span><br><span class="line">*.tar.gz和*.tgz用tar–xzf解压</span><br><span class="line">*.bz2用bzip2-d或者用bunzip2解压</span><br><span class="line">*.tar.bz2用tar–xjf解压</span><br><span class="line">*.Z用uncompress解压</span><br><span class="line">*.tar.Z用tar–xZf解压</span><br><span class="line">*.rar用unrare解压</span><br><span class="line">*.zip用unzip解压</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker安装部署使用</title>
    <link href="https://anlt-9570.github.io/2022/02/14/docker/docker/"/>
    <id>https://anlt-9570.github.io/2022/02/14/docker/docker/</id>
    <published>2022-02-14T03:22:25.566Z</published>
    <updated>2022-05-01T14:11:41.950Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="docker-安装">          <a href="#docker-安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2>      <p>docker要求CenterOS系统的内核版本3.10以上，可以通过<kbd>uname -r</kbd>命令来查看CenterOS是否支持Docker。</p><p>如果系统低了，通过<kbd>yum -y update</kbd>命令更新</p><p>安装docker需要的依赖软件包</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></div></figure><p>卸载</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engin</span><br></pre></td></tr></table></div></figure><p>设置yum源</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></div></figure><p>查看docker的版本</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></div></figure><p>安装docker</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker //启动</span><br><span class="line">systemctl enable docker //开机启动</span><br><span class="line">docker version //查看版本</span><br></pre></td></tr></table></div></figure>        <h2 id="docker的常用命令">          <a href="#docker的常用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h2>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker search java//搜索</span><br><span class="line">docker pull java //下载镜像</span><br><span class="line">docker stop id //停止容器</span><br><span class="line">docker rm id //删除容器</span><br><span class="line">docker rmi 镜像名称或ID //删除镜像</span><br><span class="line">docker images //查看已经下载或者自己构建的镜像</span><br><span class="line">docker ps //查看正在运行的容器</span><br><span class="line">docker ps -a //查看所有容器</span><br><span class="line">docker inspect id //查询容器信息</span><br><span class="line">docker build -t 名称 . dockerfile位置  //构建镜像</span><br><span class="line">docker run -d -p 对外端口:对外端口 -v 磁盘路径:容器里面的路径 镜像名 //运行并构建容器 -d 表示后台运行 -v文件挂载</span><br><span class="line">docker exec -it 容器id /bin/bash   //进入容器</span><br><span class="line">docker tag 镜像id 自定义名称  //修改镜像名称</span><br><span class="line">docker create 自定义容器名称 镜像名称  //创建容器</span><br><span class="line">docker logs -f -t --tail=100 容器id //查看容器的日志 -f跟踪实时日志 -t显示时间 --tail=100显示多少行</span><br><span class="line">docker logs 容器id//</span><br><span class="line">docker cp 容器id:容器路径 目标路径 //把容器的文件复制到指定目录</span><br><span class="line">//容器内安装vim</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line">--net=host//表示不用做端口映射，外部可以直接访问，进入容器后显示的是主机名称，而不是容器id</span><br><span class="line">--cap-add NET_ADMIN //开放网络的权限</span><br><span class="line">--privileged=true //开放容器的所有权限</span><br><span class="line">-it //交互模式运行，进入容器查看</span><br></pre></td></tr></table></div></figure>        <h2 id="docker-nginx部署vue项目">          <a href="#docker-nginx部署vue项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker-nginx部署vue项目" class="headerlink" title="docker+nginx部署vue项目"></a>docker+nginx部署vue项目</h2>      <p>在服务器创建pack_vue文件，npm run build 打包vue项目，把dist文件压缩上传到该目录并解压。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build //打包vue项目</span><br><span class="line">unrar x xxx.rar  //解压以rar结尾的压缩包</span><br></pre></td></tr></table></div></figure><p>在pack_vue目录下创建dockerfile和nginx.conf文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#dockerfile文件</span><br><span class="line"></span><br><span class="line"># 设置基础镜像</span><br><span class="line">FROM nginx</span><br><span class="line">COPY dist/  /usr/share/nginx/html/   # 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面</span><br><span class="line">COPY nginx.conf /etc/nginx/conf.d/default.conf   #拷贝nginx.conf文件到镜像下，替换原有的文件</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       801;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html; #配置vue项目的根路径</span><br><span class="line">            index  index.html index.htm; #配置首页</span><br><span class="line">            try_files $uri $uri/ /index.html; #防止刷新报404</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>构建镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-vue .  //mu-vue表示镜像的名称(随意取)  .(点)表示dockerfile文件所在位置</span><br></pre></td></tr></table></div></figure><p>运行并构建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:80 my-vue   //-d 表示后台启动  -p表映射的端口  对外端口:对内端口   -v 文件挂载</span><br></pre></td></tr></table></div></figure><p>注：dist文件，nginx.conf，dockerfile都是在同一目录下</p>        <h2 id="docker部署springboot项目">          <a href="#docker部署springboot项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h2>      <p>把项目打成jar报上传到服务器，然后配置dockerfile</p><p>配置dockerfile</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#指定java环境</span><br><span class="line">from java:8</span><br><span class="line">#将jar报添加到容器中并修改名称</span><br><span class="line">add demos-0.0.1-SNAPSHOT.jar demos.jar</span><br><span class="line">#可以指定端口</span><br><span class="line">#expose 8088</span><br><span class="line">#运行jar包</span><br><span class="line">entrypoint [&quot;java&quot;,&quot;-jar&quot;,&quot;/demos.jar&quot;]</span><br></pre></td></tr></table></div></figure><p>构建镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t demos .</span><br></pre></td></tr></table></div></figure><p>运行并构建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8686:8686 demos</span><br></pre></td></tr></table></div></figure><p>注：jar包和dockerfile在同一目录.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>My_Test</title>
    <link href="https://anlt-9570.github.io/2022/02/14/Text/"/>
    <id>https://anlt-9570.github.io/2022/02/14/Text/</id>
    <published>2022-02-14T03:21:44.857Z</published>
    <updated>2022-03-04T12:53:41.022Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
