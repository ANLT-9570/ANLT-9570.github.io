<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANLT-9570</title>
  
  
  <link href="https://anlt-9570.github.io/atom.xml" rel="self"/>
  
  <link href="https://anlt-9570.github.io/"/>
  <updated>2023-05-07T13:46:52.909Z</updated>
  <id>https://anlt-9570.github.io/</id>
  
  <author>
    <name>xc9570</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql_MVCC</title>
    <link href="https://anlt-9570.github.io/2023/05/07/MySQL/MySQL/"/>
    <id>https://anlt-9570.github.io/2023/05/07/MySQL/MySQL/</id>
    <published>2023-05-07T13:46:52.908Z</published>
    <updated>2023-05-07T13:46:52.909Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h4 id="MySQL日志：">          <a href="#MySQL日志：" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL日志：" class="headerlink" title="MySQL日志："></a>MySQL日志：</h4>      <p>​        <strong>redo log</strong>：记录InnoDB存储引擎中的事务操作（CUD）,也就是物理日志（用于宕机或崩溃回复）</p><p>​        <strong>undo log</strong>：记录数据修改操作的反向操作（用于事务回滚）</p><p>​        <strong>bin log</strong>：记录MySQL的所有数据库的操作，即逻辑日志；比如数据库结构和数据的增删改操作，例： CREATE、ALTER、DROP、                        INSERT、UPDATE 和 DELETE 等（用于数据备份，恢复，复制等）</p>        <h4 id="事务的特性：">          <a href="#事务的特性：" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务的特性：" class="headerlink" title="事务的特性："></a>事务的特性：</h4>      <p>​        <strong>原子性</strong>：由undo log实现</p><p>​        <strong>持久性</strong>：由redo log实现</p><p>​        <strong>隔离性</strong>：加锁（当前读）或者MVCC（快照读）实现</p><p>​        <strong>一致性</strong>：由undo log ,redo log ,隔离性共同实现</p>        <h4 id="并发事务产生的一些问题：">          <a href="#并发事务产生的一些问题：" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发事务产生的一些问题：" class="headerlink" title="并发事务产生的一些问题："></a>并发事务产生的一些问题：</h4>      <p>​        <strong>脏读</strong>：读到了其它事物未提交的数据，意味着可能这些数据会回滚；</p><p>​        <strong>不可重复读</strong>：在一个事务内，多次读取某个数据，却得到不同的结果；(读到了update后的数据)</p><p>​        <strong>幻读</strong>：在一个事务内，多次读取某个数据，却得到不同的结果；(insert,delete)</p><p>​        不可重复读和幻读都是读到了其它事物以提交的数据，但是它们针对的点不同；</p>        <h4 id="事务的隔离级别：">          <a href="#事务的隔离级别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h4>      <p>​        <strong>读未提交</strong>：一个事务可以读取另一个未提交事务的数据。可能会导致脏读，幻读，或不可重复读；</p><p>​        <strong>读已提交</strong>：一个事务要等另一个事务提交后，才能读取数据。可能会导致幻读和不可重复度；</p><p>​        <strong>可重复度</strong>：开始读取数据(事务开启)时，不在允许修改操作。可能会导致幻读。(<strong>MySQL默认的隔离级别</strong>)</p><p>​        <strong>可串行化</strong>：最高隔离级别。可避免脏读，幻读，不可重复；</p><p>同一行数据发生读写请求时，写会上锁阻塞住。但MVCC用更好的方式处理读写请求，做到在发生读写请求冲突时不用加锁。这个读指的是快照读，而不是当前读，当前读是一种加锁操作(悲观锁)。</p><p>​        <strong>当前读</strong>：读取的数据库记录都是当前最小版本的，会对当前数据进行加锁，防止其它事物修改数据；是悲观锁的一种；</p><p>​                        select lock in share mode(共享锁)，select for update(排它锁)，update,insert,delete(排它锁)都是当前读</p><p>​        <strong>快照读</strong>：快照读是基于多版本并发控制实现，即是MVCC;它读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据；</p><p>MVCC实现原理：</p><p>​        MVCC基于，3个隐试字段，undolog，版本链，readView实现的；MVCC是维持一个数据的多个版本，使读写操作没有冲突的一个抽象概念。</p><p>​        3个隐试字段：</p><p>​                        DB_TRX_ID：事务ID，记录这条记录最后一次被哪个事务ID修改</p><p>​                        DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本；</p><p>​                        DB_ROW_ID：自增ID；如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引</p><p>​                        </p><p>​        undolog:记录数据修改操作的反向操作（用于事务回滚）</p><p>​        版本链：多个事务对数据修改产生的日志；比如有一条数据(name=aa,age=10),事务1要对其进行修改，数据库会对他先加排它锁，                        然后把该数据记录到undolog中，作为旧记录，即在undolog中有当前行的副本，记录完后，修改该行name=b,并且修改该                              行的隐藏字段事务id为1，默认从1开始，之后递增，回滚指针指向undolog的副本记录，表示我的上一个版本就是它…以此                        类推，隐藏字段事务id递增，2,3,4…..n;回滚指针则会指向它的上一个版本；以此形成版本链；</p><p>​                        </p><p>​        readView：readView记录了当前事务开始时间点之前，已提交的事务版本号和快照数据；在MVCC中，每个事物在执行读操作时，                                   都有自己的视图(readView)，用于确定当前事务可以看见哪些数据版本；</p><p>​                            readView中包含的信息：</p><p>​                                当前事务的事务ID(m_tx_id)：用于确定当前事务提交时是否需要参与冲突检测</p><p>​                                快照版本号(m_low_limit_id)：数据库系统生成readView分配的事务ID最大值+1</p><p>​                                活跃版本号(m_up_limit_id)：存储活跃事务列表中最小的ID</p><p>​                                已提交的事务列表（m_trx_ids）：正在活跃(活跃：指正在对数据进行操作，还没完成，事务没提交)的事务ID列表；</p><p>​                                m_ids：存储该行记录历史版本事务ID(记录该记录被哪些事务id修改过);</p><p>​                                creator_trx_id：创建该readView的事务ID，也就是当前事务的ID；</p><p>​        可见性判断：事务在对数据读取操作时，会从undolog实例版本链中，从最新版本开始往前对比，通过一系列的规则来判断该版本对当前事务是否可见，如果不可见则通过roll_pointer继续进行对比，直到找到可见版本或找不到任何一个可见版本为止。</p><p>​        可见性判断的规则：</p><p>​                如果DB_TRX_ID(该版本的事务ID) &lt; m_up_limit_id,说明该版本对于当前事务是可见的;(说明该版本已提交事务，不在事务列表)</p><p>​                如果DB_TRX_ID(该版本的事务ID) &gt;= m_low_limit_id,说明该版本对于当前事务是不可见的;(说明该版本的事务是之后生成的)</p><p>​                如果m_up_limit_id&lt;=DB_TRX_ID&lt;m_low_limit_id,说明该版本对于当前事务是不可见的;(说明该版本的事务在活跃事务列表中，                事务还没提交)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://anlt-9570.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis_Study</title>
    <link href="https://anlt-9570.github.io/2023/02/24/redis/Redis/"/>
    <id>https://anlt-9570.github.io/2023/02/24/redis/Redis/</id>
    <published>2023-02-24T03:50:48.815Z</published>
    <updated>2023-02-24T03:50:50.642Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h4 id="1-Redis安装">          <a href="#1-Redis安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Redis安装" class="headerlink" title="1.Redis安装"></a>1.Redis安装</h4>      <p>下载地址： <span class="exturl"><a class="exturl__link" href="https://github.com/microsoftarchive/redis/tags">https://github.com/microsoftarchive/redis/tags</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (windos版)</p><p>下载后解压，然后到redis的目录双击redis-server.exe，就可以启动服务了，或者在目录下打开cmd窗口，执行 <code>redis-server.exe --service-install redis.windows.conf</code>该命令安装redis服务，去服务列表看是否安装成功，安装成功后顺便启动服务;</p><p><code>redis-server.exe redis.windows.conf </code>//只启动服务</p><p>然后到redis的安装目录双击 redis-cli.exe运行就可进行数据操作了，或者打开cmd黑窗口执行<code>redis-cli.exe -h 127.0.0.1 -p 6379</code></p><p>该命令也可以</p>        <h4 id="2-Redis的5种数据结构">          <a href="#2-Redis的5种数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Redis的5种数据结构" class="headerlink" title="2.Redis的5种数据结构"></a>2.Redis的5种数据结构</h4>      <p>STRING(字符串)：键值的存储单个字符串</p><p>LIST(列表)：有序的存储多个字符串且可以相同</p><p>SET(集合)：无序的存储多个字符串且不可以相同（通过散列表保证数据的不同）</p><p>HASH(散列)：可以存储多个键键值的形式，后面的键值和字符一样</p><p>ZSET(有序集合)：存储结构跟散列一样，但是以键值键存储，值必须是浮点数，可以根据浮点数排序</p>        <h5 id="2-1-STRING-字符串-的命令">          <a href="#2-1-STRING-字符串-的命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-STRING-字符串-的命令" class="headerlink" title="2.1 STRING(字符串)的命令"></a>2.1 STRING(字符串)的命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET //设置存储的键值  set key value  </span><br><span class="line">--&gt; 例： set hello world //如果key相同会把之前的值覆盖掉 可以设置过期时间</span><br><span class="line">SETNX //设置存储的键值 不能设置过期时间</span><br><span class="line">GET //获取存储的键值  get key ---&gt; 例：get hello</span><br><span class="line">DEL //删除存储的键值  del key ---&gt; 例：del hello</span><br><span class="line">INCR //自增1 ,如果不是数字会报错 incr key -&gt; 例：incr t</span><br><span class="line">DECR //自减1 decr key -&gt; 例：decr t</span><br><span class="line">INCRBY // 自增指定值 incrby key amount -&gt; 例：incrby t 2</span><br><span class="line">DECRBY // 自减指定值 decrby key amount -&gt; 例：decrby t 2</span><br><span class="line">INCRBYFLOAT //加上浮点数 incrbyfloat t 1.2</span><br></pre></td></tr></table></div></figure><p><img src="/2023/02/24/redis/Redis/image-20220211155742883.png" alt="image-20220211155742883"></p>        <h5 id="2-2-LIST-列表-命令">          <a href="#2-2-LIST-列表-命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-LIST-列表-命令" class="headerlink" title="2.2 LIST(列表)命令"></a>2.2 LIST(列表)命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lpush //向集合的左边(头)添加数据 lpush key value -&gt; 例：lpush hello word</span><br><span class="line">rpush //向集合的右边(尾)添加数据 rpush key value -&gt; 例：rpush hello word2</span><br><span class="line">lrange//从指定的开始位置到结束位置查看集合数据 lrange key start end </span><br><span class="line">-&gt; 例：lrange hello 0 -1 //-1表示查看这个列表数据</span><br><span class="line">lindex//查看指定位置索引的数据lindex key index -&gt; 例：lindex hello 1</span><br><span class="line">lpop//从列表的最左边弹出一个元素,弹出后该元素将不再列表 lpop key -&gt; 例：lpop hello</span><br><span class="line">rpop//...</span><br><span class="line">rpoplpush //rpoplpush source desc -&gt; rpoplpush q1 q2 从q1列表弹出最右边的一个元素，推到q2左边</span><br><span class="line">阻塞式命令</span><br><span class="line">BLPOP //blpop key timeout -&gt; 例：blpop test 10 //左</span><br><span class="line">BRPOP //...右</span><br><span class="line">BRPOPLPUSH // brpoplpush source desc timeout -&gt; brpoplpush q1 q2 3</span><br><span class="line">//从q1列表弹出最右边的一个元素，推到q2左边。在timeout秒之内阻塞等待可弹出元素</span><br></pre></td></tr></table></div></figure><p><img src="/2023/02/24/redis/Redis/picture%5Cimage-20220211161732124.png" alt="image-20220211161732124"></p>        <h5 id="2-3-SET-集合-命令">          <a href="#2-3-SET-集合-命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-SET-集合-命令" class="headerlink" title="2.3 SET(集合)命令"></a>2.3 SET(集合)命令</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sadd //向集合添加元素 sadd key member -&gt; 例：sadd hello word //1，添加成功,0集合已存在该数据</span><br><span class="line">smembers //查看集合中所有元素 smembers key -&gt; 例： smembers hello</span><br><span class="line">sismember key member //查找指定元素是否在集合 1，存在,0,不存在 -&gt; 例：sismember hello word</span><br><span class="line">srem key member //删除集合指定的元素(返回删除的数量)  -&gt; 例：srem hello word</span><br><span class="line">scard //返回集合包含元素的数量(集合的大小size) scard key</span><br><span class="line">srandmember //从集合里随机返回指定数量的数据，count为正数返回的元素不从复，为负数数据可能会重复</span><br><span class="line">//srandmember key count</span><br><span class="line">spop //随机移除集合元素不指定默认一个 spop key [count]</span><br><span class="line">smove //从source集合移动member元素到desc集合 返回1表示成功反之</span><br><span class="line">sdiff //返回第一个集合不存在其它集合的数据 sdiff key [...]</span><br><span class="line">sunion // 返回多个集合中各不相同的数据 sunion key [...]</span><br><span class="line">sinter //返回多个集合并集 sinter key [...]</span><br></pre></td></tr></table></div></figure><p><img src="/2023/02/24/redis/Redis/picture%5Cimage-20220211165652946.png" alt="image-20220211165652946"></p>        <h5 id="2-4HASH-散列">          <a href="#2-4HASH-散列" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4HASH-散列" class="headerlink" title="2.4HASH(散列)"></a>2.4HASH(散列)</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HSET //在一个键中在设置一个键值对 hset key field value -&gt; 例：hset hellos h1 h1_word</span><br><span class="line">HGET //获取键的键值 hget key field -&gt; 例：hget hellos h1</span><br><span class="line">HGETALL //获取所以键的键值对 hgetall key -&gt; 例： hgetall hellos</span><br><span class="line">HDEL //删除键的键 hdel key field  -&gt; 例：hdel hellos h1</span><br><span class="line">HINCRBY //对键的键自增指定数量 hincrby key key increment -&gt; 例：hincrby htest ht 2</span><br><span class="line"></span><br><span class="line">HMGET //从散列里获取一个或者多个键的值 hmget key field [field...]</span><br><span class="line">HMSET //设置单个或者多个键值对 hmset key field value [field value...]</span><br><span class="line">HLEN //获取散列表的数量 hlen key</span><br><span class="line"></span><br><span class="line">HEXISTS //检查某个键是否在散列表 hexists key field</span><br><span class="line">HKEYS //获取所有的键 hkeys key</span><br><span class="line">HVALS //获取所以键的值 hvals key </span><br><span class="line">HINCRBY //将key的值加上指定数量 hincrby key field increment</span><br><span class="line">HINCRBYFLOAD //将key的值加上指定数量(浮点数) hincrbyfloat key field increment</span><br></pre></td></tr></table></div></figure><p><img src="/2023/02/24/redis/Redis/picture%5Cimage-20220211171713508.png" alt="image-20220211171713508"></p>        <h5 id="2-5-ZSET-有序集合">          <a href="#2-5-ZSET-有序集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-ZSET-有序集合" class="headerlink" title="2.5 ZSET(有序集合)"></a>2.5 ZSET(有序集合)</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ZADD //将带有分值的成员添加到有序集合 zadd key value member -&gt; 例：zadd hs 10 h1</span><br><span class="line">ZRANGE //获取指定区间的元素 zrange key start stop [withscores](可又可无)</span><br><span class="line">-&gt; 例：zrange hs 0 -1 withscores</span><br><span class="line">ZRANGEBYSCORE //获取给定分数范围的元素 zrangebyscore key min max [withscores]</span><br><span class="line">-&gt; 例：zrangebyscore hs 10 40 </span><br><span class="line">ZREVRANGEBYSCORE //根据分值大到小的返回，其余同上</span><br><span class="line"></span><br><span class="line">ZREM //删除指定键的成员 zrem key member -&gt; 例：zrem hs h1</span><br><span class="line">ZINCRBY //给指定的成员自增指定的数量 zincrby key increment member -&gt; 例：zincrby ztest 3 zt</span><br><span class="line">zrevrange //根据评分从高到底排序获取数据 zrevrange hs 0 -1 withscores -&gt; 例：zrevrange hs 0 -1 [withscores] </span><br><span class="line"></span><br><span class="line">ZCARD //获取有序集合的数量 zcard key</span><br><span class="line">ZCOUNT //获取指定区间的值 zcount key min max</span><br><span class="line">ZRANK // 获取成员在有序集合的位置(索引) zrank key member</span><br><span class="line">ZSCORE //获取成员的分值 zscore key member</span><br><span class="line">ZREVRANK //返回成员的排名 按照分值从大到小排 zrevrank key member</span><br><span class="line">ZINTERSTORE //多个集合(集合的值和有序集合的键成员member)或者有序集合的交集之和 数据量多会比较慢</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK //移除在start和top之间的排名成员 zremrangebyrank key start top</span><br><span class="line">ZREMRANGEBYSCORE //移除在min和max之间分值的成员 zremrangebyscore key min max</span><br><span class="line"></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">属性：</span><br><span class="line">destination：新的集合名称</span><br><span class="line">numkeys：多少个集合要合并</span><br><span class="line">key：要合并的集合，多个空格隔开</span><br><span class="line">-&gt; 例： zinterstore newzt 2 zts zts2</span><br></pre></td></tr></table></div></figure><p><img src="/2023/02/24/redis/Redis/picture%5Cimage-20220211181836780.png" alt="image-20220211181836780"></p>        <h5 id="2-6发布与订阅">          <a href="#2-6发布与订阅" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6发布与订阅" class="headerlink" title="2.6发布与订阅"></a>2.6发布与订阅</h5>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subscribe //订阅一个或者多个频道 subscribe channel [channel...]</span><br><span class="line">unsubscribe //取消订阅频道 unsubscribe [channel [channel...]] 如果不指定默认退订所有频道</span><br><span class="line"></span><br><span class="line">publish // 给指定的频道发送消息 publish channel message</span><br><span class="line"></span><br><span class="line">psubscribe //订阅给定模式的频道  psubscribe pattern [pattern...]</span><br><span class="line">punsubscribe //退订给定模式的频道 punsubscribe [pattern [pattern...]] 不指定退订所有频道</span><br></pre></td></tr></table></div></figure>        <h4 id="3-Redis的基本事务">          <a href="#3-Redis的基本事务" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Redis的基本事务" class="headerlink" title="3.Redis的基本事务"></a>3.Redis的基本事务</h4>      <p>redis有5个事务命令，分别为：WATCH,MULTI,EXEC,UNWATCH,DISCARD</p><p>在redis里面，被multi和exec命令包围的所有命令会一个一个地执行，直到所有命令执行完。当一个事务执行完毕之后，redis才会处理其它客户端的命令。要在redis里面执行事务首先执行multi命令，然后输入那些我们想在事务里执行的命令，最后在执行exec命令。当redis从一个客户端接收到multi命令时，redis会将这个客户端发送的命令都放入到一个队列里面，直到客户端发送exec命令为止</p>        <h4 id="键的过期时间">          <a href="#键的过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h4>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">persist -&gt; persist key //移除键的过期时间</span><br><span class="line">ttl -&gt; ttl key //查看键的过期还剩多少秒</span><br><span class="line">expire -&gt; expire key seconds 指定键多少秒后过期</span><br><span class="line">expireat -&gt; expireat key timestamp 指定键的过期时间(时间戳)</span><br><span class="line">pttl -&gt; pttl key 查看键的过期时间剩多少毫秒</span><br><span class="line">pexpire -&gt; pexpire key milliseconds 指定键多少毫秒后过期</span><br></pre></td></tr></table></div></figure><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Thread</title>
    <link href="https://anlt-9570.github.io/2023/02/12/java/multithread/Thread/"/>
    <id>https://anlt-9570.github.io/2023/02/12/java/multithread/Thread/</id>
    <published>2023-02-12T14:19:11.545Z</published>
    <updated>2023-02-19T02:42:20.260Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.interrupted()：清除线程中断标记(如果为true说明当前线程之前设置有中断标记，现在清除成功，如果为fale说明当前线程没有中断标记；静态方法通过Thread.interrupted()直接调用)</span><br><span class="line"></span><br><span class="line">Thread.currentThread().interrupt()：给目标线程设置中断标记，不会阻止目标线程继续执行(线程对象方法)</span><br><span class="line"></span><br><span class="line">Thread.currentThread().isInterrupted()：判断当前线程是否有中断标记(如果为true说明有，反之为false；线程对象方法)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Thread" scheme="https://anlt-9570.github.io/categories/Thread/"/>
    
    
  </entry>
  
  <entry>
    <title>java8的一些新特性</title>
    <link href="https://anlt-9570.github.io/2022/11/21/java/java8_newer/"/>
    <id>https://anlt-9570.github.io/2022/11/21/java/java8_newer/</id>
    <published>2022-11-21T14:08:37.989Z</published>
    <updated>2023-02-19T02:44:23.427Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="函数式接口">          <a href="#函数式接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2>              <h3 id="1-Supplier-gt-todo">          <a href="#1-Supplier-gt-todo" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Supplier-gt-todo" class="headerlink" title="1. Supplier  ()-&gt;{//todo}"></a>1. Supplier  ()-&gt;{//todo}</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier源码 无参数返回一个传入的对象</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用样例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSupplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer status = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; s = () -&gt; <span class="string">&quot;666&quot;</span>;</span><br><span class="line">        String s1 = s.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; ii = () -&gt; <span class="number">666</span>;</span><br><span class="line">        Integer integer = ii.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;TestSupplier&gt; tsssss = () -&gt; <span class="keyword">new</span> TestSupplier();</span><br><span class="line">        TestSupplier testSupplier = tsssss.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; s2 = () -&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;&#125;;</span><br><span class="line">        String s3 = s2.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;TestSupplier&gt; ts = TestSupplier::<span class="keyword">new</span>;</span><br><span class="line">        TestSupplier testSupplier2 = ts.get();</span><br><span class="line"></span><br><span class="line">        TestSupplier testSupplier1 = getTestSupplier(TestSupplier::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        TestSupplier testSupplier3 = (TestSupplier)getTestSuppliers(TestSupplier::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; i = TestSupplier::getStatus;</span><br><span class="line">        Integer integer1 = i.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;TestSupplier&gt; supplier = <span class="keyword">new</span> Supplier&lt;TestSupplier&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TestSupplier <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TestSupplier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getTestSuppliers</span><span class="params">(Supplier&lt;Object&gt; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSupplier <span class="title">getTestSupplier</span><span class="params">(Supplier&lt;TestSupplier&gt; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getStatus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="2-Consumer-s-gt-todo">          <a href="#2-Consumer-s-gt-todo" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Consumer-s-gt-todo" class="headerlink" title="2. Consumer (s)-&gt;{//todo}"></a>2. Consumer (s)-&gt;{//todo}</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Consumer源码 接受一个泛型 &lt;T&gt; 类型参数，进行处理后无任何返回值</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用样例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        testAccept();</span><br><span class="line"></span><br><span class="line">        testThen();</span><br><span class="line"></span><br><span class="line">        tcc((s)-&gt;&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;,<span class="string">&quot;9999999....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcc</span><span class="params">(Consumer&lt;Object&gt; consumer,String s)</span></span>&#123;</span><br><span class="line">        consumer.accept(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAccept</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; sss = s -&gt; System.out.println(s);</span><br><span class="line">        sss.accept(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; ss = System.out::println;</span><br><span class="line">        ss.accept(<span class="string">&quot;66666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con = s -&gt; System.out.println(s.length());</span><br><span class="line">        Consumer&lt;String&gt; cc = con.andThen(System.out::println);</span><br><span class="line">        cc.accept(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testThen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;Integer&gt; ac1 = <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1...&quot;</span>+ ++integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Integer&gt; ac2 = <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2...&quot;</span>+ ++integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Integer&gt; ac3 = <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;3...&quot;</span>+ ++integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ac1.andThen(ac2).andThen(ac3).accept(<span class="number">1</span>);<span class="comment">//执行顺序 ac1   ac2   ac3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="3-Predicate-s-gt-todo">          <a href="#3-Predicate-s-gt-todo" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Predicate-s-gt-todo" class="headerlink" title="3.Predicate (s)-&gt;{//todo}"></a>3.Predicate (s)-&gt;{//todo}</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Predicate源码 </span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用样例主要用於判斷</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPredicate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean aBoolean = cusTest(number -&gt; number &gt; <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(aBoolean);</span><br><span class="line"></span><br><span class="line">        testTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;:-----&quot;</span>);</span><br><span class="line">        testNegate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于判断一个参数是否符合某个条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">cusTest</span><span class="params">(Predicate&lt;Integer&gt; p,Integer s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//predicate.negate() 方法会返回一个与指定判断相反的 Predicate。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNegate</span><span class="params">()</span></span>&#123; <span class="comment">//返回相反值</span></span><br><span class="line">        Predicate&lt;Integer&gt; p = n-&gt; n &gt; <span class="number">5</span>;</span><br><span class="line">        Predicate&lt;Integer&gt; negate = p.negate();</span><br><span class="line">        <span class="keyword">boolean</span> test = negate.test(<span class="number">6</span>);</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        System.out.println(p.negate().test(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于判断一个参数是否符合某个条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; tp = String::isEmpty;</span><br><span class="line">        System.out.println(tp.test(<span class="string">&quot;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(tp.test(<span class="string">&quot;666&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        Predicate&lt;Integer&gt; a = number -&gt; number &gt; <span class="number">5</span>;</span><br><span class="line">        Predicate&lt;Integer&gt; b = number -&gt; number &lt; <span class="number">9</span>;</span><br><span class="line">        <span class="comment">//使用 and() 方法，可以让前后两个 Predicate 判断条件一起生效。</span></span><br><span class="line">        Predicate&lt;Integer&gt; and = a.and(b);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; collect = numberList.stream().filter(and).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 or() 方法，或者..的意思</span></span><br><span class="line">        Predicate&lt;Integer&gt; g = number -&gt; number &gt; <span class="number">5</span>;</span><br><span class="line">        Predicate&lt;Integer&gt; f = number -&gt; number &lt; <span class="number">9</span>;</span><br><span class="line">        Predicate&lt;Integer&gt; or = g.or(f);</span><br><span class="line">        List&lt;Integer&gt; collect2 = numberList.stream().filter(or).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="4-Function-s-gt-todo">          <a href="#4-Function-s-gt-todo" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Function-s-gt-todo" class="headerlink" title="4. Function (s)-&gt;{//todo}"></a>4. Function (s)-&gt;{//todo}</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function源码 它可以接受一个泛型 T 对象，返回一个泛型 R 对象</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用样例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testApply();</span><br><span class="line">        testAndThen();</span><br><span class="line">        String ddd = testMeths(String::toUpperCase, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(ddd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAndThen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Integer&gt; len = str -&gt; str.length();</span><br><span class="line">        Function&lt;Integer, Integer&gt; l = leng -&gt; leng * <span class="number">2</span>;</span><br><span class="line">        Integer apply = len.andThen(l).apply(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(apply);<span class="comment">//6</span></span><br><span class="line">        System.out.println(<span class="string">&quot;......&quot;</span>);</span><br><span class="line">        Function&lt;Integer, Integer&gt; ll = leng -&gt; leng * <span class="number">2</span>;</span><br><span class="line">        Function&lt;Integer, Integer&gt; compose = l.compose(ll);</span><br><span class="line">        Integer apply1 = compose.apply(<span class="number">2</span>);</span><br><span class="line">        System.out.println(apply1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function&lt;String, String&gt; toUpperCase = str -&gt; str.toUpperCase();</span><br><span class="line">        String asd = toUpperCase.apply(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(asd);<span class="comment">//ASD</span></span><br><span class="line"></span><br><span class="line">        Function&lt;String, Integer&gt; len = str -&gt; str.length();</span><br><span class="line">        Integer l = len.apply(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(l);<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testMeths</span><span class="params">(Function&lt;String, String&gt; f,String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.apply(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Optional介紹">          <a href="#Optional介紹" class="heading-link"><i class="fas fa-link"></i></a><a href="#Optional介紹" class="headerlink" title="Optional介紹"></a>Optional介紹</h2>      <p>Optional主要用於緩解空指針的發生；</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOptional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        create();<span class="comment">//創建和獲取值</span></span><br><span class="line">        checkOptional();<span class="comment">//判斷</span></span><br><span class="line">        whenIsNullGetDefault();<span class="comment">//如果為空獲取默認值</span></span><br><span class="line">        testFunction();<span class="comment">//使用函數接口 filter map flatMap</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 創建Optional的3中方式和取值</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Optional.get()取值，如果為空會報空指針</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">//of傳入的值不能為 null</span></span><br><span class="line">        Optional&lt;String&gt; hello = Optional.of(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回一個空的Optional 但get會報錯</span></span><br><span class="line">        Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class="line"><span class="comment">//        System.out.println(empty.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//應許傳入的值為null 但get會報錯</span></span><br><span class="line">        Optional&lt;Object&gt; o = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//        System.out.println(o.get());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Optional.isPresent() 判斷對象是否存在 存在返回true反之false</span></span><br><span class="line">        Optional&lt;String&gt; hello = Optional.of(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.isPresent());<span class="comment">//判斷是否存在   ---&gt; true</span></span><br><span class="line"></span><br><span class="line">        Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class="line">        System.out.println(empty.isPresent());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Optional.ifPresent(Consumer&lt;T&gt; consumer) 判斷對象是否存在 存在執行括號裡的lambda表達式反之</span></span><br><span class="line">        hello.ifPresent(s-&gt; System.out.println(s));</span><br><span class="line">        empty.ifPresent(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whenIsNullGetDefault</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Optional.orElse(T t) 沒有值就返回空號的值</span></span><br><span class="line"><span class="comment">        * Optional.orElseGet(Supplier&lt;T&gt; t) 沒有值執行空號里的lambda和返回</span></span><br><span class="line"><span class="comment">        * Optional.orElseThrow(Supplier&lt;T&gt; exceptionSupplier)沒有值執行空號里的lambda拋出異常</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class="line">        System.out.println(empty.orElse(<span class="string">&quot;6666&quot;</span>));</span><br><span class="line">        Object o = empty.orElseGet(() -&gt; &#123;<span class="keyword">return</span> <span class="string">&quot;dddd&quot;</span>;&#125;);</span><br><span class="line">        Object dddd = empty.orElseThrow(() -&gt; <span class="keyword">new</span> Exception(<span class="string">&quot;dddd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; integer = Optional.of(<span class="number">123</span>);</span><br><span class="line">        integer.filter(s-&gt; s == <span class="number">123</span>).ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Integer&gt; integer1 = Optional.of(<span class="number">789</span>);</span><br><span class="line">        integer1.map(String::valueOf).map(String::length).ifPresent(System.out::println);</span><br><span class="line">        Optional&lt;String&gt; s = integer1.map(String::valueOf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="時間-LocalDateTime-LocalDate-LocalTime">          <a href="#時間-LocalDateTime-LocalDate-LocalTime" class="heading-link"><i class="fas fa-link"></i></a><a href="#時間-LocalDateTime-LocalDate-LocalTime" class="headerlink" title="時間(LocalDateTime,LocalDate,LocalTime)"></a>時間(LocalDateTime,LocalDate,LocalTime)</h2>      <figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        getTime();<span class="comment">//獲取時間</span></span><br><span class="line">        createTime();<span class="comment">//創建時間</span></span><br><span class="line">        convertTime();<span class="comment">//時間轉換</span></span><br><span class="line">        formatTime();<span class="comment">//時間格式化</span></span><br><span class="line">        calcTime();<span class="comment">//時間加減</span></span><br><span class="line">        diffTime();<span class="comment">//時間比較</span></span><br><span class="line">        extendTime();<span class="comment">//時間擴展</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void getTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;..............獲取時間&quot;</span>);</span><br><span class="line">        <span class="comment">//獲取當前時間戳</span></span><br><span class="line">        long l <span class="operator">=</span> <span class="type">LocalDateTime</span>.now().toInstant(<span class="type">ZoneOffset</span>.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="type">System</span>.out.println(l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//當前的精確時間 年月日時分秒    LocalDateTime</span></span><br><span class="line">        <span class="type">LocalDateTime</span> now <span class="operator">=</span> <span class="type">LocalDateTime</span>.now();</span><br><span class="line">        <span class="type">System</span>.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//當前日期 年月日  LocalDate</span></span><br><span class="line">        <span class="type">LocalDate</span> now1 <span class="operator">=</span> <span class="type">LocalDate</span>.now();</span><br><span class="line">        <span class="type">System</span>.out.println(now1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//現在時間 時分秒  LocalTime</span></span><br><span class="line">        <span class="type">LocalTime</span> now2 <span class="operator">=</span> <span class="type">LocalTime</span>.now();</span><br><span class="line">        <span class="type">System</span>.out.println(now2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//當前時區的精確時間 年月日時分秒</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> zdt <span class="operator">=</span> <span class="type">LocalDateTime</span>.now().atZone(<span class="type">ZoneId</span>.systemDefault());</span><br><span class="line">        <span class="type">System</span>.out.println(zdt);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(zdt.getYear()<span class="operator">+</span><span class="string">&quot;.&quot;</span><span class="operator">+</span>zdt.getMonthValue()</span><br><span class="line">                <span class="operator">+</span><span class="string">&quot;.&quot;</span><span class="operator">+</span>zdt.getDayOfMonth()<span class="operator">+</span><span class="string">&quot;.&quot;</span><span class="operator">+</span>zdt.getHour()<span class="operator">+</span><span class="string">&quot;.&quot;</span><span class="operator">+</span>zdt.getMinute()<span class="operator">+</span><span class="string">&quot;.&quot;</span><span class="operator">+</span>zdt.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void createTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;........................創建時間&quot;</span>);</span><br><span class="line">        <span class="comment">//LocalDateTime</span></span><br><span class="line">        <span class="type">LocalDateTime</span> of <span class="operator">=</span> <span class="type">LocalDateTime</span>.of(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;年月日時分秒：&quot;</span><span class="operator">+</span>of);</span><br><span class="line">        <span class="comment">//LocalDate</span></span><br><span class="line">        <span class="type">LocalDate</span> of1 <span class="operator">=</span> <span class="type">LocalDate</span>.of(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;年月日：&quot;</span><span class="operator">+</span>of1);</span><br><span class="line">        <span class="comment">//LocalTime</span></span><br><span class="line">        <span class="type">LocalTime</span> of2 <span class="operator">=</span> <span class="type">LocalTime</span>.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;時分秒：&quot;</span><span class="operator">+</span>of2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void convertTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;.............時間轉換&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串时间转换</span></span><br><span class="line">        <span class="type">LocalDateTime</span> parse <span class="operator">=</span> <span class="type">LocalDateTime</span>.parse(<span class="string">&quot;2020-12-12T12:12:12&quot;</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;字符串时间转换：&quot;</span><span class="operator">+</span>parse);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> parse1 <span class="operator">=</span> <span class="type">LocalDate</span>.parse(<span class="string">&quot;20201212&quot;</span>, <span class="type">DateTimeFormatter</span>.<span class="type">BASIC_ISO_DATE</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;字符串时间转换-指定格式：&quot;</span> <span class="operator">+</span> parse1);<span class="comment">//2020-12-12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date轉換成LocalDateTime</span></span><br><span class="line">        <span class="type">Instant</span> instant <span class="operator">=</span> new <span class="type">Date</span>().toInstant();</span><br><span class="line">        <span class="type">ZoneId</span> zoneId <span class="operator">=</span> <span class="type">ZoneId</span>.systemDefault();</span><br><span class="line">        <span class="type">LocalDateTime</span> ldt <span class="operator">=</span> <span class="type">LocalDateTime</span>.ofInstant(instant, zoneId);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;Date轉換成LocalDateTime：&quot;</span><span class="operator">+</span>ldt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LocalDateTime轉換成Date</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> zdt <span class="operator">=</span> <span class="type">LocalDateTime</span>.now().atZone(<span class="type">ZoneId</span>.systemDefault());</span><br><span class="line">        <span class="type">Date</span> date <span class="operator">=</span> <span class="type">Date</span>.from(zdt.toInstant());</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;LocalDateTime轉換成Date：&quot;</span><span class="operator">+</span>date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前时间转时间戳</span></span><br><span class="line">        long epochMilli <span class="operator">=</span> <span class="type">LocalDateTime</span>.now().toInstant(<span class="type">ZoneOffset</span>.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;当前时间转时间戳：&quot;</span> <span class="operator">+</span> epochMilli);</span><br><span class="line">        <span class="comment">// 时间戳转换成时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> epochMilliTime <span class="operator">=</span> <span class="type">LocalDateTime</span>.ofInstant(<span class="type">Instant</span>.ofEpochMilli(epochMilli), <span class="type">ZoneId</span>.systemDefault());</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;时间戳转换成时间：&quot;</span> <span class="operator">+</span> epochMilliTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void formatTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;................時間格式化&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> now <span class="operator">=</span> <span class="type">LocalDateTime</span>.now();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當前時間：&quot;</span><span class="operator">+</span>now);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;格式化-年月日時分秒：&quot;</span><span class="operator">+</span>now.format(<span class="type">DateTimeFormatter</span>.<span class="type">ISO_LOCAL_DATE_TIME</span>));</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;格式化-年月日：&quot;</span><span class="operator">+</span>now.format(<span class="type">DateTimeFormatter</span>.<span class="type">ISO_DATE</span>));</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;格式化-時分秒：&quot;</span><span class="operator">+</span>now.format(<span class="type">DateTimeFormatter</span>.<span class="type">ISO_LOCAL_TIME</span>));</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;格式化-自定義格式化：&quot;</span><span class="operator">+</span>now.format(<span class="type">DateTimeFormatter</span>.ofPattern(<span class="string">&quot;YYYY-MM&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void calcTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;............時間加減&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> now <span class="operator">=</span> <span class="type">LocalDateTime</span>.now();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當前時間：&quot;</span><span class="operator">+</span>now);</span><br><span class="line">        <span class="type">LocalDateTime</span> ldt <span class="operator">=</span> now.plusYears(<span class="number">1</span>).plusMonths(<span class="number">1</span>).plusDays(<span class="number">1</span>).plusHours(<span class="number">1</span>).plusMinutes(<span class="number">1</span>).plusSeconds(<span class="number">1</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;增加1年1月1日時1分1秒：&quot;</span><span class="operator">+</span>ldt);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> months <span class="operator">=</span> now.minusMonths(<span class="number">6</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;減少兩個月&quot;</span><span class="operator">+</span>months);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void diffTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;.............時間比較&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> now <span class="operator">=</span> <span class="type">LocalDateTime</span>.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> ldt <span class="operator">=</span> now.minusDays(<span class="number">2</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(now);</span><br><span class="line">        <span class="type">System</span>.out.println(ldt);</span><br><span class="line">        <span class="type">System</span>.out.println(now.isAfter(ldt));<span class="comment">//now是否在ldt後面 返回boolean類型</span></span><br><span class="line">        <span class="type">System</span>.out.println(now.isBefore(ldt));<span class="comment">//now是否在ldt前面 返回boolean類型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//時間差比較</span></span><br><span class="line">        long month <span class="operator">=</span> ldt.until(now, <span class="type">ChronoUnit</span>.<span class="type">MONTHS</span>);</span><br><span class="line">        long days <span class="operator">=</span> ldt.until(now, <span class="type">ChronoUnit</span>.<span class="type">DAYS</span>);</span><br><span class="line">        long hours <span class="operator">=</span> ldt.until(now, <span class="type">ChronoUnit</span>.<span class="type">HOURS</span>);</span><br><span class="line">        long minutes <span class="operator">=</span> ldt.until(now, <span class="type">ChronoUnit</span>.<span class="type">MINUTES</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;相差月數：&quot;</span><span class="operator">+</span>month);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;相差天數：&quot;</span><span class="operator">+</span>days);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;相差小時：&quot;</span><span class="operator">+</span>hours);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;相差分鐘：&quot;</span><span class="operator">+</span>minutes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void extendTime()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;...............時間擴展&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> now <span class="operator">=</span> <span class="type">LocalDateTime</span>.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> localDateTime <span class="operator">=</span> now.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當月的第1天：&quot;</span><span class="operator">+</span>localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> localDateTime2 <span class="operator">=</span> now.withDayOfMonth(<span class="number">2</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當月的第2天：&quot;</span><span class="operator">+</span>localDateTime2);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> localDateTime3 <span class="operator">=</span> now.withDayOfYear(<span class="number">66</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當年的第66天：&quot;</span><span class="operator">+</span>localDateTime3);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> localDateTime1 <span class="operator">=</span> now.withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當天最後一秒:&quot;</span> <span class="operator">+</span> localDateTime1);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> localDateTime4 <span class="operator">=</span> now.withMonth(<span class="number">1</span>).withDayOfMonth(<span class="number">30</span>).withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;當月最後一秒:&quot;</span> <span class="operator">+</span> localDateTime4);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> lastDay <span class="operator">=</span> now.with(<span class="type">TemporalAdjusters</span>.lastDayOfMonth());</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;本月最后一天:&quot;</span> <span class="operator">+</span> lastDay);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;是否潤年:&quot;</span> <span class="operator">+</span> <span class="type">Year</span>.isLeap(now.getYear()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="CompletableFuture-異步任務">          <a href="#CompletableFuture-異步任務" class="heading-link"><i class="fas fa-link"></i></a><a href="#CompletableFuture-異步任務" class="headerlink" title="CompletableFuture 異步任務"></a>CompletableFuture 異步任務</h2>              <h3 id="创建异步任务">          <a href="#创建异步任务" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h3>              <h4 id="supplyAsync-runAsync">          <a href="#supplyAsync-runAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#supplyAsync-runAsync" class="headerlink" title="supplyAsync/runAsync"></a>supplyAsync/runAsync</h4>      <p>CompletableFuture创建异步任务，一般有supplyAsync和runAsync两个方法,supplyAsync支持返回值，runAsync沒有返回值；</p>        <h5 id="supplyAsync">          <a href="#supplyAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h5>      <figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="operator">&lt;</span><span class="type">U</span><span class="operator">&gt;</span> <span class="type">CompletableFuture</span>&lt;<span class="type">U</span>&gt; supplyAsync(<span class="type">Supplier</span>&lt;<span class="type">U</span>&gt; supplier)</span><br><span class="line"><span class="comment">//自定义线程，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="operator">&lt;</span><span class="type">U</span><span class="operator">&gt;</span> <span class="type">CompletableFuture</span>&lt;<span class="type">U</span>&gt; supplyAsync(<span class="type">Supplier</span>&lt;<span class="type">U</span>&gt; supplier, <span class="type">Executor</span> executor)</span><br></pre></td></tr></table></div></figure>        <h5 id="runAsync">          <a href="#runAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h5>      <figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CompletableFuture</span>&lt;<span class="type">Void</span>&gt; runAsync(<span class="type">Runnable</span> runnable) </span><br><span class="line"><span class="comment">//自定义线程，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CompletableFuture</span>&lt;<span class="type">Void</span>&gt; runAsync(<span class="type">Runnable</span> runnable,  <span class="type">Executor</span> executor)</span><br></pre></td></tr></table></div></figure><p>实例代码</p>   <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        supplyAndRunAsyncTest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;3333：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;999&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">supplyAndRunAsyncTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//線程池</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor</span><br><span class="line">                (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3L</span>, TimeUnit.DAYS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; scf = CompletableFuture.supplyAsync(Ta::t1);<span class="comment">//使用默認的線程池 ---&gt; ForkJoinPool</span></span><br><span class="line">        CompletableFuture&lt;String&gt; scf2 = CompletableFuture.supplyAsync(Ta::t1,executor); <span class="comment">//使用自定義線程池 executor</span></span><br><span class="line">        System.out.println(scf2.get());     <span class="comment">//獲取返回值阻塞線程 需要處理異常</span></span><br><span class="line">        System.out.println(scf2.join());    <span class="comment">//獲取返回值阻塞線程 不用處理異常</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; System.out.println(<span class="number">6666</span>));<span class="comment">//使用默認的線程池 ---&gt; ForkJoinPool</span></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; System.out.println(<span class="string">&quot;6666...&quot;</span>),executor);<span class="comment">//使用自定義線程池 executor</span></span><br><span class="line">        executor.shutdown();<span class="comment">//關閉線程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>建议使用自定义的线程池，默认的线程池 ForkJoinPool(线程数量=cpu核心数-1)</p></blockquote><blockquote><p>tips: 後面帶有then的方法都是基於上面的方法使用的，執行完第一個異步任務後，會回調後面的then方法</p></blockquote>        <h3 id="任务异步回调">          <a href="#任务异步回调" class="heading-link"><i class="fas fa-link"></i></a><a href="#任务异步回调" class="headerlink" title="任务异步回调"></a>任务异步回调</h3>              <h4 id="thenRun-thenRunAsync">          <a href="#thenRun-thenRunAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#thenRun-thenRunAsync" class="headerlink" title="thenRun/thenRunAsync"></a>thenRun/thenRunAsync</h4>      <p>調用thenRun的方法和thenRun之間不能進行参数传递，也没有返回值</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;<span class="comment">//默认线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;<span class="comment">//默认线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span></span>;<span class="comment">//自定义线程池</span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        thenRunAsyncTest(); <span class="comment">//  thenRun/thenRunAsync</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">t1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(s+<span class="string">&quot;：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;999&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenRunAsyncTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;Rn1&quot;</span>))</span><br><span class="line">                .thenRun(() -&gt; System.out.println(<span class="string">&quot;0.0&quot;</span>)); <span class="comment">//和第一个方法使用一个线程池</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;Rn2&quot;</span>),es)</span><br><span class="line">                .thenRunAsync(() -&gt; System.out.println(<span class="string">&quot;1.1&quot;</span>));<span class="comment">//默認線程池</span></span><br><span class="line">        <span class="comment">//第一个方法使用的是默认线程池，第二个使用的是自定义线程池</span></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;Rn3&quot;</span>))</span><br><span class="line">                .thenRunAsync(() -&gt; System.out.println(<span class="string">&quot;2.2：&quot;</span>),es);<span class="comment">//自定義線程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="thenAccept-thenAcceptAsync">          <a href="#thenAccept-thenAcceptAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#thenAccept-thenAcceptAsync" class="headerlink" title="thenAccept/thenAcceptAsync"></a>thenAccept/thenAcceptAsync</h4>      <p>将第一个方法的执行结果，作为入参传递到thenAccept回调方法中，但是回调方法没有返回值</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span><span class="comment">//默认线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span><span class="comment">//默认线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span><span class="comment">//自定义线程池</span></span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        thenAcceptAsyncTest(); <span class="comment">//  thenAccept/thenAcceptAsync</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">t1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(s+<span class="string">&quot;：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;999--&quot;</span>+s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptAsyncTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;An1&quot;</span>))</span><br><span class="line">                .thenAccept((s)-&gt; System.out.println(s));<span class="comment">//和第一个方法使用一个线程池</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;An2&quot;</span>),es)</span><br><span class="line">                .thenAcceptAsync((s)-&gt; System.out.println(s));<span class="comment">//默認線程池</span></span><br><span class="line">        <span class="comment">//第一个方法使用的是默认线程池，第二个使用的是自定义线程池</span></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;Ta.t1(<span class="string">&quot;An3&quot;</span>))</span><br><span class="line">                .thenAcceptAsync((s)-&gt; System.out.println(s),es);<span class="comment">//自定義線程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="thenApply-thenApplyAsync">          <a href="#thenApply-thenApplyAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#thenApply-thenApplyAsync" class="headerlink" title="thenApply/thenApplyAsync"></a>thenApply/thenApplyAsync</h4>      <p>将第一个方法的执行结果，作为入参传递到thenApply回调方法中，并且回调方法是有返回值的</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span><span class="comment">//默认线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span><span class="comment">//默认线程池</span></span></span><br><span class="line"><span class="function">&lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn,Executor executor)</span><span class="comment">//自定义线程池</span></span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        thenApplyAsyncTest(); <span class="comment">//  thenApply/thenApplyAsync</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">t1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(s+<span class="string">&quot;：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;999--&quot;</span>+s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyAsyncTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; Ta.t1(<span class="string">&quot;Ayn1&quot;</span>))</span><br><span class="line">                .thenApply(s -&gt; s + <span class="string">&quot;====3333&quot;</span>);<span class="comment">//和第一个方法使用一个线程池</span></span><br><span class="line"><span class="comment">//第一个方法使用的是自定义线程池，第二个使用的是默认线程池</span></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; Ta.t1(<span class="string">&quot;Ayn2&quot;</span>),es)</span><br><span class="line">                .thenApplyAsync(s -&gt; s + <span class="string">&quot;====4444&quot;</span>);</span><br><span class="line"><span class="comment">//第一个方法使用的是默认线程池，第二个使用的是自定义线程池</span></span><br><span class="line">        CompletableFuture&lt;String&gt; ayn3 = CompletableFuture.supplyAsync(() -&gt; Ta.t1(<span class="string">&quot;Ayn3&quot;</span>))</span><br><span class="line">                .thenApplyAsync(s -&gt; s + <span class="string">&quot;====5555&quot;</span>, es);</span><br><span class="line">        System.out.println(ayn3.join());<span class="comment">//是thenApplyAsync返回的结果</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="thenCompose-thenComposeAsync">          <a href="#thenCompose-thenComposeAsync" class="heading-link"><i class="fas fa-link"></i></a><a href="#thenCompose-thenComposeAsync" class="headerlink" title="thenCompose/thenComposeAsync"></a>thenCompose/thenComposeAsync</h4>      <p>thenCompose有点类似于thenApply,thenCompose依赖上一个任务结果,上一个任务执行完后，则运行thenCompose里的CompletableFuture，返回的也是thenCompose里的CompletableFuture，而thenApply里如果嵌套了CompletableFuture,返回的结果也会嵌套CompletableFuture而thenCompose不会；thenCompose更多的是用于多个CompletableFuture的连接；</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">( Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">( Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,Executor executor)</span></span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        thenComposeAsyncTest(); <span class="comment">//  thenComposeAsyncTest</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">t1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(s+<span class="string">&quot;：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;999--&quot;</span>+s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeAsyncTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; fn = CompletableFuture.supplyAsync(() -&gt; <span class="number">666</span>);</span><br><span class="line"><span class="comment">//多个CompletableFuture连接</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; p1 = CompletableFuture.supplyAsync(() -&gt; Ta.t1(<span class="string">&quot;p&quot;</span>))</span><br><span class="line">                .thenCompose((data) -&gt; fn);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; p = CompletableFuture.supplyAsync(() -&gt; Ta.t1(<span class="string">&quot;p&quot;</span>))</span><br><span class="line">                .thenCompose((data) -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(() -&gt; data + <span class="string">&quot;66666&quot;</span>)</span><br><span class="line">                );</span><br><span class="line">        System.out.println(p.join());</span><br><span class="line">        System.out.println(p1.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="whenComplete">          <a href="#whenComplete" class="heading-link"><i class="fas fa-link"></i></a><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h4>      <p>CompletableFuture某个任务执行完成后，不论是正常完成还是出现异常都会执行whenComplete，异常为null说明是正常的反之；</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">( BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        whenCompleteTest(); <span class="comment">//  whenComplete</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whenCompleteTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="number">666</span>)</span><br><span class="line">                .whenComplete((a,throwable)-&gt;&#123;  <span class="comment">//a 上个任务的结果</span></span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    System.out.println(throwable.getMessage());</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="handle">          <a href="#handle" class="heading-link"><i class="fas fa-link"></i></a><a href="#handle" class="headerlink" title="handle"></a>handle</h4>      <p>handle和whenComplete类似，whenComplete没有返回值，handle有返回值</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function">&lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></div></figure><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        handleTest(); <span class="comment">//  handleTest</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; handle = CompletableFuture.supplyAsync(() -&gt; <span class="number">666</span>)</span><br><span class="line">                .handle((a, throwable) -&gt; &#123;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    System.out.println(throwable.getMessage());</span><br><span class="line">                    <span class="keyword">return</span> a + <span class="number">555</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(handle.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="exceptionally">          <a href="#exceptionally" class="heading-link"><i class="fas fa-link"></i></a><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4>      <p>exceptionally方法表示：用于捕捉某个任务的执行异常</p><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        exceptionallyTest(); <span class="comment">//  exceptionallyTest</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionallyTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span> / <span class="number">0</span>)</span><br><span class="line">                .exceptionally(s -&gt; &#123;</span><br><span class="line">                    s.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">555</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="组合处理">          <a href="#组合处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合处理" class="headerlink" title="组合处理"></a>组合处理</h3>              <h4 id="runAfterBoth-thenAcceptBoth-thenCombine">          <a href="#runAfterBoth-thenAcceptBoth-thenCombine" class="heading-link"><i class="fas fa-link"></i></a><a href="#runAfterBoth-thenAcceptBoth-thenCombine" class="headerlink" title="runAfterBoth/thenAcceptBoth/thenCombine"></a>runAfterBoth/thenAcceptBoth/thenCombine</h4>      <p>这三个方法都是将两个CompletableFuture组合起来，只有两个都正常执行完了才会执行某个任务；区别在于<strong>runAfterBoth</strong></p><p>没有入参也没有返回值，<strong>thenAcceptBoth</strong>将两个任务的执行结果作为方法的入参，但是无返回值；<strong>thenCombine</strong>将两个任务的执行结果作为方法的入参，有返回值；</p><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        runAfterOrAcceptOrCombineTest();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterOrAcceptOrCombineTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; fn1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">1111</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;6666&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; fn2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">2222</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//runAfterBoth</span></span><br><span class="line">        <span class="comment">//fn1和fn2的任务都执行成功后，才会执行后面的方法体,没有入参，无返回值;</span></span><br><span class="line">        fn1.runAfterBoth(fn2, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行成功了...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//thenAcceptBoth</span></span><br><span class="line">        <span class="comment">//fn1和fn2的任务都执行成功后，会将其结果作为方法入参，无返回值;</span></span><br><span class="line">        fn1.thenAcceptBoth(fn2, (a, b) -&gt; &#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;===&quot;</span> + b);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//thenCombine</span></span><br><span class="line">        <span class="comment">//fn1和fn2的任务都执行成功后，会将其结果作为方法入参，有返回值;</span></span><br><span class="line">        CompletableFuture&lt;String&gt; r = fn1.thenCombine(fn2, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(r.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="applyToEither-acceptEither-runAfterEither">          <a href="#applyToEither-acceptEither-runAfterEither" class="heading-link"><i class="fas fa-link"></i></a><a href="#applyToEither-acceptEither-runAfterEither" class="headerlink" title="applyToEither/acceptEither/runAfterEither"></a>applyToEither/acceptEither/runAfterEither</h4>      <p>这三个方法都是将两个CompletableFuture组合起来，只要其中一个执行完了就会执行某个任务,其区别在于<strong>applyToEither</strong>会将已经执行完成的任务的结果作为方法的入参，并有返回值；<strong>acceptEither</strong>同样将已经执行完成的任务的结果作为方法的入参，但是没有返回值；<strong>runAfterEither</strong>没有方法入参，也没有返回值；</p><blockquote><p>Tips：两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果；</p></blockquote><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        applyOrAcceptOrRunAfterEitherTest();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyOrAcceptOrRunAfterEitherTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; fn1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">1111</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;6666&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; fn2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">2222</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//applyToEither</span></span><br><span class="line">        <span class="comment">//fn1和fn2执行完成后，会将其执行结果作为方法入参，有返回值</span></span><br><span class="line">        CompletableFuture&lt;String&gt; res = fn1.applyToEither(fn2, (r) -&gt; r + <span class="string">&quot;...&quot;</span> + <span class="number">1</span>);</span><br><span class="line">        System.out.println(res.join());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//acceptEither</span></span><br><span class="line">        <span class="comment">//fn1和fn2执行完成后，会将其执行结果作为方法入参，没有返回值</span></span><br><span class="line">        fn1.acceptEither(fn2, (r) -&gt; System.out.println(r));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//runAfterEither</span></span><br><span class="line">        <span class="comment">//fn1和fn2执行完成后，才会执行后面的方法，没有入参，无返回值;</span></span><br><span class="line">        fn1.runAfterEither(fn2,()-&gt; System.out.println(<span class="number">66666</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="allOf-anyOf">          <a href="#allOf-anyOf" class="heading-link"><i class="fas fa-link"></i></a><a href="#allOf-anyOf" class="headerlink" title="allOf/anyOf"></a>allOf/anyOf</h4>      <p>allOf(无返回)：把多个CompletableFuture任务都组合一起执行，其中一些CompletableFuture发生异常时也不会影响其它的执行</p><p>anyOf(有返回)：把多个CompletableFuture任务都组合一起执行，只要谁执行的快，就把最快的结果作为最终结果；如果执行中出现异常，则都失败；</p><p>实例代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompletableFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AllAnyOfTest();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AllAnyOfTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; fn1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">1111</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;6666&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; fn2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">2222</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(dt(),dt2());</span><br><span class="line">        CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(dt(),dt2());</span><br><span class="line">        System.out.println(any.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;?&gt; dt()&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;6666&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;?&gt; dt2()&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;DDDDD&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="https://anlt-9570.github.io/categories/java8/"/>
    
    
  </entry>
  
  <entry>
    <title>linux分區</title>
    <link href="https://anlt-9570.github.io/2022/11/18/linux/linux-partition/"/>
    <id>https://anlt-9570.github.io/2022/11/18/linux/linux-partition/</id>
    <published>2022-11-18T03:10:21.189Z</published>
    <updated>2023-05-07T13:48:25.477Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>查看linux的分區情況(手機的linux演示)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs         10M     0   10M   0% /dev</span><br><span class="line">shm             1.2G     0  1.2G   0% /dev/shm</span><br><span class="line">/dev/sda1       3.9G  3.7G  153M  97% /</span><br><span class="line">tmpfs           473M  144K  472M   1% /run</span><br><span class="line">shared_storage  110G   76G   35G  69% /mnt/shared</span><br><span class="line">cgroup_root      10M     0   10M   0% /sys/fs/cgroup</span><br><span class="line">//只有一個分區 ----&gt; /dev/sda1</span><br></pre></td></tr></table></div></figure><p>查看該目錄屬於哪個分區</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df -h /目錄 </span><br><span class="line">df -h /usr</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1       3.9G  3.7G  153M  97% /</span><br></pre></td></tr></table></div></figure><p>使用<kbd>fdisk -l</kbd>查看本機可以識別的硬盤和分區信息</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 128 GiB, 137438953472 bytes, 268435456 sectors //硬盤的大小</span><br><span class="line">Disk model: QEMU HARDDISK   </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x129d9e93</span><br><span class="line">//已經分區的詳情</span><br><span class="line">Device     Boot   Start      End  Sectors Size Id Type</span><br><span class="line">/dev/sda1  *       2048  8390655  8388608   4G 83 Linux</span><br></pre></td></tr></table></div></figure><p>對/dev/sda硬盤分區</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.38.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">This disk is currently in use - repartitioning is probably a bad idea.</span><br><span class="line">It&#x27;s recommended to umount all file systems, and swapoff all swap</span><br><span class="line">partitions on this disk.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): m //輸入m 獲取字母對應的詳情</span><br><span class="line">Help:</span><br><span class="line">  DOS (MBR)</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit nested BSD disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">  Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br><span class="line">Command (m for help): n //輸入n 添加新的分區</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): p //選擇分區的類型 p總分區 e擴展分區</span><br><span class="line">Partition number (2-4, default 2): 2 //磁盤的序號，已經有1了，所以從開始</span><br><span class="line"></span><br><span class="line">First sector (8390656-268435455, default 8390656):  //磁盤的大小的開始位置，可直接回車或者從指定的位置開始分配</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (8390656-268435455, default 268435455): //磁盤大小的結束位置可指定或者回車，指定不能超過最大範圍</span><br><span class="line">Created a new partition 2 of type &#x27;Linux&#x27; and of size 124 GiB.</span><br><span class="line">Command (m for help): w //w保存退出</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>分配完後<kbd>lsblk</kbd>命令查看分區的詳情</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lsblk /硬盤(可去)</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda      8:0    0  128G  0 disk </span><br><span class="line">├─sda1   8:1    0    4G  0 part /var/lib/docker</span><br><span class="line">│                               /</span><br><span class="line">└─sda2   8:2    0   24G  0 part   //新分的區</span><br><span class="line">sr0     11:0    1   41M  0 rom </span><br></pre></td></tr></table></div></figure><p>對剛剛分好的區進行格式化</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda2  //磁盤加分區</span><br><span class="line">mke2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">Discarding device blocks: done                            </span><br><span class="line">Creating filesystem with 6292992 4k blocks and 1574880 inodes</span><br><span class="line">Filesystem UUID: c034819b-f8c9-4d6a-8a30-6257a26beee4</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">4096000</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done  </span><br></pre></td></tr></table></div></figure><p>把分區掛載到文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//創建好要掛載的文件</span><br><span class="line">mkdir /cus </span><br><span class="line"></span><br><span class="line">//在該文件添加信息</span><br><span class="line">vi /etc/fstab</span><br><span class="line">//要添加的信息 UUID 是在格式化的時候生成的 /cus 掛載的文件</span><br><span class="line">UUID=c034819b-f8c9-4d6a-8a30-6257a26beee4  /cus   ext4     defaults            0    0</span><br></pre></td></tr></table></div></figure><p>掛載完後重啟 <kbd>reboot</kbd></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@alpine-term ~ # df -h  //查看</span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs         10M     0   10M   0% /dev</span><br><span class="line">shm             1.2G     0  1.2G   0% /dev/shm</span><br><span class="line">/dev/sda1       3.9G  3.7G  153M  97% /</span><br><span class="line">tmpfs           473M  204K  472M   1% /run</span><br><span class="line">shared_storage  110G   76G   35G  69% /mnt/shared</span><br><span class="line">/dev/sda2        24G   24K   23G   1% /cus//這就是新分的區</span><br><span class="line">cgroup_root      10M     0   10M   0% /sys/fs/cgroup</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://anlt-9570.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>rz安裝</title>
    <link href="https://anlt-9570.github.io/2022/11/15/linux/rz_install/"/>
    <id>https://anlt-9570.github.io/2022/11/15/linux/rz_install/</id>
    <published>2022-11-15T10:13:12.573Z</published>
    <updated>2023-05-07T13:48:32.919Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>wget 下载lrzsz安装包</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</span><br></pre></td></tr></table></div></figure><p>解压，然后进入目录</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf lrzsz-0.12.20.tar.gz</span><br></pre></td></tr></table></div></figure><p>配置安装路径</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></div></figure><p>输入命令后，报错，证明虚拟机中缺少gcc，首先安装gcc：yum install gcc，再进行./configure就成功了。</p><p>编译&amp;安装</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://anlt-9570.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收,GCRoot,OOPMap</title>
    <link href="https://anlt-9570.github.io/2022/08/06/JVM/GCROOT-OOPMAP/"/>
    <id>https://anlt-9570.github.io/2022/08/06/JVM/GCROOT-OOPMAP/</id>
    <published>2022-08-06T02:22:10.039Z</published>
    <updated>2023-05-07T13:46:45.879Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="GC收集器的类型">          <a href="#GC收集器的类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#GC收集器的类型" class="headerlink" title="GC收集器的类型"></a>GC收集器的类型</h3>      <p>部分收集(Partial GC)：指目标不是完整收集整个java堆的垃圾收集</p><p>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集（新生代的Eden区满了之后触发Minor GC）</p><p>老年代(Major GC/old GC):指目标只是老年代的收集（老年代空间不足时尝试触发Minor GC，如果还不足则触发Major GC）</p><p>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代</p><p>整堆收集(Full GC):收集整个java堆和方法区（老年代或方法区等，空间不足时触发）</p>        <h3 id="如何标记对象是否存活">          <a href="#如何标记对象是否存活" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何标记对象是否存活" class="headerlink" title="如何标记对象是否存活"></a>如何标记对象是否存活</h3>      <p>判断对象是否存活就是判断对象是否被在次使用，常用的算法有引用计算和可达性分析</p><p><b>1.引用计数算法</b></p><p>引用计数就是为对象添加一个引用计数器，当有一个对象引用它时，那么该对象的引用计数加1，反之每一个引用失效时，该对象的计数就会减1，当对象的引用次数为0时，那么认为该对象不会被再次使用，通过这种方式能够快速的定位到这些可回收的对象，从而进行清理；</p><p>不过引用计数无法解决对象的循环引用问题，比如A引用B,B引用A，除此之外它们没有被任何对象引用，可能这两个对象不可能再被访问，但是它们相互引用对方，导致计数不为0，引用计数无法定位到和回收它们，另一方面就是需要而外的空间去维护引用计数器；</p><p><b>2.可达性分析</b></p><p>可达性分析是通过根对象(GCRoots)为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象到GCroot间没有任何引用链，则证明此对象不再用，可回收;</p><p>那么哪些对象可以称之为GCRoots对象呢？作为GCRoot对象需要满足一个条件，那就是它在很长一段时间内不会被GC回收；</p><p>1.虚拟机栈中的本地变量</p><p>2.方法区中常量引用的对象和静态属性引用的对象</p><p>3.本地方法中引用的对象</p><p>当我们通过可达性分析法来定位到对象是否存活后，就需要通过某种策略把这些已经死的对象进行清理，这过程涉及到三种算法，分别为：标记清除，标记复制，标记整理；</p>        <h3 id="垃圾收集算法">          <a href="#垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3>      <p>垃圾收集算法是基于分代收集理论上的(而分代收集是建立在两个分代假说上的);</p><p>1.弱分代假说：绝大多数对象都是朝生夕灭的</p><p>2.强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</p><p><b>1.标记清除</b></p><p>标记清除法是先标记内存里需要回收的对象，标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，回收未被标记的对象；不过标记清除也有它的不足之处，那就是会造成不连续的内存空间，或者当大量对象需要回收而且比较分散，清除的过程就会比较耗时；</p><p><b>2.标记复制</b></p><p>标记复制是将可用的内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块，然后在把已使用的内存空间一次清理掉；如果内存大多数对象是存活的，将会产生大量的内存复制开销；可使用的内存只有原来的一半；</p><p><b>3.标记整理</b></p><p>标记整理分为两个阶段，标记阶段和整理阶段；标记阶段会先把存活的对象和可回收的对象标记出来；标记完在堆内存进行整理，这个阶段会把存活的对象往内存的一端移动，移动完成对象后在清除存活对象边界之外的对象。</p><p>标记整理解决了标记复制法的空间浪费，又解决了标记清除的空间碎片问题；</p>        <h3 id="什么是OOPMap">          <a href="#什么是OOPMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是OOPMap" class="headerlink" title="什么是OOPMap"></a>什么是OOPMap</h3>      <p>当垃圾回收发生时，收集线程会遍历栈里的所有变量，看看哪些位置上存储了引用类型，就意味着这个引用所指向的对象在这一次不会被回收；</p><p>栈上的本地变量表只有一部分数据是引用类型的，为了避免每次垃圾收集时都要扫描整个栈，所以采用了空间换时间的策略。</p><p>HotSpot虚拟机采用了一种叫做OOPMap的数据结构用于记录栈中的对象引用，OOPMap记录了栈上本地变量到堆上对象的引用关系，这些引用关系对象不能进行回收，并且可以作为根节点进行可达性分析，查找出不能够回收的对象；</p>        <h3 id="什么是safePoint-安全点">          <a href="#什么是safePoint-安全点" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是safePoint-安全点" class="headerlink" title="什么是safePoint(安全点)"></a>什么是safePoint(安全点)</h3>      <p>在GCRoot枚举过程中，可能会导致对象的引用关系发生变化，那么保存的OOPMap就要跟着变化，如果每一条指令的执行都要去修改OOPMap的话，又是一件成本很高的事。所以就引入了安全点(safePoint)概念，只有在Safe Point才会生成或更新对应的OOPMap;</p><p>Safe Point可以理解成用户执行到特殊的位置，在这些位置上中断用户线程然后更新对应的OOPMap;</p><p>Safe Region(安全区)：就是在程序的一段代码片段中引用的关系不会发生变化，也就是不用更新OOPMap,那么在这段代码区域内进行GC不会有问题；</p>        <h3 id="GCRoots是如何枚举的？">          <a href="#GCRoots是如何枚举的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCRoots是如何枚举的？" class="headerlink" title="GCRoots是如何枚举的？"></a>GCRoots是如何枚举的？</h3>      <p>GCRoot在枚举时都必须暂停用户线程，因为整个枚举的过程必须保证在一致性的快照中进行；这里一致性是指整个枚举期间，系统看起来像被冻结在某个时间点上，不会出现GCRoot的对象引用关系还在不断变化的情况，否则枚举结果的准确性无法保证；</p><p>GCRoot的枚举过程是：(效率慢的)：遍历栈里的所有变量，逐一进行类型判断，如果是引用类信息，则属于GCRoots;(高效的)：直接扫描栈里的OOPMap,通过OOPMap获取对象的引用</p><p>GCRoot会被回收吗?：GCRoot对象不会被垃圾收集回收，它必须保持活跃状态，直到应用程序结束才能被销毁。垃圾收集器只回收那些不可达的对象，而保留GCRoot对象作为堆中对象的访问入口；</p><p>//GCRoot是怎么回收的？当当前线程出栈后，GCRoot就会被回收；</p><p>//GCRoot是怎么判定被回收的？没有被其它对象引用就会被回收；</p>        <h3 id="RemeberSet-记忆集">          <a href="#RemeberSet-记忆集" class="heading-link"><i class="fas fa-link"></i></a><a href="#RemeberSet-记忆集" class="headerlink" title="RemeberSet(记忆集)"></a>RemeberSet(记忆集)</h3>      <p>记忆集只是一种抽象的数据结构，卡表才是记忆集的具体实现；记忆集会记录下当前区的对象被哪些区对象所引用，这样一来在进行垃圾回收时，就不用进行全部扫描(就不用全部扫描新生代和老年代)，只需要扫描记忆集，就可以知道哪些对象存在跨域引用，把它们加入到GCRoots中一并扫描，缩减了扫描范围(也就是解决跨带引用的问题)；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring循环依赖问题</title>
    <link href="https://anlt-9570.github.io/2022/07/28/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://anlt-9570.github.io/2022/07/28/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-07-28T03:25:44.441Z</published>
    <updated>2023-02-17T02:10:13.494Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>循环依赖的场景就是A依赖B，B又依赖A对象；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line">public class B &#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>先了解三级缓存的各个属性</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一级缓存：用于存储已经初始化完成的对象</span><br><span class="line">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="line">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">//二级缓存：存储的是实例化完成，没有进行属性赋值的对象</span><br><span class="line">/** Cache of early singleton objects: bean name to bean instance. */</span><br><span class="line">private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">//三级缓存：单列对象工厂，存放bean工厂对象</span><br><span class="line">/** Cache of singleton factories: bean name to ObjectFactory. */</span><br><span class="line">private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</span><br></pre></td></tr></table></div></figure><p>//bean的加载过程</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//实例化bean</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="comment">//是否提前曝光</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//把实例化的对象添加到第三级缓存(解决循环依赖)</span></span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//属性填充 可能存在依赖于其它bean属性，则会递归调用</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略.....</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这个方法就是对象的初始化过程，结合以上A,B对象的情况来说一下循环依赖的一个流程是怎么解决的：</p><p>首先标记实例化对象A,把A对象的实例放到第三级缓存</p><p>属性填充，填充过程中发现需要依赖注入B,则获取B的实例</p><p>标记实例化B,并且把B的实例放到第三级缓存</p><p>属性填充，填充过程中发现需要依赖注入A,则获取A的实例</p><p>这时候是从缓存获取A的实例，先从一级缓存获取，没有则从二级缓存获取，没有则从三级缓存获取，获取到后把实例放到二级缓存，并且把三级缓存的删除掉</p><p>这时B实例初始化完成，放到一级缓存，移除二，三级缓存</p><p>B实例化完成后返回继续初始化A实例，属性装配完后，放到一级缓存，移除二，三级缓存</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从一级缓存获取实例</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//从二级缓存获取实例</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//从三级缓存获取实例</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取三级缓存实例</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//放到二级缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">//移除三级缓存的实例</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>为什么使用三级缓存而不是两级？</p><p>二级缓存也可以解决循环依赖，但是如果bean被aop进行切面后，只使用两个缓存则无法解决；</p><p>如果只有一级和三级缓存，每次先从三级缓存拿到singletonFactory，执行getObject()方法又会产生新的代理对象，这时候对象就不是单列的了，不符合spring的单列原则；所以需要借助二级缓存来解决这个问题，三级缓存产生的对象放到二级缓存中去，后面在二级缓存中会拿到的是同一个对象，就不需要在三级缓存中产生一个新的代理对象了，保证始终只有一个代理对象；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://anlt-9570.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>java运算符</title>
    <link href="https://anlt-9570.github.io/2022/06/30/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/javaOperation/"/>
    <id>https://anlt-9570.github.io/2022/06/30/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/javaOperation/</id>
    <published>2022-06-30T06:46:54.348Z</published>
    <updated>2022-06-30T06:48:49.972Z</updated>
    
    
    
    
    <category term="java" scheme="https://anlt-9570.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Keepalived+nginx集群的使用</title>
    <link href="https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/"/>
    <id>https://anlt-9570.github.io/2022/05/04/keepalived/keepalived/</id>
    <published>2022-05-04T00:59:00.380Z</published>
    <updated>2022-05-04T09:02:10.555Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>准备多台机器：144，145</p><p>使用yum安装Keepalived</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br></pre></td></tr></table></div></figure><p>安装完后，默认安装在<code>/etc/keepalived</code>该路径</p><p><code>144</code>修改keepalived.conf文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>145</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  # notification_email &#123;</span><br><span class="line">    # acassen@firewall.loc</span><br><span class="line">    # failover@firewall.loc</span><br><span class="line">    # sysadmin@firewall.loc</span><br><span class="line">  #1907402902@qq.com</span><br><span class="line">  # &#125;</span><br><span class="line">  # notification_email_from 1907402902@qq.com</span><br><span class="line">  # smtp_server smtp.qq.com</span><br><span class="line">  # smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL #全局唯一标识</span><br><span class="line">  # vrrp_skip_check_adv_addr</span><br><span class="line">  # vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;//脚本信息，必须放在vrrp_instance前面，不然不生效，注意需要有空格</span><br><span class="line">        script &quot;/etc/keepalived/nginx_check.sh&quot; //脚本的地址</span><br><span class="line">        interval 10#检测脚本执行时间间隔2s</span><br><span class="line">        weight 2#权重，如果脚本检测为真，服务器权重为2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP#主从分类 MASTER:主服务器，BACKUP：从服务器</span><br><span class="line">    interface ens33#网卡名称</span><br><span class="line">    virtual_router_id 51#主备机的VID必须都相同</span><br><span class="line">    priority 90#主备机取不同的优先级，主机值较大</span><br><span class="line">    advert_int 1#每隔1s发送心跳检测</span><br><span class="line">    authentication &#123;#检验方式类型是密码 密码1111</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP </span><br><span class="line">        #192.168.200.16#VRRP IP</span><br><span class="line">        #192.168.200.17</span><br><span class="line">        #192.168.200.18</span><br><span class="line">192.168.66.66#虚拟IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>脚本nginx_check.sh文件</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">A=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">echo &#x27;-----&gt;144...心跳检测....&#x27;</span><br><span class="line">if [ $A ];then</span><br><span class="line">echo &quot;true....&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;restarting......&quot;</span><br><span class="line">docker start nginx</span><br><span class="line">fi</span><br><span class="line">sleep 5s #时间不能大于脚本的执行间隔时间</span><br><span class="line">C=`docker ps|grep nginx|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">if [ $C ];then</span><br><span class="line">echo &quot;to start success...&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;Fails to start.....&quot;</span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>需要给脚本赋予权限，不然可能执行失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx_check.sh</span><br></pre></td></tr></table></div></figure><p>keepalived启动</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></div></figure><p>查看状态</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status keepalived.service</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.66/">http://192.168.66.66</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>tip：如果脚本没有生效，需要修改<code>/etc/selinux/config</code>文件的<code>SELINUX=disabled</code>;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="keepalived" scheme="https://anlt-9570.github.io/categories/keepalived/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx使用</title>
    <link href="https://anlt-9570.github.io/2022/04/28/nginx/n/"/>
    <id>https://anlt-9570.github.io/2022/04/28/nginx/n/</id>
    <published>2022-04-28T13:16:51.048Z</published>
    <updated>2023-05-07T13:48:51.748Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="nginx-conf文件的简单概述">          <a href="#nginx-conf文件的简单概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx-conf文件的简单概述" class="headerlink" title="nginx.conf文件的简单概述"></a>nginx.conf文件的简单概述</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main#全局配置</span><br><span class="line"></span><br><span class="line">events &#123;#工作模式与连接数上限</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123; //http服务器</span><br><span class="line"></span><br><span class="line">server &#123; //虚拟主机 可以有多个虚拟主机</span><br><span class="line">...</span><br><span class="line">location &#123;#路由配置匹配（虚拟目录等）</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location path&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">location otherPath&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123; //虚拟主机</span><br><span class="line">    ...</span><br><span class="line">    location &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">upstream name &#123;//负载均衡器</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Nginx基本使用">          <a href="#Nginx基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Nginx基本使用" class="headerlink" title="Nginx基本使用"></a>Nginx基本使用</h1>      <p>使用docker使用nginx，提前创建好挂载目录，并赋予nginx.conf权限，不然挂载失败</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 nginx.conf</span><br></pre></td></tr></table></div></figure><p>运行并挂载容器等</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 80:80 -p 801:801 -p 802:802 -p 803:803 --name nginx --privileged=true -v /opt/nginx/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#nginx运行的用户或者用户组,windows下默认是nobody可以注释掉，docker下默认nginx用户</span><br><span class="line">user  nginx;</span><br><span class="line">#nginx进程数 (cpu核心数)</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">#进程文件，windows下可以注释掉</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">#connections 20000; 每个进程应许的最多连接数</span><br><span class="line">#单个进程最大连接数(最大连接数=连接数*进程数)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">#访问日志</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">#文件的传输模式</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">#最长连接超时时间，单位秒默认0</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;d</span><br><span class="line">#虚拟主机配置</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 802; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">        server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">            location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">                root /usr/share/nginx/html; #指定目录</span><br><span class="line">                index index.html; #不配置默认index.html</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server&#123;</span><br><span class="line">    listen 803; #监听端口 或者 IP和端口(配置IP后server_name无效)</span><br><span class="line">    server_name 127.0.0.1; #(配置ip或者域名,可以有多个以空格隔开)</span><br><span class="line">    location / &#123; #配置端口之后的路由地址 / 开头表示匹配所有请求</span><br><span class="line">    root /usr/share/nginx/html; #指定目录</span><br><span class="line">    index index.html; #不配置默认index.html</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://127.0.0.1:802/">http://127.0.0.1:802/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h1 id="匹配规则">          <a href="#匹配规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#匹配规则</span><br><span class="line">server_name有三种写法：精确名称，以星号开头或者结尾，正则表达式</span><br><span class="line">例：</span><br><span class="line">server_name www.xc.com</span><br><span class="line">server_name *.com www.xc.*</span><br><span class="line">server_name www./[A-Za-z]/g.com</span><br><span class="line"></span><br><span class="line">#location匹配符号</span><br><span class="line"></span><br><span class="line">优先级</span><br><span class="line">1 =精确匹配</span><br><span class="line">2 ^~以某个字符串开头</span><br><span class="line">3 ~区分大小写的正则匹配</span><br><span class="line">3 ~*不区分大小写的正则匹配</span><br><span class="line">4 /通用匹配，任何请求都会匹配到</span><br><span class="line"></span><br><span class="line">//精确匹配</span><br><span class="line">location /index.html &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/index.html</span><br><span class="line"></span><br><span class="line">//以某个字符开头</span><br><span class="line">location ^~ /b &#123;</span><br><span class="line">default_type text/html; //响应类型</span><br><span class="line">return 200 &#x27;9999&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/boss</span><br><span class="line"></span><br><span class="line">//区分大小写</span><br><span class="line">location ~ /Cc &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/Cc</span><br><span class="line"></span><br><span class="line">//不区分大小写</span><br><span class="line">location ~ /Dd &#123;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &#x27;dd&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/dd</span><br><span class="line"></span><br><span class="line">//前缀匹配</span><br><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://127.0.0.1:802/images/b.jpg</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h1 id="反向代理">          <a href="#反向代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1>      <p>在143的主机上代理144</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 801;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://192.168.66.1:1572; //代理的ip和端口</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">访问 http://192.168.66.143:801/t</span><br></pre></td></tr></table></div></figure>        <h1 id="负载均衡">          <a href="#负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1>      <p>//默认轮训</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>负载均衡的几种策略方式；</p><p>1.轮询(默认)：轮流分发到不同的机器；</p><p>2.weight(权重)：根据权重的比率进行分发，权重越高被分配的几率越打；(ip_hash策略的时候不可用)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:1572 weight=2;</span><br><span class="line">server 192.168.66.144:1572 weight=4;</span><br><span class="line">server 192.168.66.145:1572 weight=8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>3.ip_hash：根据IP进行hash分配，每个IP都会固定访问到一个机器；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>4.fair(第三方)：根据后端响应时间来分配请求，响应时间短的分配越多；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.66.143:1572;</span><br><span class="line">server 192.168.66.144:1572;</span><br><span class="line">server 192.168.66.145:1572;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用fair之前，需要提前安装第三方插件，不然会报错，起不来;</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</span><br></pre></td></tr></table></div></figure><p>5.url_hash(第三方)</p><p>使用url_hash之前，也需要提前安装第三方插件，不然会报错，起不来;</p>        <h1 id="负载均衡调度参数">          <a href="#负载均衡调度参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#负载均衡调度参数" class="headerlink" title="负载均衡调度参数"></a>负载均衡调度参数</h1>      <p>down：表示当前机器不参与负载均衡</p><p>backup：表示当前机器为备份机器，当其它所有的机器不可用之后，请求才回到当前机器，当其他机器可用之后，当前机器</p><p>max_fails：允许请求最大失败次数，超过最大次数暂停服务，默认为1；</p><p>fail_timeout：请求处理失败后，暂停指定的时间，然后重新连接；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tt&#123;</span><br><span class="line">    server 192.168.66.1:1572 down; //</span><br><span class="line">    server 192.168.66.1:1573 backup; //备份服务器</span><br><span class="line">    server 192.168.66.1:1574 max_fails=10 fail_timeout=10s;//重试10次后，暂停10s后重新连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="nginx其它参数">          <a href="#nginx其它参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#nginx其它参数" class="headerlink" title="nginx其它参数"></a>nginx其它参数</h1>      <p>autoindex on;//列出目录内容</p><p>autoindex_exact_size on;//默认为on，显示出文件的大小</p><p>autoindex_localtime on;//显示文件的时间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    autoindex_localtime off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>allow指令：允许哪些IP访问，all表示运行所有；</p><p>deny指令：禁止哪些IP访问，all表示运行所有；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">deny all;</span><br><span class="line">allow 192.168.66.143;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://anlt-9570.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ使用</title>
    <link href="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/"/>
    <id>https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/</id>
    <published>2022-04-10T03:07:27.623Z</published>
    <updated>2023-02-24T03:48:15.399Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="RabbitMQ的几个主要成员">          <a href="#RabbitMQ的几个主要成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几个主要成员" class="headerlink" title="RabbitMQ的几个主要成员"></a>RabbitMQ的几个主要成员</h1>              <h2 id="1-Producer-生产者">          <a href="#1-Producer-生产者" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Producer-生产者" class="headerlink" title="1.Producer(生产者)"></a>1.Producer(生产者)</h2>      <p>生产消息的一端，可以指定交换机发送消息；</p><p>生产者可以在发送消息前声明Exchange(交换机)，Queue(队列)以及对于关系。</p>        <h2 id="2-Consumer-消费者">          <a href="#2-Consumer-消费者" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Consumer-消费者" class="headerlink" title="2.Consumer(消费者)"></a>2.Consumer(消费者)</h2>      <p>消费消息的一方，通过监听指定队列来消费消息。</p>        <h2 id="3-Exchange-交换机">          <a href="#3-Exchange-交换机" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Exchange-交换机" class="headerlink" title="3.Exchange(交换机)"></a>3.Exchange(交换机)</h2>      <p>用于接收、分配消息，存在多种不同类型的交换机处理特定需求。</p><p>不做存储，消息存储在队列中；交换机类型：direct(默认)，fanout，topics。</p>        <h2 id="4-Queue-队列">          <a href="#4-Queue-队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Queue-队列" class="headerlink" title="4.Queue(队列)"></a>4.Queue(队列)</h2>      <p>用于存储生产者的消息</p>        <h2 id="5-RoutingKey-路由键">          <a href="#5-RoutingKey-路由键" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-RoutingKey-路由键" class="headerlink" title="5.RoutingKey(路由键)"></a>5.RoutingKey(路由键)</h2>      <p>交换机和队列绑定的路由规则</p>        <h1 id="RabbitMQ的几种消息模型">          <a href="#RabbitMQ的几种消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的几种消息模型" class="headerlink" title="RabbitMQ的几种消息模型"></a>RabbitMQ的几种消息模型</h1>      <p>基于springboot整合rabbitmq。</p><p>依赖</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure><p>配置文件配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">admin</span></span><br></pre></td></tr></table></div></figure>        <h2 id="1-基本消息模型">          <a href="#1-基本消息模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基本消息模型" class="headerlink" title="1.基本消息模型"></a>1.基本消息模型</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/1.png" alt="1"></p><p>以上图的模型中，有以下的概念：</p><p>P：生产者，也就是发送消息的一端</p><p>C：消费者，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>RabbitMQ的配置</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列，没有该队列时，会自动配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：队列名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久化默认true</span></span><br><span class="line"><span class="comment">         * boolean exclusive：是否独占(是否只能有一个消费者监听)默认false</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有消费者是否自动删除)默认false</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;xc.com.lt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String exchange //交换机 默认&quot;&quot;</span></span><br><span class="line"><span class="comment">         * String routingKey //路由键(或者队列名)</span></span><br><span class="line"><span class="comment">         * Message message //消息内容</span></span><br><span class="line"><span class="comment">         * CorrelationData correlationData 关联的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="消息确认机制">          <a href="#消息确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5>      <p>生产者：消息投递后，如果失败了，消息就会丢失而且我们自己也不会知道</p><p>消费者：消息消费后，在队列中的消息就会被删除，不管我们有没有消费成功</p><p>那么rabbitmq是怎么知道消息是否投递或者消费成功的呢？</p><p>生产者和消费者提供了几种模式；</p><p>生产者：</p><p>​    NONE：禁用发布确认模式，默认就是这种模式</p><p>​    CORRELATED：消息发布成功后，触发回调方法</p><p>​    SIMPLE：和CORRELATED一样回触发回调，但是比CORRELATED多了一些功能，比如使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待broker节点返回结果。</p><p>生产者的配置：</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment">#开启消息发送失败退回</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></div></figure><p>消息发送后会回调这个方法</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * correlationData：投递消息时附带的信息</span></span><br><span class="line"><span class="comment">     * ack：消息是否发送成功 true：成功，false：失败</span></span><br><span class="line"><span class="comment">     * cause：失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback((correlationData, ack, cause)-&gt;&#123;</span><br><span class="line">        System.out.println(ack);</span><br><span class="line">        System.out.println(cause);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//消息回退 returnedMessage：投递的信息如：交换机，路由键，消息等</span></span><br><span class="line">    rabbitTemplate.setReturnsCallback((returnedMessage)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(returnedMessage.getMessage().getBody()));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者：</p><p>​        NONE：自动应答（默认）</p><p>​        MANUL：收到应答，需要消费端手动回复确认</p><p>​        AUTO：根据监听器是否正常返回还是抛出异常来发出ack/nack。</p><p>实现方式</p><p>方式一配置</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></div></figure><p>方式二</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span><span class="comment">//监听队列时顺便通过 ackMode指定方式</span></span><br></pre></td></tr></table></div></figure><p>修改消费者，手动应答</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    <span class="comment">//deliveryTag:消息的deliveryTag标识，rabbitmq通过deliveryTag进行匹配;multiple:是否批量确认 true批量确认反之</span></span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="2-工作队列模式">          <a href="#2-工作队列模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-工作队列模式" class="headerlink" title="2.工作队列模式"></a>2.工作队列模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/2.png" alt="2"></p><p>工作队列模式有点类似于第一种，一个生产端，多个消费端同时消费一个队列，但是一个消息只能被一个消费者消费</p><p>P：生产者，也就是发送消息的一端</p><p>C1：消费者1，接收消息的一端</p><p>C2：消费者2，接收消息的一端</p><p>queue：消息队列，图中红色的部分。可以存储消息；生产者向其投递消息，消费者从其取出消息。</p><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;xc.com.lt&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息投递成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>多个消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;xc.com.lt&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(Message message,Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有多个消费者，rabbitmq实行的是消息均摊的方式，这样每个消费者所消费的消息都会差不多；这样不是很好，可能有一些消费的会比较快，有一些消费比较慢，快的在消费完后处于空闲状态，慢的会阻塞不能及时处理。</p><p>我们可以通过prefetch属性来表示该消费者每次只能从队列处理几个消息，处理完在取。比如prefetch=1表示每次只能从该队列取一条，消息没有处理完不会分配，这样就达到能者多劳。</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#一次处理的消息数量</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></div></figure>        <h2 id="3-订阅模式">          <a href="#3-订阅模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-订阅模式" class="headerlink" title="3.订阅模式"></a>3.订阅模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/5.png" alt="3"></p><p>和上面两种不同的是，这种模式多了个交换机。生产者把消息投递到交换机，交换机把消息分发到各个队列，不用指定路由键，交换机只负责分配消息，不做存储；每个监听的消费都会同时接收到消息。</p><p>而<b>fanout</b>类型的交换机可以做到这种模式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue1&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanout_queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new Queue(&quot;fanout_queue1&quot;);或者</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout_queue2&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义fanout类型的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String name：交换机名称</span></span><br><span class="line"><span class="comment">         * boolean durable：是否持久换(默认true)</span></span><br><span class="line"><span class="comment">         * boolean autoDelete：是否自动删除(没有队列是否自动删除)(默认false)</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments：参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new FanoutExchange(&quot;fanoutExchange&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;fanoutExchange&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue1()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanout_queue2()).to(fanoutExchange()).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t4&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t4</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fanout不用指定路由键</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue1&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout_queue2&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive4</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="4-路由模式">          <a href="#4-路由模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-路由模式" class="headerlink" title="4.路由模式"></a>4.路由模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/4.png" alt="3"></p><p>生产者向交换机投递消息时，可以指定路由键，交换机会根据路由键分发到指定队列。</p><p>而<b>direct</b>类型的交换机就是这种形式；</p><p>队列和交换机声明以及绑定</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;direct_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue5()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue6()).to(directExchange()).with(<span class="string">&quot;direct.routingKey.2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生存者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t6&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t6</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.1&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t7&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t7</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;direct_exchange&quot;</span>,<span class="string">&quot;direct.routingKey.2&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_1&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span><span class="comment">//注意这种要提前把队列和交换机创建好，不然气得会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive5</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;direct_queue_2&quot;),exchange = @Exchange(&quot;direct_exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive6</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;direct_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="5-主题模式">          <a href="#5-主题模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-主题模式" class="headerlink" title="5.主题模式"></a>5.主题模式</h2>      <p><img src="https://anlt-9570.github.io/2022/04/10/MQ/RabbitMQ/rabbitmq_study/6.png" alt="3"></p><p>topics(主题)模式和routing(路由)模式类似，只不过路由模式的键是固定的，而主题模式的路由键可以模糊匹配，类似于SQL 的 = 和 like关系。<b>*</b> 号表示匹配一个 <b>#</b> 表示匹配一个或多个</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue9</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topics-queue-3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">topicsExchange2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topics-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue7()).to(topicsExchange()).with(<span class="string">&quot;topics.orange.rabbit&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue8()).to(topicsExchange()).with(<span class="string">&quot;*.orange.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicsExchangeWithQueue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue9()).to(topicsExchange()).with(<span class="string">&quot;lazy.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t8&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t8</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送后消费者1和2会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;topics.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t9</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">         <span class="comment">//发送后消费者2和3会收到消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topics-exchange&quot;</span>,<span class="string">&quot;lazy.orange.rabbit&quot;</span>,<span class="string">&quot;das&quot;</span>+a);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-a&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive7</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者1：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-b&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive8</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者2：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;topics-queue-3&quot;),exchange = @Exchange(value = &quot;topics-exchange&quot;,type = ExchangeTypes.TOPIC)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive9</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topics_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="死信队列">          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>      <p>当消息在队列中变成死信消息之后，它就会被重新转移到死信交换机(Dead-Letter-Exchange)简称DLX 。</p><p>变成死信消息的几种情况：消息被拒绝、消息过期、队列达到最大长度。</p><p>死信交换机和普通交换机没什么区别，它能够被任何的队列指定，当队列中消息成为死信消息时，就会重新发布到死信交换机上，进而路由到对应的队列上。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueDeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;deal-queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">dealExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;deal-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//普通队列绑定死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//map.put(&quot;x-message-ttl&quot;, 1000*5);//直接设置 Queue 延迟时间 但如果直接给队列设置过期时间,这种做法不是很灵活</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;deal-exchange&quot;</span>);<span class="comment">//交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;deal.routingKey.v1&quot;</span>);<span class="comment">//路由键</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;ordinary-queue-6&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">ordinaryExchange1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;ordinary-exchange-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">ordinaryBindExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue11()).to(ordinaryExchange1()).with(<span class="string">&quot;ordinary.routingKey.v2&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列与死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDealExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueDeal()).to(dealExchange1()).with(<span class="string">&quot;deal.routingKey.v1&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>生产者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">t10</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发送时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;ordinary-exchange-2&quot;</span>,<span class="string">&quot;ordinary.routingKey.v2&quot;</span>,<span class="string">&quot;AMQP-&quot;</span>+a</span><br><span class="line">                ,(message)-&gt;&#123;</span><br><span class="line">                    message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>);<span class="comment">//设置消息过期时间</span></span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消费者</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;deal-queue&quot;),exchange = @Exchange(value = &quot;deal-exchange&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive10</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收时间&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">&quot;ordinary_消费者3：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动应答</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>tip:如果队列和消息同时设置了过期时间则以最短的时间为准</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="https://anlt-9570.github.io/categories/MQ/"/>
    
    
  </entry>
  
  <entry>
    <title>docker单机、集群安装rabbitmq</title>
    <link href="https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/"/>
    <id>https://anlt-9570.github.io/2022/04/09/MQ/RabbitMQ/rabbitmq_install/</id>
    <published>2022-04-09T09:51:02.023Z</published>
    <updated>2023-02-21T11:19:14.259Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="单机安装">          <a href="#单机安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h1>      <p>拉取镜像</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>创建容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></div></figure><p>访问<kbd><span class="exturl"><a class="exturl__link" href="http://ip:15672/">http://ip:15672</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd>并登陆，用户名密码默认都是guest</p><p>tips：如果<kbd>docker pull rabbitmq</kbd>后面不带management，启动mq是无法打开管理界面的，所以下载的时候要带management插件的rabbitmq</p>        <h1 id="集群安装">          <a href="#集群安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h1>      <p>RabbitMQ集群节点包含内存节点(RAM)、磁盘节点(Disk，消息持久化，默认)、集群中至少有一个Disk节点。集群分为三种模式：普通模式、镜像模式、仲裁队列(3.8版本以上才支持)。</p><p>普通模式：普通模式中，集群中各个节点有相同的的队列结构，但消息会存在集群中的某一个节点，对于消费者来说，若消息在A节点的Queue中，当从B节点拉取时，RabbitMQ会从A中取出消息，并经过B节点发送给消费者(不过如果A已经宕机，A节点的消息将会丢失)。</p><p>镜像模式：镜像模式就有点类似于主从，一个主节点，多个从节点，队列的所有操作都在主节点上完成，主节点的数据都会备份到从节点。如果是从节点接收到操作请求，会路由到主节点完成。</p>        <h2 id="普通集群配置">          <a href="#普通集群配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通集群配置" class="headerlink" title="普通集群配置"></a>普通集群配置</h2>      <p>先准备三台机器 <code>192.168.66.143(主)</code>,<code>192.168.66.144(备)</code>,<code>192.168.66.145(备)</code></p><p>在三台机器上创建文件夹，用于挂载docker容器 <code>mkdir -p /opt/rabbitmq</code></p><p>拉取MQ镜像 <code>docker pull rabbitmq:management</code></p><p>在各个机器上配置hosts</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.66.143 hadoop03</span><br><span class="line">192.168.66.144 hadoop04</span><br><span class="line">192.168.66.145 hadoop05</span><br></pre></td></tr></table></div></figure><p>在各个机器上先搭建单机</p><figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.66.143</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop03 --name r3 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.144</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop04 --name r4 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 --add-host=<span class="string">&quot;hadoop05&quot;</span>:192.168.66.145 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#192.168.66.145</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --hostname hadoop05 --name r5 -d -p 4369:4369 --restart=always  -p 25672:25672 -p 15672:15672 -p 5672:5672 --add-host=<span class="string">&quot;hadoop04&quot;</span>:192.168.66.144 --add-host=<span class="string">&quot;hadoop03&quot;</span>:192.168.66.143 -v /opt/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="keyword">add</span><span class="bash">-host=<span class="string">&quot;hostname&quot;</span>:ip ：添加其它机器</span></span><br><span class="line">--hostname：容器的主机名称</span><br><span class="line">--name：容器名称</span><br></pre></td></tr></table></div></figure><p>RabbitMQ是基于Erlang语言的，集群中的每个RabbitMQ节点使用Erlang cookie来通信的，而且每个cookie的值都必须相同。</p><p>去主节点143上查看cookie值，并把144，145的cookie值改成143cookie的值</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cat /opt/rabbitmq/.erlang.cookie //查看143主机cookie值</span><br><span class="line"></span><br><span class="line">//修改144，145主机的cookie值，修改前必须先修改.erlang.cookie文件的权限，默认是只读权限</span><br><span class="line">$chmod 700 /opt/rabbitmq/.erlang.cookie //授予权限</span><br><span class="line"></span><br><span class="line">$vim /opt/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>192.168.66.143配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 无需太多配置，直接查看集群状态</span><br><span class="line">$ docker exec -it r3 bash</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br><span class="line">因为143是主节点，所以不需要过多的配置</span><br></pre></td></tr></table></div></figure><p>192.168.66.144配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r4 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster --ram rabbit@hadoop03 #加入集群 主节点是hadoop03 --ram表示设置为内存节点(默认disk磁盘)</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>192.168.66.145配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it r5 bash</span><br><span class="line">$ rabbitmqctl stop_app #关闭应用</span><br><span class="line">$ rabbitmqctl reset #重置</span><br><span class="line">$ rabbitmqctl join_cluster rabbit@hadoop03 #加入集群 主节点是hadoop03</span><br><span class="line">$ rabbitmqctl start_app #启动</span><br><span class="line"># 查看集群信息</span><br><span class="line">$ rabbitmqctl cluster_status</span><br></pre></td></tr></table></div></figure><p>访问各个机器的地址：<a href="http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672">http://192.168.66.143:15672，http://192.168.66.144:15672，http://192.168.66.145:15672</a></p>        <h2 id="SpringBoot集群配置使用">          <a href="#SpringBoot集群配置使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot集群配置使用" class="headerlink" title="SpringBoot集群配置使用"></a>SpringBoot集群配置使用</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    #单机连接</span><br><span class="line">    #    host: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span></span><br><span class="line">    #集群连接</span><br><span class="line">    addresses: <span class="number">192.168</span><span class="number">.66</span><span class="number">.143</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.144</span>:<span class="number">5672</span>, <span class="number">192.168</span><span class="number">.66</span><span class="number">.145</span>:<span class="number">5672</span></span><br></pre></td></tr></table></div></figure><p>集群的时候生存者发送消息才会去创建队列</p>        <h2 id="镜像集群模式">          <a href="#镜像集群模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2>      <p>镜像模式基于普通模式，且具备高可用的能力。</p><p>镜像模式的配置有3种模式：exactly(建议),all,nodes</p>        <h3 id="exactly模式-建议使用这个模式">          <a href="#exactly模式-建议使用这个模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#exactly模式-建议使用这个模式" class="headerlink" title="exactly模式(建议使用这个模式)"></a>exactly模式(建议使用这个模式)</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_exactly &quot;^test*&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">-p admin：设置指定虚拟机</span><br><span class="line">ha_exactly：策略名称</span><br><span class="line">&quot;^test*&quot;：匹配队列的正则表达式；(匹配所有名称是以test开头的队列)</span><br><span class="line">&quot;ha-mode&quot;:&quot;exactly&quot;：策略模式，此处是exactly</span><br><span class="line">&quot;ha-params&quot;:2：策略参数，为ha-mode的补充；这里是2，就是副本数量为2，1主1镜像</span><br><span class="line">&quot;ha-sync-mode&quot;:&quot;automatic&quot;：同步策略，默认是manually，即新加入的镜像节点不会同步旧的消息；如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</span><br></pre></td></tr></table></div></figure>        <h3 id="all模式">          <a href="#all模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#all模式" class="headerlink" title="all模式"></a>all模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_all &quot;^all&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">ha_all：策略名称</span><br><span class="line">&quot;^all&quot;：匹配队列的正则表达式，这里是以all开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;all&quot;：all模式</span><br></pre></td></tr></table></div></figure>        <h3 id="nodes模式">          <a href="#nodes模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#nodes模式" class="headerlink" title="nodes模式"></a>nodes模式</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$rabbitmqctl set_policy -p admin ha_nodes &quot;^nodes&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;，&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ha_nodes：策略名称</span><br><span class="line">&quot;^nodes&quot;：匹配队列的正则表达式，这里是以nodes开头的队列名称</span><br><span class="line">&quot;ha-mode&quot;:&quot;nodes&quot;：nodes模式</span><br><span class="line">&quot;ha-params&quot;:[&quot;rabbit@hadoop03&quot;,&quot;rabbit@hadoop04&quot;]：策略参数，指定副本所在节点名称</span><br></pre></td></tr></table></div></figure>        <h3 id="RabbitMQ集成Nginx统一管理控制台">          <a href="#RabbitMQ集成Nginx统一管理控制台" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ集成Nginx统一管理控制台" class="headerlink" title="RabbitMQ集成Nginx统一管理控制台"></a>RabbitMQ集成Nginx统一管理控制台</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 802;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass  http://test;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream test&#123;</span><br><span class="line">server 192.168.66.143:15672;</span><br><span class="line">server 192.168.66.144:15672;</span><br><span class="line">server 192.168.66.145:15672;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>访问 <span class="exturl"><a class="exturl__link" href="http://192.168.66.143:802/">http://192.168.66.143:802</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker+jenkins实现自动化部署</title>
    <link href="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/"/>
    <id>https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/</id>
    <published>2022-04-07T04:50:52.109Z</published>
    <updated>2023-02-19T02:42:57.253Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h2 id="docker安装Jenkins">          <a href="#docker安装Jenkins" class="heading-link"><i class="fas fa-link"></i></a><a href="#docker安装Jenkins" class="headerlink" title="docker安装Jenkins"></a>docker安装Jenkins</h2>      <p>先拉取jenkins</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br><span class="line">docker tag 镜像id jenkins //修改镜像名称方便书写</span><br></pre></td></tr></table></div></figure><p>创建jenkins的挂载目录并且授权不然容器没有权限会报错，方便后续配置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/jenkins //-p 多级目录创建</span><br><span class="line">chmod 777 jenkins //授权</span><br></pre></td></tr></table></div></figure><p>创建并运行容器</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6060:8080 -p 50000:50000 -u root --privileged=true -v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker jenkins</span><br><span class="line"></span><br><span class="line">-p 6060:8080 //jenkins默认的访问端口是8080对外设置为6060</span><br><span class="line">-p 50000:50000  //Jenkins 可以公开一个允许入站代理连接到它的 TCP 端口</span><br><span class="line">-v /opt/jenkins:/var/jenkins_home //设置挂载的目录,jenkins生成的文件也会映射到容器外部的磁盘</span><br><span class="line">-u root --privileged=true -v //以root账号运行，方便后面jenkins执行shell脚本权限不够报错</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock -v /opt/jenkins:/var/jenkins_home -v /usr/bin/docker:/usr/bin/docker //把docker也挂载到jenkins里面，执行shell脚本时需要用到docker指令，不然用不了</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器id//查看启动的结果,没有报错信息就是启动成功或者:docker ps /容器是否在运行</span><br></pre></td></tr></table></div></figure><p>启动成功后访问 <kbd><span class="exturl"><a class="exturl__link" href="http://ip:6060/">http://ip:6060</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></kbd> 访问后会提示密码在 <kbd>/var/jenkins_home/secrets/initialAdminPassword</kbd> 文件里，先进入容器，然后查看密码</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 74d93f86e4ea /bin/bash //进入容器</span><br><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword //查看密码</span><br></pre></td></tr></table></div></figure><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0.png" alt="0"></p><p>选择安装推荐的插件(这里可能需要等久一点或者会报连接jenkins报错，只要你的网络没问题,点击重试就行)，创建账号密码登录进去.</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-1.png" alt="0-1"></p><p>等待……….</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\0-2.png" alt="0-2"></p><p>插件安装完成创建用户</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/0-3.png" alt="0-3"></p><p>选择左边侧边栏的 “系统管理” 在选择 “全局工具配置”</p><p><img src="/2022/04/07/docker/dockerInstallJenkins/hexo\blogs\source_posts\docker\dockerInstallJenkins\1.png" alt="1"></p><p>往下滑，找到 <b>JDK</b> 选择jdk安装</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/2.png" alt="2"></p><p>自动安装那里，默认是打钩的我已经把它去掉。选择自己已经安装有的jdk，别名可以随意取，可以通过<kbd>echo $JAVA_HOME</kbd>查看jdk的路径然后复制到JAVA_HOME路径里</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/3.png" alt="3"></p><p>往下滑找到maven选择自动安装，然后取个别名，选择maven的版本后点击保存。</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/4.png" alt="4"></p><p>配置完<b>jdk</b>和<b>maven</b>在安装一个maven的插件，主要用于构建maven项目方便</p><p>系统管理—&gt;插件管理</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/5.png" alt="5"></p><p>选择可选插件搜索maven选择 Pipeline Maven Integration 安装，因为我这里已经安装了，所以没有,可以在已安装那里看到</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/6.png" alt="6"></p><p>回到首页选择<b>新建任务</b>就会显示刚刚安装的maven插件，没安装是没有的，输入任务名称点击<b>构建一个maven项目</b>，点击确定</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/7.png" alt="7"></p><p>点击<b>源码管理</b>选择<b>Git</b> ,<b>URL</b>那里输入<b>Github</b>或者<b>Gitee</b>仓库的地址，选择添加，会弹出一个框，要求输入<b>Github</b>或者<b>Gitee</b>的账号和密码，添加完后<b>Credentials</b>那里就可以选择刚刚添加的账号了</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/8.png" alt="8"></p><p>点击build,Root POM下需要填写<kbd>项名称/pom.xml</kbd>,不然你仓库下有多个项目的话不知道使用哪个项目的pom文件或者任务名称和项目名称不一样也会找不到pom文件。Goals and options(目标和选择)主要用于打包时需要设置的参数，比如：设置jvm的堆栈的大小或者跳过maven测试等等…</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/9.png" alt="9"></p><p>点击<b>Post Steps</b>选择<b>Add post</b>下拉框选择 <b>执行shell</b>(jenkins打包完后执行shell，启动项目)，显示一个输入框就可以在里面写shell脚本</p><p><img src="https://anlt-9570.github.io/2022/04/07/docker/dockerInstallJenkins/10.png" alt="10"></p><p>我的shell脚本</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#任务和项目必须一致，需要修改 pname ,ou,in,jport</span><br><span class="line">#!/bin/bash</span><br><span class="line">#任务名称 任务名称必须和项目名称一样</span><br><span class="line">pname=&quot;demo&quot;</span><br><span class="line">##构建容器时指定对外和对内端口</span><br><span class="line">ou=1586</span><br><span class="line">in=1586</span><br><span class="line">#jenkins端口</span><br><span class="line">jport=6060</span><br><span class="line">#会根据任务创建存放jar包目录</span><br><span class="line">p=/project/java/$pname/$pname/target</span><br><span class="line">#jenkins自动生成jar包的目录</span><br><span class="line">p3=/var/jenkins_home/workspace/$pname/$pname/target/</span><br><span class="line">#先删除以前的jar</span><br><span class="line">rm -rf $p</span><br><span class="line"></span><br><span class="line">#获取容器的id</span><br><span class="line">id=`docker ps -a|grep $pname| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#根据端口获取jenkins的容器id</span><br><span class="line">jid=`docker ps -a|grep $jport| awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">#镜像Id</span><br><span class="line">ll=`docker images|grep $pname|awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">#查找并切割获取jar包名称</span><br><span class="line">j=`find $p3 -name &#x27;*.jar&#x27; |cut -d&#x27;/&#x27; -f8`</span><br><span class="line">#判断容器是否在运行</span><br><span class="line">if [ $id ];then</span><br><span class="line"> echo $id</span><br><span class="line"> docker stop $id</span><br><span class="line"> docker rm $id</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;iiiiiiii&quot;</span><br><span class="line">fi</span><br><span class="line">#判断镜像是否存在</span><br><span class="line">if [ $ll ];then</span><br><span class="line"> docker rmi $ll</span><br><span class="line"> sleep 3</span><br><span class="line"> echo &quot;lllllll&quot;</span><br><span class="line"> echo $ll</span><br><span class="line">fi</span><br><span class="line">#创建文件</span><br><span class="line">mkdir -p $p</span><br><span class="line">#把jar复制到指定目录</span><br><span class="line">docker cp $jid:$p3/$j $p</span><br><span class="line">cd $p</span><br><span class="line">echo `pwd`</span><br><span class="line">#dockerfile创建写入</span><br><span class="line">echo &#x27;from java:8&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;add &#x27;$j&#x27; &#x27;$j&#x27;&#x27; &gt;&gt; dockerfile</span><br><span class="line">echo &#x27;entrypoint [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x27;$j&#x27;&quot;]&#x27; &gt;&gt; dockerfile</span><br><span class="line">cat dockerfile</span><br><span class="line">ls</span><br><span class="line">#运行构建容器</span><br><span class="line">docker build -t $pname .</span><br><span class="line">sleep 3</span><br><span class="line">docker run -d -p $ou:$in $pname</span><br><span class="line">exit 0</span><br></pre></td></tr></table></div></figure><p>以上jenkins和要发布的项目都是在同一太机器上运行的…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://anlt-9570.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://anlt-9570.github.io/2022/03/07/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-03-07T03:52:50.168Z</published>
    <updated>2023-05-07T13:47:26.291Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="各种垃圾收集器">          <a href="#各种垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种垃圾收集器" class="headerlink" title="各种垃圾收集器"></a>各种垃圾收集器</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Serial</span><br><span class="line">ParNew</span><br><span class="line">ParallelScavenge</span><br><span class="line">Parallel Old</span><br><span class="line">Serial Old</span><br><span class="line">CMS</span><br><span class="line">G1</span><br><span class="line">Shenandoah</span><br><span class="line">ZGC</span><br></pre></td></tr></table></div></figure><p>衡量垃圾收集器的三个指标：内存占用(Footprint)，吞吐量(Throughput)，延迟。</p>        <h3 id="Serial-收集器">          <a href="#Serial-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3>      <p>Serial收集器是最基础、历史最悠久的收集器,JDK1.3之前是HotSpot虚拟机新生代收集器的唯一选择。Serial收集器是一个单线程的收集器，它单线程的意义并不是说明它只会使用一个处理器或一条线程去完成垃圾收集，是强调在它进行垃圾收集时，必须暂停其它所有工作的线程(在用户不可知，不可控的情况下把用户正常工作的线程停掉，这种体验效果很不好—-类似余电脑运行一个小时就会暂停响应五分钟)，直到它收集结束。</p><p>它由于其它虚拟机的特点是：简单，高效(单线程相比),而外内存消耗最小。</p>        <h3 id="ParNew收集器">          <a href="#ParNew收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3>      <p>parNew收集器是Serial收集器的多线程版本，除了同时使用多线程进行垃圾收集之外，其余的行为都和Serial收集器一致。可以与CMS收集器配合工作，支持新生代的垃圾并发收集。</p>        <h3 id="ParallelScavenge收集器">          <a href="#ParallelScavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParallelScavenge收集器" class="headerlink" title="ParallelScavenge收集器"></a>ParallelScavenge收集器</h3>      <p>parallelScavenge收集器是一款新生代收集器，基于标记-复制算法，可以并行收集的多线程收集器。parallel Scavenge收集器的关注目标是达到一个可控制的吞吐量(适合在后台运算而不需要太多交互的分享任务)。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis(最大垃圾收集停顿时间，大于0的毫秒数) //时间越短，将会以牺牲吞吐量和新生代空间为代价换取</span><br><span class="line">-XX:GCTimeRatio(吞吐量大小；建议大于0小于100整数)</span><br><span class="line">-XX:+UseAdaptiveSizePolice(这是一个开关参数，激活后就不需要人工指定新生代(-Xmn),Eden、Suurvivor等细节参数，虚拟机会根据当前系统的运行情况，动态调整参数，提供最合适的停顿时间或者最大的吞吐量。)</span><br></pre></td></tr></table></div></figure>        <h3 id="Serial-Old收集器">          <a href="#Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3>      <p>Serial Old收集器是Serial收集器的老年代版本，主要用于老年代，其它都是和Serial收集器一样。</p>        <h3 id="Parallel-Old收集器">          <a href="#Parallel-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3>      <p>Parallel Old是Parallel Scavenge收集器的老年代版本，主要用于老年代，其它和Parallel Scavenge一样。</p>        <h3 id="CMS收集器">          <a href="#CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3>      <p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器；是基于标记清除算法实现的，整个过程分为四步骤：1.初始标记，2.并发标记，3.重新标记，4.并发清除。</p><p>在初始标记、重新标记这两步骤依然需要停止用户线程，并发标记、并发清除与用户线程并发执行。</p><p>初始标记只是标记一下GCRoots能直接关联到的对象，速度快；并发标记是从GC Roots的直接关联对象开始变量整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。重新标记是为了修正并发标记期间变动的对象，停顿的时间比初始标记长一些，但也远比并发标记时间短。并发清除清理被标记死亡的对象，与用户线程并发执行。</p><p>优点：并发收集、低停顿。</p><p>缺点：并发阶段占用了资源，导致应用程序变慢，吞吐量降低，碎片空间。</p>        <h3 id="Garbage-First-G1-收集器">          <a href="#Garbage-First-G1-收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First( G1 收集器)"></a>Garbage First( G1 收集器)</h3>      <p>G1是面向服务端的垃圾收集器基于标记整理算法实现的。jdk1.8默认使用的是Parallel Scanvenge加Parallel Old的组合，1.9开始将使用G1取代它们。G1不在像以前一样把java堆分为新生代和老年代，而是基于Region的堆内存布局。把连续的java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代。收集器会对扮演不同角色的Region区采用不同的策略去收集。</p><p>每个Region区中都有一个Humongous区域，专门用来存储大对象。只要超过了Region容量一半的对象判定为大对象。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：G1HeapRegionSize//可通过该参数设置Region区的大小，1到32MB,且为2的N次幂</span><br></pre></td></tr></table></div></figure><p>G1将Region作为单次回收的最小单元，避免了全区域的垃圾收集。G1会用一个优先级列表去根据Region里面的垃圾大小级回收所需要的时间去维护，然后根据用户设定的收集停顿时间优先处理收益最大的Region区。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：MaxGCPauseMillis //停顿的时间 默认200毫秒</span><br></pre></td></tr></table></div></figure><p>每个Region区都维护自己的记忆集(类似于哈斯表),跨Region引用对象通过记忆集堆解决。因此G1比其他垃圾收集器更占内存，要耗费相当于java堆容量的10%至20%的额外内存来维持记忆集。</p><p>G1的运作过程：</p><p>初始标记：标记一下GC Roots能直接关联到的对象；需要停顿线程(耗时很短)</p><p>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出回收的对象。耗时长，但可与用户线程并发执行。</p><p>最终标记：处理并发阶段遗留的SATB记录。(对用户线程做短暂的暂停)</p><p>筛选回收：更新Region的统计数据切根据回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划。(暂停用户线程)</p>        <h3 id="G1和CMS的对比">          <a href="#G1和CMS的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#G1和CMS的对比" class="headerlink" title="G1和CMS的对比"></a>G1和CMS的对比</h3>      <p>CMS是基于标记-清除算法会产生碎片空间，根据新生代老年代划分,只有一份记忆集</p><p>G1基于标记整理算法，不会产生碎片空间，根据Region区划分,每个Region区都有一个记忆集</p><p>G1垃圾收集产生的内存占用或者程序运行时的而外负载都比CMS高。</p><p>CMS适合小内存的应用上，G1适合大内存(java堆容量6GB到8GB)</p><p>CMS使用了增量更新实现了标记阶段的并发，而G1使用了原始快照</p>        <h3 id="虚拟机垃圾收集器日志">          <a href="#虚拟机垃圾收集器日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机垃圾收集器日志" class="headerlink" title="虚拟机垃圾收集器日志"></a>虚拟机垃圾收集器日志</h3>      <p>jdk9以后虚拟机的所有功能日志都收归到<kbd>-Xlog</kbd>参数上</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:[selector][output][decorators] [output-options] //默认 uptime level tags</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC //查看gc的基本信息</span><br><span class="line">-XX:+PrintGCDetails //查看GC详细信息</span><br><span class="line">-XX:+PrintHeapAtGC //查看GC前后的堆方法区可用容量变化</span><br><span class="line">//查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-XX:+Print-GCApplicationConcurrentTime以及-XX:PrintGCApplicationStoppedTime</span><br><span class="line">//查看收集器Ergonomics机制(自动设置堆空间各分代区域大小、收集目标等内容)</span><br><span class="line">-XX:+PrintAdaptive-SizePolicy</span><br><span class="line">//查看熬过收集后剩余对象的年龄分布信息</span><br><span class="line">-XX:+printTenuring-Distribution</span><br><span class="line"></span><br><span class="line">//jdk9以后</span><br><span class="line">-Xlog:gc GCTest //查看gc的基本信息</span><br><span class="line">-Xlog:gc* GCTest //查看GC详细信息</span><br><span class="line">-Xlog:gc+heap=debug //查看GC前后的堆方法区可用容量变化</span><br><span class="line">-Xlog:safepoint GCTest //查看GC过程中用户线程并发时间以及停顿时间</span><br><span class="line">-Xlog:gc+ergo*=trace</span><br><span class="line">-Xlog:gc+age=trace</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM参数调试了解</title>
    <link href="https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/"/>
    <id>https://anlt-9570.github.io/2022/03/04/JVM/JVM%E8%B0%83%E8%AF%95/</id>
    <published>2022-03-04T01:51:05.808Z</published>
    <updated>2022-06-13T09:49:53.371Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JVM参数设置">          <a href="#JVM参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line"></span><br><span class="line">jvm堆大小设置</span><br><span class="line">-Xmx3550m:设置JVM最大可用内存为3550M</span><br><span class="line">-Xms3550m:设置JVM初始内存为3550M</span><br><span class="line">-Xmn2g:设置年轻代大小为2G。整个JVM内存大小 = 年轻代大小 + 老年代大小 + 持久代大小</span><br><span class="line">-Xss128k:设置每个线程的堆栈大小</span><br><span class="line">-XX:Survivor-Ratio=8 //指定新生代和中Eden区和Survivor的比列(默认8:1)</span><br><span class="line">-XX:PretenureSizeThreshold=2 //设定大于该值的对象直接进入老年代，仅支持Serial和ParNew收集器</span><br><span class="line">-XX:MaxTenuringThreshold=1 //设置对象存活多少次，进入老年代</span><br><span class="line"></span><br><span class="line">//方法区</span><br><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize:设置元空间的最大值，默认-1</span><br><span class="line">-XX:MetaspaceSize:元空间的初始大小</span><br><span class="line"></span><br><span class="line">-XX:MaxDirectMemorySize:设置直接内存的大小，如果不指定默认和java堆的最大值(-Xmx)一致</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="java堆溢出测试">          <a href="#java堆溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆溢出测试" class="headerlink" title="java堆溢出测试"></a>java堆溢出测试</h3>      <p>只要不断的忘堆里面塞对象，并且保证GCRoots到对象有可达路径，避免垃圾回收。</p><p>将堆的大小限制为20MB不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样就不可扩展)<br>通过 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出的时候Dump出当前的内存堆以便进行事后分析</p><p>//idea的VM option中设置</p><p>-Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError</p><p>处理：</p><p>如果不是内存泄漏，检查java虚拟机的堆参数(-Xmx和-Xms)设置，与机器的内存对比，看看是否有向上跳整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。</p>        <h3 id="java虚拟机栈和本地方法栈溢出测试">          <a href="#java虚拟机栈和本地方法栈溢出测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#java虚拟机栈和本地方法栈溢出测试" class="headerlink" title="java虚拟机栈和本地方法栈溢出测试"></a>java虚拟机栈和本地方法栈溢出测试</h3>      <p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但没有效果，栈容量只能由 -Xss参数来设定。</p><p>虚拟机栈可能会抛出的两种异常：StackOverflowError(栈超过深度),OOM(内存溢出)</p><p>1.栈溢出</p><p>设置-Xss128k,写个递归死循环调用,就会抛出栈溢出</p><p>2.OOM(内存溢出)</p><p>设置-Xss128k,写个方法在方法中无限的创建线程，就会抛出OOM</p><p>处理：如果是多线程导致OOM，再不能减少线程数量和减少栈容量来换取更多的线程，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>        <h3 id="方法区和运行时常量池溢出">          <a href="#方法区和运行时常量池溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3>      <p>1.8后使用元空间代替永久代。</p><p>String::intern()是一个本地方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回常量池中这个字符串的对象引用，否则会在常量池中创建新的，并且返回引用。jdk1.6之前常量池都是分配在永久代中，可以通过 -XX:PermSize 和 -XX:MaxPermSize限制永久代的大小，即可间接限制常量池的容量。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=6M //方法区的初始大小</span><br><span class="line">-XX:MaxPermSize=6M //方法区的最大大小</span><br></pre></td></tr></table></div></figure><p>在jdk1.6中无限的调用String::intern()会发生OOM异常，但是在1.7或者1.8级以上不发生OOM，只是循环会一直进行下去。出现这种情况是因为JDK1.7级以上版本，原本存放在永久代的字符串常量池，已经被移至java堆之中，所以JDK1.7以上版本，限制方法区的容量对这个测试没效果。可以设置堆的大小，来测试(如-Xmx:6M)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM介绍</title>
    <link href="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/"/>
    <id>https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/</id>
    <published>2022-03-02T13:59:21.520Z</published>
    <updated>2023-02-16T14:37:23.489Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h1 id="虚拟机分类">          <a href="#虚拟机分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机分类" class="headerlink" title="虚拟机分类"></a>虚拟机分类</h1>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Classic VM//初代</span><br><span class="line">Exact VM//</span><br><span class="line">HotSpot 虚拟机</span><br><span class="line">J9</span><br><span class="line">Graal 虚拟机</span><br></pre></td></tr></table></div></figure>        <h1 id="类加载器子系统">          <a href="#类加载器子系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1>              <h2 id="类加载过程">          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2>      <p>类加载过程分为三个阶段：加载，链接(Linking)，初始化</p><p>1.加载：通过类的全限定名以二进制流的方式加载到内存中，生成该类的Class对象；把该类的静态存储结构转换为方法区的运行时数据结构。</p><p>加载.class的方式:通过本地，或者网络等；</p><p>2.链接(Linking)：链接又分为三个阶段：验证(Verify)，准备（Prepare），解析（Resolve）；</p><p>验证：确保当前class文件的字节流包含的信息符合当前虚拟机的要求；主要包括四种验证：文件格式，元数据，字节码，符号引用验证；例如每个class文件的开头都是以CA FE BA BE标识开头；可通过     Binary Viewe查看；</p><p>准备：为类变量(static修饰的变量，不包括被final修饰的static(编译期已分配))分配内存，设置该变量的默认初始值(0值)；(通过jclasslib工具查看)</p><p>解析：将常量池的符号引用转换为直接引用（通过：javap -v xx.class进行反编译可以看到常量池已经加载的信息，然后看方法区的引用）解析主要针对：类或接口，字段，类方法等；</p><p>3.初始化：执行类构造器方法clinit()（类变量(static)的赋值和执行静态代码块，如果类中没有静态代码块和类变量，不会生成clinit文件）多线程情况下也只会被执行一次</p>        <h2 id="类加载器">          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2>      <p>Bootstrap ClassLoad ，Extension ClassLoad，System ClassCload</p><p>JVM支持两种类加载器：引导类加载器(Bootstrap ClassLoader)，自定义类加载器(User-Define ClassLoader)(继承ClassLoader类的都属于自定义加载器)</p><p>Bootstrap ClassLoader：</p><ul><li>属于虚拟机自带的加载器</li><li>用于加载java的核心库(JAVA_HOME/jre/lib/rt.jar等)只加载包名为java，javax,sun等开头的类</li><li>加载扩展类和应用程序类加载器，没有父加载器，不继承ClassCload</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bootstrap ClassLoad类加载器加载的目录</span></span><br><span class="line">URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">    System.out.println(urL.toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Extension ClassLoad：</p><ul><li>ClassLoad类的子类</li><li>从java.ext.dirs系统属性指定的目录加载类库，或从jdk的jre/lib/ext下加载类库；用户创建的类库放在此也会加载；</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Extension  ClassLoad类加载器加载的目录</span></span><br><span class="line">String property = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s:property.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>AppClassLoader：</p><ul><li>ClassLoad类的子类</li><li>负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库</li><li>该类是程序中默认的类加载器，一般java应用的类都是由它来完成加载</li></ul><blockquote><p>用户实现自定义类加载器需要实现ClassLoader或者URLClassLoader加载器</p></blockquote>        <h2 id="双亲委派机制">          <a href="#双亲委派机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2>      <p>工作原理：如果类加载器收到了类加载的请求，它并不会自己先去加载，而是委托给父类加载器去加载；如果父加载器还存在父加载器继续递归向上委托，直到最顶层的类加载器；如果父加载器可以完成加载，就成功返回，倘若父加载器无法完成加载，则由子加载器完成；</p><blockquote><p>避免了类的重复加载，防止核心API被串改</p></blockquote>        <h1 id="运行时数据区">          <a href="#运行时数据区" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1>              <h2 id="Java虚拟机的运行时数据区分布">          <a href="#Java虚拟机的运行时数据区分布" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机的运行时数据区分布" class="headerlink" title="Java虚拟机的运行时数据区分布"></a>Java虚拟机的运行时数据区分布</h2>      <p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/20201124113636647.png" alt="0"></p>        <h3 id="程序计数器">          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3>      <p>程序计数器是线程私有的，用来记录当前线程执行到的指令行(存储指向下一条指令的地址，随着线程的生命周期而结束)。比如在多线程中，cpu会对已经就绪的线程进行随机调度，如果当前线程指令还没执行完，可能被其它线程抢到时间片，此时就需要程序计数器记录当前线程执行到的位置，当当前线程又抢到时间片后，又会从刚才记录的指令开始执行。并且程序计数器不会发生OOM(OutOfMemoryError内存溢出)</p>        <h3 id="Java虚拟机栈">          <a href="#Java虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3>      <p>java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧(用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息)，每一个方法被调用直至执行完毕的过程，对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>局部变量表存放编译期可知的八种基本数据类型和对象引用类型。</p><p>在栈中可能会发生的两种异常：StackOverflowError(栈溢出)，OutOfMemoryError(内存溢出)</p><p>如果线程请求的深度或者递归的深度大于虚拟机的深度将会抛出StackOverflowError(栈溢出)</p><p>虚拟机栈容量是可以动态的扩展，当栈扩展时无法申请到空间会抛出OOM异常，或者开太多的线程也会OOM</p><p>HotSpot虚拟机栈容量是不可以动态扩展的，所以不会由于虚拟机无法扩展而导致OOM异常;不过线程申请不到栈空间还是会OOM。</p><p>局部变量表：类似于一个一维数组，数组的每个元素叫slot(槽)，用于存储变量(基本数据类和引用类型)；32位类型的变量占1一个槽(引用类型属于32位)，64位占两个槽（使用的时候取起始位置）；</p><blockquote><p>非静态方法第一个槽默认是this，静态方法没有，所以静态方法不能用this</p></blockquote><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/2.jpg" alt="2"></p><p>操作数栈：在方法执行的过程中，根据字节码指令，写入或读取数据(入栈/出栈);主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/3.jpg" alt="3"></p><p>动态链接：将符号引用转换为直接引用；java源文件编译成字节码时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里；一个方法调用了其它方法时，就是通过常量池中指向方法符号引用表示的；</p><p><img src="https://anlt-9570.github.io/2022/03/02/JVM/%E5%88%9D%E8%AF%86JVM/4.jpg" alt="4"></p>        <h3 id="本地方法栈">          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3>      <p>本地方法栈与虚拟机栈的作用非常相似，区别在于虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务(调用其它语言的库)。</p><p>HotSpot中是直接把本地方法栈和虚拟机栈合二为一的，与虚拟机栈一样，本地方法栈也会在栈深度溢出或者扩展失败时分别抛出StackOverflow和OOM。</p>        <h3 id="java堆">          <a href="#java堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3>      <p>java堆是虚拟机所管理的内存中最大的一块，并且也是被所有线程共享的一块内存区域。在虚拟机启动时被创建，java堆主要是用来存放对象实例，数组，几乎所有的对象实例都在堆中分配内存。</p><p>java堆可以被实现成固定的大小，也可以是扩展(可通过-Xmx和-Xms设定)。如果堆中没有内存完成实例分配，并且堆无法在扩展时，虚拟机将会抛出OOM</p><p>所有线程共享java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal,Allocation Buffer,TLAB)，线程私有的缓冲区分配在Eden区，只占Eden区1/100；</p><p>堆空间基于分代收集理论细分为：</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，永久代(java7以前)；</p><p>新生代（分为：Eden区，Survivor 0区，Survivor 1区），老年代，元空间(java8及以后);</p><p>新生代和老年代的占比是1:2，而新生代中Eden区和s0,s1占比是8:1:1;</p><p>几乎所有的对象都是在Eden区new出来的；被销毁的对象大多都是在新生代；</p><blockquote><p>对象的分配过程：大多对象都会在Eden区new出来，当Eden区满了之后会触发 Minor GC/Young GC，存活的对象将会放到s0,s1其中的一个区，而空着的一个Survivor区则称为to区；当Survivor区满了之后不会直接触发GC，而是当Eden区满了之后触发Minor GC/Young GC会同时对Survivor进行GC处理，把from区存活的对象放到to区，from就会变成to，to变成from，如果from区满了之后，剩余存活的对象直接进入老年代；对象每存活一次，就会有一个计数器记录着这个对象存活了多少次，当超过15次之后，将进入到老年代或者是Survivor区相同年龄的所有对象大于Survivor空间的一半则进入老年代；老年代满后直接FGC</p></blockquote><p>设置堆空间大小的参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-Xms用来设置堆空间(年轻代+老年代)的初始内存大小</span><br><span class="line">-X jvm的运行参数</span><br><span class="line">msmemory start</span><br><span class="line">-Xmx设置堆空间的最大内存大小</span><br><span class="line">-Xmn设置新生代的空间大小</span><br><span class="line">//堆空间的默认大小</span><br><span class="line">初始内存大小：物理电脑内存大小的1/64</span><br><span class="line">最大内存大小：物理电脑内存大小的1/4</span><br><span class="line">    </span><br><span class="line">//获取jvm的堆初始内存总量</span><br><span class="line">long initMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;</span><br><span class="line">//获取jvm的最大内存总量</span><br><span class="line">long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;</span><br><span class="line">System.out.println(&quot;-Xms:&quot;+initMemory+&quot;M&quot;);</span><br><span class="line">System.out.println(&quot;-Xmx:&quot;+maxMemory+&quot;M&quot;);</span><br><span class="line"></span><br><span class="line">jstat -gc 进程id//查看jvm的使用情况 在黑窗口使用</span><br><span class="line">-XX:+PrintGCDetails //GC的详细处理信息</span><br><span class="line"></span><br><span class="line">//新生代和老年代的占比配置</span><br><span class="line">默认：-XX:NewRation=2,表示新生代占1，老年代占2，新生代占整个堆的1/3</span><br><span class="line">可以修改：-XX:NewRation=4,表示新生代占1，老年代占4，新生代占整个堆的1/5</span><br><span class="line">//配置新生代中Eden区和Survivor的占比</span><br><span class="line">-XX:SurvivorRation=8;</span><br></pre></td></tr></table></div></figure><p>逃逸分析：逃逸分析的基本行为就是分析对象的动态作用域；</p><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有逃逸分析；</p><p>反之它被外部方法引用，则发生逃逸。例如作为调用参数传递到其它方法；</p><p>没有发生逃逸的对象，则可以分配到栈上，随着方法的结束，栈空间的对象就被移除；</p><p>代码优化：栈上分配，标量替换；</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存上的分配</span><br><span class="line">Person person = new Person();</span><br><span class="line">Person:方法区</span><br><span class="line">person:栈</span><br><span class="line">new Person():堆</span><br></pre></td></tr></table></div></figure><p>java8开始，静态变量，字符串常量池移到堆中；</p>        <h3 id="方法区">          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3>      <p>java7之前叫永久代（Perm）,java8之后叫元空间（meta space）</p><p>方法区和堆一样也是被线程共享的内存区域，内存大小可固定或者扩展；用于存储被虚拟机加载的类型信息，运行时常量池(常量，静态变量)等。元空间不在虚拟机设置的内存中，而是使用本地内存；方法区也会OOM;</p><p>方法区的初始大小默认21m,最大内存没有限制；</p><p>方法区参数设置</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=100m //初始大小</span><br><span class="line">-XX:MaxMetaspaceSize=1000m //最大值</span><br></pre></td></tr></table></div></figure><p>运行时常量池是方法区的一部分，存储编译期生成的各种字面量与符号引用</p><p>JDK1.8取消了永久代，取代永久代的是元空间。元空间属于本地内存，存储内容不同，元空间存储类的元信息，静态变量和常量池并入堆中。常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名参数等；</p>        <h3 id="直接内存-堆外内存">          <a href="#直接内存-堆外内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3>      <p>直接内存并不是虚拟机运行时数据区的一部分,也不属于虚拟机规范，但是因为被频繁的使用(NIO)，才划出这一块，而且也可能导致OOM.</p><p>可以直接使用Native函数库直接分配堆外内存，然后通过在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>为什么要设置直接内存呢：</p><p>java本身无法对磁盘读写，想要进行磁盘读写必须调用操作系统的方法(Native),调用操作系统方法的时候，CPU会切换到内核态。内核态期间，CPU函数读取磁盘文件，同时在操作系统内存中开辟一块系统缓存，将读取的数据写入到系统缓存区，但是java不能直接读取系统缓存，所以java会在堆内存中开辟自己的缓存区，java再次从系统缓存将数据读取到java缓存区。由于产生了两块缓存区导致访问速度缓慢。</p><p>调用ByteBuffer.allocateDirect()时，会分配一块直接内存，java和系统可以共享该区域，减少一次读写操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM工具</title>
    <link href="https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/"/>
    <id>https://anlt-9570.github.io/2022/03/01/JVM/JVM%E6%8C%87%E4%BB%A4/</id>
    <published>2022-03-01T02:42:32.346Z</published>
    <updated>2022-05-17T06:05:16.558Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span>        <h3 id="JPS">          <a href="#JPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3>      <p>JPS 查看当前运行的java进程</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jps [-lvm] ：用于查看当前机器上运行的java进程</span><br><span class="line">命令格式：</span><br><span class="line">jps [options] [hostid] //hostid不知道默认为当前主机或服务器</span><br><span class="line"></span><br><span class="line">options参数：</span><br><span class="line">-q 不输出类名,jar名和传入的main方法参数</span><br><span class="line">-m 输出传入的main方法参数</span><br><span class="line">-l 输出main类或jar的全限名</span><br><span class="line">-v 输出传入的jvm参数</span><br><span class="line">jps -l,jps -m</span><br></pre></td></tr></table></div></figure><!-- more -->        <h3 id="jstat">          <a href="#jstat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3>      <p>jstat用于生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机每一条线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因，如线程死锁，死循环等。</p><p>jstat (用于监视虚拟机运行时状态信息的命令，可以显示出虚拟机进程中的类加载，内存，垃圾收集等运行数据)</p><p>格式：jstat [option] pid [interval] [count]</p><p>interval 连续输出的时间间隔</p><p>count 连续输出的次数</p><p>option 操作参数</p><p>​    -class 监视类加载，卸载数量，总空间以及耗费的时间</p><p>​    jstat -class 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loaded：加载class的数量</span><br><span class="line">Bytes：已加载class字节大小</span><br><span class="line">Unloaded：未加载class的数量</span><br><span class="line">Bytes：未加载class字节大小</span><br><span class="line">Time：加载时间</span><br></pre></td></tr></table></div></figure><p>​    -gc 垃圾回收堆的行为统计</p><p>​    jstat -gc 22324</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C即Capacity 总容量，U即Used 已使用的容量</span><br><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></div></figure><p>-gccapacity 同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NGCMN：新生代最小容量</span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line">NGC：当前新生代容量</span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line">OGC：当前老年代大小</span><br><span class="line">OC:当前老年代大小</span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line">YGC：年轻代gc次数</span><br><span class="line">FGC：老年代GC次数</span><br></pre></td></tr></table></div></figure><p>-gcutil 同-gc，不过输出的是已使用空间占总空间的百分比</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S0：幸存1区当前使用比例</span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line">O：老年代使用比例</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></div></figure>        <h3 id="jmap">          <a href="#jmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3>      <p>jmap：用于生成heap dump文件</p><p>-XX:+HeapDumpOnOutOfMemoryError参数可以让虚拟机出现OOM的时候·自动生成dump文件。</p><p>jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><p>命令格式：jmap [option] pid</p><p>option参数：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump: 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>-dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/data/dump.hprof 21275</span><br><span class="line">jmap -dump:format=b,file=/data/dump.hprof 21275 //所有</span><br></pre></td></tr></table></div></figure>        <h3 id="jhat">          <a href="#jhat" class="heading-link"><i class="fas fa-link"></i></a><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3>      <p>jhat命令是与jmap搭配使用。用来分析jmap生成的dump</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat -port 9010 heapLive.hprof //以html的形式显示出来</span><br></pre></td></tr></table></div></figure>        <h3 id="可视化工具">          <a href="#可视化工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3>      <p>VisualVM,JConsole,JMC等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://anlt-9570.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://anlt-9570.github.io/2022/02/23/Thread/volatile/"/>
    <id>https://anlt-9570.github.io/2022/02/23/Thread/volatile/</id>
    <published>2022-02-23T12:27:35.048Z</published>
    <updated>2023-02-19T02:45:36.193Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><p>java提供了一种稍微弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。被volatile声明后，编译器不会将该变量上的操作与其它内存操作一起重排序，不会缓存在寄存器或者其它处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronize关键字更轻量级别的同步机制。</p><p>volatile保证了共享变量的可见性</p><p>volatile通常用作某个操作完成，发生中断或者状态的标记。</p><p>满足一下条件，才应该使用volatile变量：</p><p>1.对变量的写入操作不依赖当前值，或者能确保只有单个线程更新变量的值</p><p>2.该变量不会与其它状态变量一起纳入不变性条件中</p><p>3.在访问变量时不需要加锁</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="volatile" scheme="https://anlt-9570.github.io/categories/volatile/"/>
    
    
  </entry>
  
  <entry>
    <title>redis的应用场景</title>
    <link href="https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://anlt-9570.github.io/2022/02/18/redis/redis_%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-02-18T03:55:50.029Z</published>
    <updated>2023-02-19T02:46:05.175Z</updated>
    
    <content type="html"><![CDATA[<p><b></b></p><span id="more"></span><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(列表)：做最新日志列表</span><br><span class="line">zset(有序集合)：做常见日志统计</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动补全功能：使用有序集合，遍历所有字符，完整的字符末尾做个标记</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx：做分布式锁</span><br></pre></td></tr></table></div></figure><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浏览记录</span><br><span class="line">使用有序集合(zset)</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://anlt-9570.github.io/categories/redis/"/>
    
    
  </entry>
  
</feed>
